
/*
 * DO NOT EDIT THIS FILE!!!
 *
 * It was automatically generated from the ISA description in arm/isa/main.isa
 */

#include "base/bitfield.hh" // for bitfield support


#include <iostream>
#include <sstream>

#include "arch/arm/insts/branch.hh"
#include "arch/arm/insts/macromem.hh"
#include "arch/arm/insts/mem.hh"
#include "arch/arm/insts/misc.hh"
#include "arch/arm/insts/mult.hh"
#include "arch/arm/insts/pred_inst.hh"
#include "arch/arm/insts/static_inst.hh"
#include "arch/arm/insts/vfp.hh"
#include "arch/arm/isa_traits.hh"
#include "mem/packet.hh"
#include "sim/faults.hh"


namespace ArmISAInst {

#undef ENCODING
#define ENCODING	machInst.encoding
#undef OPCODE
#define OPCODE	machInst.opcode
#undef MEDIA_OPCODE
#define MEDIA_OPCODE	machInst.mediaOpcode
#undef MEDIA_OPCODE2
#define MEDIA_OPCODE2	machInst.mediaOpcode2
#undef USEIMM
#define USEIMM	machInst.useImm
#undef OPCODE_24
#define OPCODE_24	machInst.opcode24
#undef OPCODE_24_23
#define OPCODE_24_23	machInst.opcode24_23
#undef OPCODE_23_20
#define OPCODE_23_20	machInst.opcode23_20
#undef OPCODE_23_21
#define OPCODE_23_21	machInst.opcode23_21
#undef OPCODE_22
#define OPCODE_22	machInst.opcode22
#undef OPCODE_20
#define OPCODE_20	machInst.opcode20
#undef OPCODE_19_16
#define OPCODE_19_16	machInst.opcode19_16
#undef OPCODE_19
#define OPCODE_19	machInst.opcode19
#undef OPCODE_18
#define OPCODE_18	machInst.opcode18
#undef OPCODE_15_12
#define OPCODE_15_12	machInst.opcode15_12
#undef OPCODE_15
#define OPCODE_15	machInst.opcode15
#undef MISC_OPCODE
#define MISC_OPCODE	machInst.miscOpcode
#undef OPC2
#define OPC2	machInst.opc2
#undef OPCODE_7
#define OPCODE_7	machInst.opcode7
#undef OPCODE_6
#define OPCODE_6	machInst.opcode6
#undef OPCODE_4
#define OPCODE_4	machInst.opcode4
#undef IS_MISC
#define IS_MISC	machInst.isMisc
#undef SEVEN_AND_FOUR
#define SEVEN_AND_FOUR	machInst.sevenAndFour
#undef THUMB
#define THUMB	machInst.thumb
#undef BIGTHUMB
#define BIGTHUMB	machInst.bigThumb
#undef COND_CODE
#define COND_CODE	machInst.condCode
#undef S_FIELD
#define S_FIELD	machInst.sField
#undef RN
#define RN	machInst.rn
#undef RD
#define RD	machInst.rd
#undef RT
#define RT	machInst.rt
#undef SHIFT_SIZE
#define SHIFT_SIZE	machInst.shiftSize
#undef SHIFT
#define SHIFT	machInst.shift
#undef RM
#define RM	machInst.rm
#undef RS
#define RS	machInst.rs
#undef PUSWL
#define PUSWL	machInst.puswl
#undef PREPOST
#define PREPOST	machInst.puswl.prepost
#undef UP
#define UP	machInst.puswl.up
#undef PSRUSER
#define PSRUSER	machInst.puswl.psruser
#undef WRITEBACK
#define WRITEBACK	machInst.puswl.writeback
#undef LOADOP
#define LOADOP	machInst.puswl.loadOp
#undef PUBWL
#define PUBWL	machInst.pubwl
#undef IMM
#define IMM	machInst.imm
#undef IMMED_11_0
#define IMMED_11_0	machInst.immed11_0
#undef IMMED_7_0
#define IMMED_7_0	machInst.immed7_0
#undef IMMED_HI_11_8
#define IMMED_HI_11_8	machInst.immedHi11_8
#undef IMMED_LO_3_0
#define IMMED_LO_3_0	machInst.immedLo3_0
#undef IMMED_23_0
#define IMMED_23_0	machInst.immed23_0
#undef CPNUM
#define CPNUM	machInst.cpNum
#undef FN
#define FN	machInst.fn
#undef FD
#define FD	machInst.fd
#undef FPREGIMM
#define FPREGIMM	machInst.fpRegImm
#undef FM
#define FM	machInst.fm
#undef FPIMM
#define FPIMM	machInst.fpImm
#undef PUNWL
#define PUNWL	machInst.punwl
#undef M5FUNC
#define M5FUNC	machInst.m5Func
#undef TOPCODE_15_13
#define TOPCODE_15_13	machInst.topcode15_13
#undef TOPCODE_13_11
#define TOPCODE_13_11	machInst.topcode13_11
#undef TOPCODE_12_11
#define TOPCODE_12_11	machInst.topcode12_11
#undef TOPCODE_12_10
#define TOPCODE_12_10	machInst.topcode12_10
#undef TOPCODE_11_9
#define TOPCODE_11_9	machInst.topcode11_9
#undef TOPCODE_11_8
#define TOPCODE_11_8	machInst.topcode11_8
#undef TOPCODE_10_9
#define TOPCODE_10_9	machInst.topcode10_9
#undef TOPCODE_10_8
#define TOPCODE_10_8	machInst.topcode10_8
#undef TOPCODE_9_6
#define TOPCODE_9_6	machInst.topcode9_6
#undef TOPCODE_7
#define TOPCODE_7	machInst.topcode7
#undef TOPCODE_7_6
#define TOPCODE_7_6	machInst.topcode7_6
#undef TOPCODE_7_5
#define TOPCODE_7_5	machInst.topcode7_5
#undef TOPCODE_7_4
#define TOPCODE_7_4	machInst.topcode7_4
#undef TOPCODE_3_0
#define TOPCODE_3_0	machInst.topcode3_0
#undef HTOPCODE_12_11
#define HTOPCODE_12_11	machInst.htopcode12_11
#undef HTOPCODE_10_9
#define HTOPCODE_10_9	machInst.htopcode10_9
#undef HTOPCODE_9
#define HTOPCODE_9	machInst.htopcode9
#undef HTOPCODE_9_8
#define HTOPCODE_9_8	machInst.htopcode9_8
#undef HTOPCODE_9_5
#define HTOPCODE_9_5	machInst.htopcode9_5
#undef HTOPCODE_9_4
#define HTOPCODE_9_4	machInst.htopcode9_4
#undef HTOPCODE_8
#define HTOPCODE_8	machInst.htopcode8
#undef HTOPCODE_8_7
#define HTOPCODE_8_7	machInst.htopcode8_7
#undef HTOPCODE_8_6
#define HTOPCODE_8_6	machInst.htopcode8_6
#undef HTOPCODE_8_5
#define HTOPCODE_8_5	machInst.htopcode8_5
#undef HTOPCODE_7
#define HTOPCODE_7	machInst.htopcode7
#undef HTOPCODE_7_5
#define HTOPCODE_7_5	machInst.htopcode7_5
#undef HTOPCODE_6
#define HTOPCODE_6	machInst.htopcode6
#undef HTOPCODE_6_5
#define HTOPCODE_6_5	machInst.htopcode6_5
#undef HTOPCODE_5_4
#define HTOPCODE_5_4	machInst.htopcode5_4
#undef HTOPCODE_4
#define HTOPCODE_4	machInst.htopcode4
#undef HTRN
#define HTRN	machInst.htrn
#undef HTS
#define HTS	machInst.hts
#undef LTOPCODE_15
#define LTOPCODE_15	machInst.ltopcode15
#undef LTOPCODE_11_8
#define LTOPCODE_11_8	machInst.ltopcode11_8
#undef LTOPCODE_7_6
#define LTOPCODE_7_6	machInst.ltopcode7_6
#undef LTOPCODE_7_4
#define LTOPCODE_7_4	machInst.ltopcode7_4
#undef LTOPCODE_4
#define LTOPCODE_4	machInst.ltopcode4
#undef LTRD
#define LTRD	machInst.ltrd
#undef LTCOPROC
#define LTCOPROC	machInst.ltcoproc

    template <class T>
    // Implement a less-than-zero function: ltz()
    // this function exists because some versions of GCC complain when a
    // comparison is done between a unsigned variable and 0 and for GCC 4.2
    // there is no way to disable this warning
    inline bool ltz(T t);

    template <>
    inline bool ltz(uint8_t) { return false; }
    template <>
    inline bool ltz(uint16_t) { return false; }
    template <>
    inline bool ltz(uint32_t) { return false; }
    template <>
    inline bool ltz(uint64_t) { return false; }
    template <>
    inline bool ltz(int8_t v) { return v < 0; }
    template <>
    inline bool ltz(int16_t v) { return v < 0; }
    template <>
    inline bool ltz(int32_t v) { return v < 0; }
    template <>
    inline bool ltz(int64_t v) { return v < 0; }

        template <typename T>
            struct bigger_type_t;

        template<> struct bigger_type_t<uint8_t> { typedef uint16_t type; };
        template<> struct bigger_type_t<uint16_t> { typedef uint32_t type; };
        template<> struct bigger_type_t<uint32_t> { typedef uint64_t type; };

        template<> struct bigger_type_t<int8_t> { typedef int16_t type; };
        template<> struct bigger_type_t<int16_t> { typedef int32_t type; };
        template<> struct bigger_type_t<int32_t> { typedef int64_t type; };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldr".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrt".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrb".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrbt".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AY_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AY_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_IMM_AN_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsb".
     */
    class LOAD_REG_AN_PN_SY_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AY_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AY_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_IMM_AN_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsbt".
     */
    class LOAD_REG_AN_PN_SY_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_IMM_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrh".
     */
    class LOAD_REG_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_IMM_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrht".
     */
    class LOAD_REG_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AY_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AY_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AN_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AN_PY_SY_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AY_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AY_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_IMM_AN_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "hdrsh".
     */
    class LOAD_REG_AN_PN_SY_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PY_SY_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AY_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AY_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_IMM_AN_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LOAD_IMM_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrsht".
     */
    class LOAD_REG_AN_PN_SY_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        LOAD_REG_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrd".
     */
    class LOAD_REGD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        LOAD_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "rfe".
     */
    class RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8 : public RfeOp
    {
      public:

        /// Constructor.
        RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _base, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pld".
     */
    class PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pldw".
     */
    class PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "pli".
     */
    class PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrex".
     */
    class LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrexh".
     */
    class LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrexb".
     */
    class LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "ldrexd".
     */
    class LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vldr".
     */
    class VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

        /**
         * Static instruction class for "svc".
         */
        class Svc : public PredOp
        {
          public:
                /// Constructor.
                Svc(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

class MrsCpsr : public MrsOp
{
  protected:
    public:
        // Constructor
        MrsCpsr(ExtMachInst machInst, IntRegIndex _dest);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MrsSpsr : public MrsOp
{
  protected:
    public:
        // Constructor
        MrsSpsr(ExtMachInst machInst, IntRegIndex _dest);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MsrCpsrReg : public MsrRegOp
{
  protected:
    public:
        // Constructor
        MsrCpsrReg(ExtMachInst machInst, IntRegIndex _op1, uint8_t mask);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MsrSpsrReg : public MsrRegOp
{
  protected:
    public:
        // Constructor
        MsrSpsrReg(ExtMachInst machInst, IntRegIndex _op1, uint8_t mask);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MsrCpsrImm : public MsrImmOp
{
  protected:
    public:
        // Constructor
        MsrCpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MsrSpsrImm : public MsrImmOp
{
  protected:
    public:
        // Constructor
        MsrSpsrImm(ExtMachInst machInst, uint32_t imm, uint8_t mask);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Rev : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rev(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Rev16 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rev16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Revsh : public RegRegOp
{
  protected:
    public:
        // Constructor
        Revsh(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Rbit : public RegRegOp
{
  protected:
    public:
        // Constructor
        Rbit(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Clz : public RegRegOp
{
  protected:
    public:
        // Constructor
        Clz(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Ssat : public RegImmRegShiftOp
{
  protected:
    public:
        // Constructor
        Ssat(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usat : public RegImmRegShiftOp
{
  protected:
    public:
        // Constructor
        Usat(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Ssat16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Ssat16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usat16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Usat16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxtb : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxtb(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxtab : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtab(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxtb16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxtb16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxtab16 : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtab16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxth : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Sxth(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sxtah : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Sxtah(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxtb : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxtb(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxtab : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtab(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxtb16 : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxtb16(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxtab16 : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtab16(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxth : public RegImmRegOp
{
  protected:
    public:
        // Constructor
        Uxth(ExtMachInst machInst,
                       IntRegIndex _dest, uint64_t _imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uxtah : public RegRegRegImmOp
{
  protected:
    public:
        // Constructor
        Uxtah(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                       uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sel : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Sel(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usad8 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Usad8(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usada8 : public RegRegRegRegOp
{
  protected:
    public:
        // Constructor
        Usada8(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       IntRegIndex _op2, IntRegIndex _op3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "bkpt".
         */
        class BkptInst : public PredOp
        {
          public:
                /// Constructor.
                BkptInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "nop".
         */
        class NopInst : public PredOp
        {
          public:
                /// Constructor.
                NopInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "yield".
         */
        class YieldInst : public PredOp
        {
          public:
                /// Constructor.
                YieldInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wfe".
         */
        class WfeInst : public PredOp
        {
          public:
                /// Constructor.
                WfeInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wfi".
         */
        class WfiInst : public PredOp
        {
          public:
                /// Constructor.
                WfiInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "sev".
         */
        class SevInst : public PredOp
        {
          public:
                /// Constructor.
                SevInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "it".
         */
        class ItInst : public PredOp
        {
          public:
                /// Constructor.
                ItInst(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "unknown".
         */
        class Unknown : public UnknownOp
        {
          public:
                /// Constructor.
                Unknown(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

class Ubfx : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Ubfx(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sbfx : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Sbfx(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Bfc : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Bfc(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Bfi : public RegRegImmImmOp
{
  protected:
    public:
        // Constructor
        Bfi(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1,
                       uint64_t _imm1, uint64_t _imm2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mrc14 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mrc14(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mcr14 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mcr14(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mrc14User : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mrc14User(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mcr14User : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mcr14User(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mrc15 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mrc15(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mcr15 : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mcr15(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mrc15User : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mrc15User(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mcr15User : public RegRegOp
{
  protected:
    public:
        // Constructor
        Mcr15User(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "enterx".
         */
        class Enterx : public PredOp
        {
          public:
                /// Constructor.
                Enterx(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "leavex".
         */
        class Leavex : public PredOp
        {
          public:
                /// Constructor.
                Leavex(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

class Setend : public ImmOp
{
  protected:
    public:
        // Constructor
        Setend(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "clrex".
         */
        class Clrex : public PredOp
        {
          public:
                /// Constructor.
                Clrex(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "isb".
         */
        class Isb : public PredOp
        {
          public:
                /// Constructor.
                Isb(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dsb".
         */
        class Dsb : public PredOp
        {
          public:
                /// Constructor.
                Dsb(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dmb".
         */
        class Dmb : public PredOp
        {
          public:
                /// Constructor.
                Dmb(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dbg".
         */
        class Dbg : public PredOp
        {
          public:
                /// Constructor.
                Dbg(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

class Cps : public ImmOp
{
  protected:
    public:
        // Constructor
        Cps(ExtMachInst machInst, uint64_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "str".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ4Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ4 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ4Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ4 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strt".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ4 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strb".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ1Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ1 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ1Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ1 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strbt".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ1 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PY_SN_UN_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_IMM_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strh".
     */
    class STORE_REG_AN_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ2Acc : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PY_SN_UY_WY_SZ2 : public MemoryPostIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ2Acc : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WY_SZ2 : public MemoryPreIndex<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AY_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_IMM_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        STORE_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strht".
     */
    class STORE_REG_AN_PN_SN_UY_WN_SZ2 : public MemoryOffset<MemoryReg>
    {
      public:

        /// Constructor.
        STORE_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "srs".
     */
    class SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8 : public SrsOp
    {
      public:

        /// Constructor.
        SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                uint32_t _regMode, int _mode, bool _wb);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PY_SN_UN_WY_SZ4 : public MemoryPostIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WY_SZ4 : public MemoryPreIndex<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strd".
     */
    class STORE_REGD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDReg>
    {
      public:

        /// Constructor.
        STORE_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add,
                int32_t _shiftAmt, uint32_t _shiftType,
                uint32_t _index);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strex".
     */
    class STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexh".
     */
    class STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexb".
     */
    class STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1 : public MemoryOffset<MemoryExImm>
    {
      public:

        /// Constructor.
        STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _base,
                bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "strexd".
     */
    class STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryExDImm>
    {
      public:

        /// Constructor.
        STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _result, uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "vstr".
     */
    class VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4 : public MemoryOffset<MemoryDImm>
    {
      public:

        /// Constructor.
        VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
                uint32_t _dest, uint32_t _dest2,
                uint32_t _base, bool _add, int32_t _imm);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "swp".
     */
    class Swp : public Swap
    {
      public:

        /// Constructor.
        Swp(ExtMachInst machInst,
                uint32_t _dest, uint32_t _op1, uint32_t _base);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    /**
     * Static instruction class for "swpb".
     */
    class Swpb : public Swap
    {
      public:

        /// Constructor.
        Swpb(ExtMachInst machInst,
                uint32_t _dest, uint32_t _op1, uint32_t _base);

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroLdrUop : public MicroMemOp
    {
      public:
        MicroLdrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroLdrRetUop : public MicroMemOp
    {
      public:
        MicroLdrRetUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroLdrFpUop : public MicroMemOp
    {
      public:
        MicroLdrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroLdrDBFpUop : public MicroMemOp
    {
      public:
        MicroLdrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroLdrDTFpUop : public MicroMemOp
    {
      public:
        MicroLdrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroStrUop : public MicroMemOp
    {
      public:
        MicroStrUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroStrFpUop : public MicroMemOp
    {
      public:
        MicroStrFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroStrDBFpUop : public MicroMemOp
    {
      public:
        MicroStrDBFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroStrDTFpUop : public MicroMemOp
    {
      public:
        MicroStrDTFpUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, bool _up,
                       uint8_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon1Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon1_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon1Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon1Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon1_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon2Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon2_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon2Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon2Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon2_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon3Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon3_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon3Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon3Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon3_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon4Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon4_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon4Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon4Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon4_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon6Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon6_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon6Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon6Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon6_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon8Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon8_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon8Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon8Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon8_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon12Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon12_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon12Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon12Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon12_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroLdrNeon16Uop : public MicroNeonMemOp
    {
      public:
        MicroLdrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("ldrneon16_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroStrNeon16Uop : public MicroNeonMemOp
    {
      public:
        MicroStrNeon16Uop(ExtMachInst machInst, RegIndex _dest,
                       RegIndex _ura, uint32_t _imm, unsigned extraMemFlags)
            : MicroNeonMemOp("strneon16_uop", machInst,
                              FloatAddOp, _dest, _ura, _imm)
        {
            memAccessFlags |= extraMemFlags;
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;

        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon4Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon4Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon6Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon6Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 4) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 5) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroDeintNeon8Uop : public MicroNeonMixOp
    {
      public:
        MicroDeintNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("deintneon8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroInterNeon8Uop : public MicroNeonMixOp
    {
      public:
        MicroInterNeon8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("interneon8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 4) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 5) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 6) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 7) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to6Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon2to8Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon2to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to6Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackNeon4to8Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroUnpackNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("unpackneon4to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to2Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to4Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to6Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon2to8Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon2to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon2to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to4Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to6Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to6Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to6uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroUnpackAllNeon4to8Uop : public MicroNeonMixOp
    {
      public:
        MicroUnpackAllNeon4to8Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step) :
            MicroNeonMixOp("unpackallneon4to8uop", machInst, FloatAddOp,
                           _dest, _op1, _step)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 0 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 2 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + step * 3 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon2to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon2to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon2to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon4to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon4to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon6to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon6to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon8to2Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon8to2Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to2uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon4to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon4to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon4to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon6to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon6to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon6to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    template <class Element>
    class MicroPackNeon8to4Uop : public MicroNeonMixLaneOp
    {
      public:
        MicroPackNeon8to4Uop(ExtMachInst machInst, RegIndex _dest, RegIndex _op1,
                       uint8_t _step, unsigned _lane) :
            MicroNeonMixLaneOp("packneon8to4uop", machInst, FloatAddOp,
                           _dest, _op1, _step, _lane)
        {
            
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 0 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + step * 3 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsMicroop] = true;;
            if (!(condCode == COND_AL || condCode == COND_UC)) {
                for (int x = 0; x < _numDestRegs; x++) {
                    _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                }
            }
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroAddiUop : public MicroIntImmOp
    {
      public:
        MicroAddiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroSubiUop : public MicroIntImmOp
    {
      public:
        MicroSubiUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb,
                       int32_t _imm);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroAddUop : public MicroIntRegOp
    {
      public:
        MicroAddUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroSubUop : public MicroIntRegOp
    {
      public:
        MicroSubUop(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb, RegIndex _urc,
                       int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroUopRegMov : public MicroIntMov
    {
      public:
        MicroUopRegMov(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroUopRegMovRet : public MicroIntMov
    {
      public:
        MicroUopRegMovRet(ExtMachInst machInst,
                       RegIndex _ura, RegIndex _urb);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

    class MicroUopSetPCCPSR : public MicroSetPCCPSR
    {
      public:
        MicroUopSetPCCPSR(ExtMachInst machInst,
                       IntRegIndex _ura,
                       IntRegIndex _urb,
                       IntRegIndex _urc);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

    };

/**
 * Static instructions class for a store multiple instruction
 */
class LdmStm : public MacroMemOp
{
    public:
        // Constructor
        LdmStm(ExtMachInst machInst, IntRegIndex rn,
                bool index, bool up, bool user, bool writeback, bool load,
                uint32_t reglist);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VldMult : public VldMultOp
{
    public:
        // Constructor
        VldMult(ExtMachInst machInst, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VldSingle : public VldSingleOp
{
    public:
        // Constructor
        VldSingle(ExtMachInst machInst, bool all, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm, unsigned lane = 0);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VstMult : public VstMultOp
{
    public:
        // Constructor
        VstMult(ExtMachInst machInst, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class VstSingle : public VstSingleOp
{
    public:
        // Constructor
        VstSingle(ExtMachInst machInst, bool all, unsigned width,
                RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
                uint32_t size, uint32_t align, RegIndex rm, unsigned lane = 0);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

/**
 * Static instructions class for a store multiple instruction
 */
class VLdmStm : public MacroVFPMemOp
{
    public:
        // Constructor
        VLdmStm(ExtMachInst machInst, IntRegIndex rn,
                RegIndex vd, bool single, bool up, bool writeback,
                bool load, uint32_t offset);
        
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

class AndImm : public DataImmOp
{
    public:
        // Constructor
        AndImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndImmCc : public DataImmOp
{
    public:
        // Constructor
        AndImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndReg : public DataRegOp
{
    public:
        // Constructor
        AndReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndRegCc : public DataRegOp
{
    public:
        // Constructor
        AndRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AndRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AndRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AndsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AndsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AndsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorImm : public DataImmOp
{
    public:
        // Constructor
        EorImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorImmCc : public DataImmOp
{
    public:
        // Constructor
        EorImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorReg : public DataRegOp
{
    public:
        // Constructor
        EorReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorRegCc : public DataRegOp
{
    public:
        // Constructor
        EorRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorRegReg : public DataRegRegOp
{
    public:
        // Constructor
        EorRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        EorRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorsImmPclr : public DataImmOp
{
    public:
        // Constructor
        EorsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class EorsRegPclr : public DataRegOp
{
    public:
        // Constructor
        EorsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubImm : public DataImmOp
{
    public:
        // Constructor
        SubImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubImmCc : public DataImmOp
{
    public:
        // Constructor
        SubImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubReg : public DataRegOp
{
    public:
        // Constructor
        SubReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubRegCc : public DataRegOp
{
    public:
        // Constructor
        SubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubRegReg : public DataRegRegOp
{
    public:
        // Constructor
        SubRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        SubRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubsImmPclr : public DataImmOp
{
    public:
        // Constructor
        SubsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SubsRegPclr : public DataRegOp
{
    public:
        // Constructor
        SubsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbImm : public DataImmOp
{
    public:
        // Constructor
        RsbImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbImmCc : public DataImmOp
{
    public:
        // Constructor
        RsbImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbReg : public DataRegOp
{
    public:
        // Constructor
        RsbReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbRegCc : public DataRegOp
{
    public:
        // Constructor
        RsbRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbRegReg : public DataRegRegOp
{
    public:
        // Constructor
        RsbRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        RsbRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbsImmPclr : public DataImmOp
{
    public:
        // Constructor
        RsbsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RsbsRegPclr : public DataRegOp
{
    public:
        // Constructor
        RsbsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddImm : public DataImmOp
{
    public:
        // Constructor
        AddImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddImmCc : public DataImmOp
{
    public:
        // Constructor
        AddImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddReg : public DataRegOp
{
    public:
        // Constructor
        AddReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddRegCc : public DataRegOp
{
    public:
        // Constructor
        AddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AddRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AddRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AddsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AddsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AddsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdrImm : public DataImmOp
{
    public:
        // Constructor
        AdrImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdrImmCc : public DataImmOp
{
    public:
        // Constructor
        AdrImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcImm : public DataImmOp
{
    public:
        // Constructor
        AdcImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcImmCc : public DataImmOp
{
    public:
        // Constructor
        AdcImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcReg : public DataRegOp
{
    public:
        // Constructor
        AdcReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcRegCc : public DataRegOp
{
    public:
        // Constructor
        AdcRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcRegReg : public DataRegRegOp
{
    public:
        // Constructor
        AdcRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        AdcRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcsImmPclr : public DataImmOp
{
    public:
        // Constructor
        AdcsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class AdcsRegPclr : public DataRegOp
{
    public:
        // Constructor
        AdcsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcImm : public DataImmOp
{
    public:
        // Constructor
        SbcImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcImmCc : public DataImmOp
{
    public:
        // Constructor
        SbcImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcReg : public DataRegOp
{
    public:
        // Constructor
        SbcReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcRegCc : public DataRegOp
{
    public:
        // Constructor
        SbcRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcRegReg : public DataRegRegOp
{
    public:
        // Constructor
        SbcRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        SbcRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcsImmPclr : public DataImmOp
{
    public:
        // Constructor
        SbcsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SbcsRegPclr : public DataRegOp
{
    public:
        // Constructor
        SbcsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscImm : public DataImmOp
{
    public:
        // Constructor
        RscImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscImmCc : public DataImmOp
{
    public:
        // Constructor
        RscImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscReg : public DataRegOp
{
    public:
        // Constructor
        RscReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscRegCc : public DataRegOp
{
    public:
        // Constructor
        RscRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscRegReg : public DataRegRegOp
{
    public:
        // Constructor
        RscRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        RscRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscsImmPclr : public DataImmOp
{
    public:
        // Constructor
        RscsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class RscsRegPclr : public DataRegOp
{
    public:
        // Constructor
        RscsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstImm : public DataImmOp
{
    public:
        // Constructor
        TstImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstImmCc : public DataImmOp
{
    public:
        // Constructor
        TstImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstReg : public DataRegOp
{
    public:
        // Constructor
        TstReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstRegCc : public DataRegOp
{
    public:
        // Constructor
        TstRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstRegReg : public DataRegRegOp
{
    public:
        // Constructor
        TstRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        TstRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstsImmPclr : public DataImmOp
{
    public:
        // Constructor
        TstsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TstsRegPclr : public DataRegOp
{
    public:
        // Constructor
        TstsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqImm : public DataImmOp
{
    public:
        // Constructor
        TeqImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqImmCc : public DataImmOp
{
    public:
        // Constructor
        TeqImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqReg : public DataRegOp
{
    public:
        // Constructor
        TeqReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqRegCc : public DataRegOp
{
    public:
        // Constructor
        TeqRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqRegReg : public DataRegRegOp
{
    public:
        // Constructor
        TeqRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        TeqRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqsImmPclr : public DataImmOp
{
    public:
        // Constructor
        TeqsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class TeqsRegPclr : public DataRegOp
{
    public:
        // Constructor
        TeqsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpImm : public DataImmOp
{
    public:
        // Constructor
        CmpImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpImmCc : public DataImmOp
{
    public:
        // Constructor
        CmpImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpReg : public DataRegOp
{
    public:
        // Constructor
        CmpReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpRegCc : public DataRegOp
{
    public:
        // Constructor
        CmpRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpRegReg : public DataRegRegOp
{
    public:
        // Constructor
        CmpRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        CmpRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpsImmPclr : public DataImmOp
{
    public:
        // Constructor
        CmpsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmpsRegPclr : public DataRegOp
{
    public:
        // Constructor
        CmpsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnImm : public DataImmOp
{
    public:
        // Constructor
        CmnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnImmCc : public DataImmOp
{
    public:
        // Constructor
        CmnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnReg : public DataRegOp
{
    public:
        // Constructor
        CmnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnRegCc : public DataRegOp
{
    public:
        // Constructor
        CmnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        CmnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        CmnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        CmnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class CmnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        CmnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrImm : public DataImmOp
{
    public:
        // Constructor
        OrrImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrImmCc : public DataImmOp
{
    public:
        // Constructor
        OrrImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrReg : public DataRegOp
{
    public:
        // Constructor
        OrrReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrRegCc : public DataRegOp
{
    public:
        // Constructor
        OrrRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrRegReg : public DataRegRegOp
{
    public:
        // Constructor
        OrrRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        OrrRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrsImmPclr : public DataImmOp
{
    public:
        // Constructor
        OrrsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrrsRegPclr : public DataRegOp
{
    public:
        // Constructor
        OrrsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnImm : public DataImmOp
{
    public:
        // Constructor
        OrnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnImmCc : public DataImmOp
{
    public:
        // Constructor
        OrnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnReg : public DataRegOp
{
    public:
        // Constructor
        OrnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnRegCc : public DataRegOp
{
    public:
        // Constructor
        OrnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        OrnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        OrnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        OrnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class OrnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        OrnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovImm : public DataImmOp
{
    public:
        // Constructor
        MovImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovImmCc : public DataImmOp
{
    public:
        // Constructor
        MovImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovReg : public DataRegOp
{
    public:
        // Constructor
        MovReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovRegCc : public DataRegOp
{
    public:
        // Constructor
        MovRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MovRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MovRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MovsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MovsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicImm : public DataImmOp
{
    public:
        // Constructor
        BicImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicImmCc : public DataImmOp
{
    public:
        // Constructor
        BicImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicReg : public DataRegOp
{
    public:
        // Constructor
        BicReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicRegCc : public DataRegOp
{
    public:
        // Constructor
        BicRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicRegReg : public DataRegRegOp
{
    public:
        // Constructor
        BicRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        BicRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicsImmPclr : public DataImmOp
{
    public:
        // Constructor
        BicsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BicsRegPclr : public DataRegOp
{
    public:
        // Constructor
        BicsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnImm : public DataImmOp
{
    public:
        // Constructor
        MvnImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnImmCc : public DataImmOp
{
    public:
        // Constructor
        MvnImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnReg : public DataRegOp
{
    public:
        // Constructor
        MvnReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnRegCc : public DataRegOp
{
    public:
        // Constructor
        MvnRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MvnRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MvnRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MvnsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MvnsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MvnsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtImm : public DataImmOp
{
    public:
        // Constructor
        MovtImm(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtImmCc : public DataImmOp
{
    public:
        // Constructor
        MovtImmCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtReg : public DataRegOp
{
    public:
        // Constructor
        MovtReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtRegCc : public DataRegOp
{
    public:
        // Constructor
        MovtRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtRegReg : public DataRegRegOp
{
    public:
        // Constructor
        MovtRegReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtRegRegCc : public DataRegRegOp
{
    public:
        // Constructor
        MovtRegRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2, IntRegIndex _shift,
                ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtsImmPclr : public DataImmOp
{
    public:
        // Constructor
        MovtsImmPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, uint32_t _imm, bool _rotC=true);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MovtsRegPclr : public DataRegOp
{
    public:
        // Constructor
        MovtsRegPclr(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QaddRegCc : public DataRegOp
{
    public:
        // Constructor
        QaddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Qadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Qadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Qadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Qadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QdaddRegCc : public DataRegOp
{
    public:
        // Constructor
        QdaddRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QsubReg : public DataRegOp
{
    public:
        // Constructor
        QsubReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QsubRegCc : public DataRegOp
{
    public:
        // Constructor
        QsubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Qsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Qsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Qsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Qsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QdsubRegCc : public DataRegOp
{
    public:
        // Constructor
        QdsubRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QasxReg : public DataRegOp
{
    public:
        // Constructor
        QasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class QsaxReg : public DataRegOp
{
    public:
        // Constructor
        QsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sadd8RegCc : public DataRegOp
{
    public:
        // Constructor
        Sadd8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sadd16RegCc : public DataRegOp
{
    public:
        // Constructor
        Sadd16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Ssub8RegCc : public DataRegOp
{
    public:
        // Constructor
        Ssub8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Ssub16RegCc : public DataRegOp
{
    public:
        // Constructor
        Ssub16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SasxReg : public DataRegOp
{
    public:
        // Constructor
        SasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SasxRegCc : public DataRegOp
{
    public:
        // Constructor
        SasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SsaxReg : public DataRegOp
{
    public:
        // Constructor
        SsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        SsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Shadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Shadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Shadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Shadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Shsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Shsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Shsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Shsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class ShasxReg : public DataRegOp
{
    public:
        // Constructor
        ShasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class ShasxRegCc : public DataRegOp
{
    public:
        // Constructor
        ShasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class ShsaxReg : public DataRegOp
{
    public:
        // Constructor
        ShsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class ShsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        ShsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uqadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Uqadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uqadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Uqadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uqsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Uqsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uqsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Uqsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UqasxReg : public DataRegOp
{
    public:
        // Constructor
        UqasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UqsaxReg : public DataRegOp
{
    public:
        // Constructor
        UqsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uadd16RegCc : public DataRegOp
{
    public:
        // Constructor
        Uadd16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uadd8RegCc : public DataRegOp
{
    public:
        // Constructor
        Uadd8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usub16RegCc : public DataRegOp
{
    public:
        // Constructor
        Usub16RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Usub8RegCc : public DataRegOp
{
    public:
        // Constructor
        Usub8RegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UasxRegCc : public DataRegOp
{
    public:
        // Constructor
        UasxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UsaxRegCc : public DataRegOp
{
    public:
        // Constructor
        UsaxRegCc(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uhadd16Reg : public DataRegOp
{
    public:
        // Constructor
        Uhadd16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uhadd8Reg : public DataRegOp
{
    public:
        // Constructor
        Uhadd8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uhsub16Reg : public DataRegOp
{
    public:
        // Constructor
        Uhsub16Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Uhsub8Reg : public DataRegOp
{
    public:
        // Constructor
        Uhsub8Reg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UhasxReg : public DataRegOp
{
    public:
        // Constructor
        UhasxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UhsaxReg : public DataRegOp
{
    public:
        // Constructor
        UhsaxReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class PkhbtReg : public DataRegOp
{
    public:
        // Constructor
        PkhbtReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class PkhtbReg : public DataRegOp
{
    public:
        // Constructor
        PkhtbReg(ExtMachInst machInst, IntRegIndex _dest,
                IntRegIndex _op1, IntRegIndex _op2,
                int32_t _shiftAmt, ArmShiftType _shiftType);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class B : public BranchImmCond
{
    public:
        // Constructor
        B(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class Bl : public BranchImmCond
{
    public:
        // Constructor
        Bl(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class BlxImm : public BranchImmCond
{
    public:
        // Constructor
        BlxImm(ExtMachInst machInst, int32_t _imm,
                       ConditionCode _condCode);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        ArmISA::PCState branchTarget(const ArmISA::PCState &branchPC) const;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
};

class BlxReg : public BranchRegCond
{
    public:
        // Constructor
        BlxReg(ExtMachInst machInst, IntRegIndex _op1,
                       ConditionCode _condCode);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class BxReg : public BranchRegCond
{
    public:
        // Constructor
        BxReg(ExtMachInst machInst, IntRegIndex _op1,
                       ConditionCode _condCode);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Cbz : public BranchImmReg
{
    public:
        // Constructor
        Cbz(ExtMachInst machInst,
                       int32_t imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Cbnz : public BranchImmReg
{
    public:
        // Constructor
        Cbnz(ExtMachInst machInst,
                       int32_t imm, IntRegIndex _op1);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Tbb : public BranchRegReg
{
    public:
        // Constructor
        Tbb(ExtMachInst machInst,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Tbh : public BranchRegReg
{
    public:
        // Constructor
        Tbh(ExtMachInst machInst,
                       IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault initiateAcc(O3DynInst *, Trace::InstRecord *) const;

    Fault initiateAcc(AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(CheckerCPU *, Trace::InstRecord *) const;

    Fault initiateAcc(TimingSimpleCPU *, Trace::InstRecord *) const;


        
    Fault completeAcc(PacketPtr,  O3DynInst *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  AtomicSimpleCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  CheckerCPU *, Trace::InstRecord *) const;

    Fault completeAcc(PacketPtr,  TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mla : public Mult4
{
    public:
        // Constructor
        Mla(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MlaCc : public Mult4
{
    public:
        // Constructor
        MlaCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mls : public Mult4
{
    public:
        // Constructor
        Mls(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Mul : public Mult3
{
    public:
        // Constructor
        Mul(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class MulCc : public Mult3
{
    public:
        // Constructor
        MulCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlabbCc : public Mult4
{
    public:
        // Constructor
        SmlabbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlabtCc : public Mult4
{
    public:
        // Constructor
        SmlabtCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlatbCc : public Mult4
{
    public:
        // Constructor
        SmlatbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlattCc : public Mult4
{
    public:
        // Constructor
        SmlattCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmladCc : public Mult4
{
    public:
        // Constructor
        SmladCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmladxCc : public Mult4
{
    public:
        // Constructor
        SmladxCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlal : public Mult4
{
    public:
        // Constructor
        Smlal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlalCc : public Mult4
{
    public:
        // Constructor
        SmlalCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlalbb : public Mult4
{
    public:
        // Constructor
        Smlalbb(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlalbt : public Mult4
{
    public:
        // Constructor
        Smlalbt(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlaltb : public Mult4
{
    public:
        // Constructor
        Smlaltb(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlaltt : public Mult4
{
    public:
        // Constructor
        Smlaltt(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlald : public Mult4
{
    public:
        // Constructor
        Smlald(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlaldx : public Mult4
{
    public:
        // Constructor
        Smlaldx(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlawbCc : public Mult4
{
    public:
        // Constructor
        SmlawbCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlawtCc : public Mult4
{
    public:
        // Constructor
        SmlawtCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlsdCc : public Mult4
{
    public:
        // Constructor
        SmlsdCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmlsdxCc : public Mult4
{
    public:
        // Constructor
        SmlsdxCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlsld : public Mult4
{
    public:
        // Constructor
        Smlsld(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smlsldx : public Mult4
{
    public:
        // Constructor
        Smlsldx(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmla : public Mult4
{
    public:
        // Constructor
        Smmla(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmlar : public Mult4
{
    public:
        // Constructor
        Smmlar(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmls : public Mult4
{
    public:
        // Constructor
        Smmls(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmlsr : public Mult4
{
    public:
        // Constructor
        Smmlsr(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmul : public Mult3
{
    public:
        // Constructor
        Smmul(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smmulr : public Mult3
{
    public:
        // Constructor
        Smmulr(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmuadCc : public Mult3
{
    public:
        // Constructor
        SmuadCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmuadxCc : public Mult3
{
    public:
        // Constructor
        SmuadxCc(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smulbb : public Mult3
{
    public:
        // Constructor
        Smulbb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smulbt : public Mult3
{
    public:
        // Constructor
        Smulbt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smultb : public Mult3
{
    public:
        // Constructor
        Smultb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smultt : public Mult3
{
    public:
        // Constructor
        Smultt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smull : public Mult4
{
    public:
        // Constructor
        Smull(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class SmullCc : public Mult4
{
    public:
        // Constructor
        SmullCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smulwb : public Mult3
{
    public:
        // Constructor
        Smulwb(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smulwt : public Mult3
{
    public:
        // Constructor
        Smulwt(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smusd : public Mult3
{
    public:
        // Constructor
        Smusd(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Smusdx : public Mult3
{
    public:
        // Constructor
        Smusdx(ExtMachInst machInst, IntRegIndex _reg0,
                       IntRegIndex _reg1, IntRegIndex _reg2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Umaal : public Mult4
{
    public:
        // Constructor
        Umaal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Umlal : public Mult4
{
    public:
        // Constructor
        Umlal(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UmlalCc : public Mult4
{
    public:
        // Constructor
        UmlalCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Umull : public Mult4
{
    public:
        // Constructor
        Umull(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class UmullCc : public Mult4
{
    public:
        // Constructor
        UmullCc(ExtMachInst machInst,
                       IntRegIndex _reg0, IntRegIndex _reg1,
                       IntRegIndex _reg2, IntRegIndex _reg3);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Sdiv : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Sdiv(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Udiv : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        Udiv(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};


template <class Micro>
class VfpMacroRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                     IntRegIndex _op1, bool _wide) :
        VfpMacroOp("VfpMacroRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        assert(numMicroops > 1);
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, mode);
            nextIdxs(_dest, _op1);
        }
    }

    
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegOp(ExtMachInst machInst,
        IntRegIndex dest, IntRegIndex op1, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1);
    } else {
        return new VfpMacroRegRegOp<VfpOp>(machInst, dest, op1, wide);
    }
}

template <class Micro>
class VfpMacroRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegImmOp(ExtMachInst _machInst, IntRegIndex _dest, uint64_t _imm,
                     bool _wide) :
        VfpMacroOp("VfpMacroRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _imm, mode);
            nextIdxs(_dest);
        }
    }

    
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegImmOp(ExtMachInst machInst,
        IntRegIndex dest, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, imm);
    } else {
        return new VfpMacroRegImmOp<VfpOp>(machInst, dest, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegImmOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegImmOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, uint64_t _imm, bool _wide) :
        VfpMacroOp("VfpMacroRegRegImmOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _imm, mode);
            nextIdxs(_dest, _op1);
        }
    }

    
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegImmOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, uint64_t imm, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, imm);
    } else {
        return new VfpMacroRegRegImmOp<VfpOp>(machInst, dest, op1, imm, wide);
    }
}

template <class Micro>
class VfpMacroRegRegRegOp : public VfpMacroOp
{
  public:
    VfpMacroRegRegRegOp(ExtMachInst _machInst, IntRegIndex _dest,
                        IntRegIndex _op1, IntRegIndex _op2, bool _wide) :
        VfpMacroOp("VfpMacroRegRegRegOp", _machInst, No_OpClass, _wide)
    {
        numMicroops = machInst.fpscrLen + 1;
        microOps = new StaticInstPtr[numMicroops];
        for (unsigned i = 0; i < numMicroops; i++) {
            VfpMicroMode mode = VfpMicroop;
            if (i == 0)
                mode = VfpFirstMicroop;
            else if (i == numMicroops - 1)
                mode = VfpLastMicroop;
            microOps[i] = new Micro(_machInst, _dest, _op1, _op2, mode);
            nextIdxs(_dest, _op1, _op2);
        }
    }

    
Fault execute(O3DynInst *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(CheckerCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const
{
        panic("Execute method called when it shouldn't!");
        // GCC < 4.3 fail to recognize the above panic as no return
        return NoFault;
}

};

template <class VfpOp>
static StaticInstPtr
decodeVfpRegRegRegOp(ExtMachInst machInst, IntRegIndex dest,
                     IntRegIndex op1, IntRegIndex op2, bool wide)
{
    if (machInst.fpscrLen == 0 || VfpMacroOp::inScalarBank(dest)) {
        return new VfpOp(machInst, dest, op1, op2);
    } else {
        return new VfpMacroRegRegRegOp<VfpOp>(machInst, dest, op1, op2, wide);
    }
}

class Vmsr : public FpRegRegOp
{
  public:
    // Constructor
    Vmsr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmsrFpscr : public FpRegRegOp
{
  public:
    // Constructor
    VmsrFpscr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Vmrs : public FpRegRegOp
{
  public:
    // Constructor
    Vmrs(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmrsFpscr : public FpRegRegOp
{
  public:
    // Constructor
    VmrsFpscr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

        /**
         * Static instruction class for "vmrs".
         */
        class VmrsApsrFpscr : public PredOp
        {
          public:
                /// Constructor.
                VmrsApsrFpscr(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

class VmovImmS : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovImmD : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovImmQ : public FpRegImmOp
{
  public:
    // Constructor
    VmovImmQ(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegS : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegD : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegQ : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovCoreRegB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovCoreRegB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovCoreRegH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovCoreRegH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovCoreRegW : public FpRegRegOp
{
  public:
    // Constructor
    VmovCoreRegW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegCoreUB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreUB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegCoreUH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreUH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegCoreSB : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreSB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegCoreSH : public FpRegRegImmOp
{
  public:
    // Constructor
    VmovRegCoreSH(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmovRegCoreW : public FpRegRegOp
{
  public:
    // Constructor
    VmovRegCoreW(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Vmov2Reg2Core : public FpRegRegRegOp
{
  public:
    // Constructor
    Vmov2Reg2Core(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class Vmov2Core2Reg : public FpRegRegRegOp
{
  public:
    // Constructor
    Vmov2Core2Reg(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VaddS : public FpRegRegRegOp
{
  public:
    // Constructor
    VaddS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VaddD : public FpRegRegRegOp
{
  public:
    // Constructor
    VaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VsubS : public FpRegRegRegOp
{
  public:
    // Constructor
    VsubS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VsubD : public FpRegRegRegOp
{
  public:
    // Constructor
    VsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VdivS : public FpRegRegRegOp
{
  public:
    // Constructor
    VdivS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VdivD : public FpRegRegRegOp
{
  public:
    // Constructor
    VdivD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmulS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmulD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VsqrtS : public FpRegRegOp
{
  public:
    // Constructor
    VsqrtS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VsqrtD : public FpRegRegOp
{
  public:
    // Constructor
    VsqrtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnegS : public FpRegRegOp
{
  public:
    // Constructor
    VnegS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnegD : public FpRegRegOp
{
  public:
    // Constructor
    VnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VabsS : public FpRegRegOp
{
  public:
    // Constructor
    VabsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VabsD : public FpRegRegOp
{
  public:
    // Constructor
    VabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmlaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmlaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmlsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VmlsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmlaS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlaS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmlaD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmlsS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlsS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmlsD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmulS : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmulS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VnmulD : public FpRegRegRegOp
{
  public:
    // Constructor
    VnmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtUIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtUIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSIntFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtSIntFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSIntFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtSIntFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUIntSR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntSR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUIntDR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntDR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSIntSR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntSR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSIntDR : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntDR(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUIntS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUIntD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpUIntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSIntS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSIntD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSIntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSFpD : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpDFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpDFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpHTFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpHTFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpHBFpS : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpHBFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSFpHT : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpHT(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSFpHB : public FpRegRegOp
{
  public:
    // Constructor
    VcvtFpSFpHB(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpS : public FpRegRegOp
{
  public:
    // Constructor
    VcmpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpD : public FpRegRegOp
{
  public:
    // Constructor
    VcmpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpZeroS : public FpRegImmOp
{
  public:
    // Constructor
    VcmpZeroS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpZeroD : public FpRegImmOp
{
  public:
    // Constructor
    VcmpZeroD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpeS : public FpRegRegOp
{
  public:
    // Constructor
    VcmpeS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpeD : public FpRegRegOp
{
  public:
    // Constructor
    VcmpeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpeZeroS : public FpRegImmOp
{
  public:
    // Constructor
    VcmpeZeroS(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcmpeZeroD : public FpRegImmOp
{
  public:
    // Constructor
    VcmpeZeroD(ExtMachInst machInst, IntRegIndex _dest,
            uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSHFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSHFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpSHFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpSHFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUHFixedS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUHFixedS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtFpUHFixedD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtFpUHFixedD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSHFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSHFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtSHFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtSHFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUHFixedFpS : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUHFixedFpS(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class VcvtUHFixedFpD : public FpRegRegImmOp
{
  public:
    // Constructor
    VcvtUHFixedFpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1,
                   uint64_t _imm, VfpMicroMode mode = VfpNotAMicroop);
    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          case 3:
            return new Base<int64_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUReg(bool notSigned, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUReg<Base>(size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<Base>(size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUThreeUSReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSThreeUSReg(unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, op2);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, op2);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, op2);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUSThreeUSReg(bool notSigned, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<Base>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeSReg(bool q, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUSReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUSReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeSReg(bool q, bool notSigned, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, IntRegIndex dest,
                        IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonUThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonUThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSThreeReg(bool q, unsigned size,
                        ExtMachInst machInst, IntRegIndex dest,
                        IntRegIndex op1, IntRegIndex op2)
    {
        if (q) {
            return decodeNeonSThreeUReg<BaseQ>(
                    size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeUReg<BaseD>(
                    size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSThreeReg(bool q, bool notSigned, unsigned size,
                         ExtMachInst machInst, IntRegIndex dest,
                         IntRegIndex op1, IntRegIndex op2)
    {
        if (notSigned) {
            return decodeNeonUThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        } else {
            return decodeNeonSThreeReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, op2);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<uint8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<uint16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<uint32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<uint64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftReg(bool q, unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            switch (size) {
              case 0:
                return new BaseQ<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseQ<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseQ<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseQ<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        } else {
            switch (size) {
              case 0:
                return new BaseD<int8_t>(machInst, dest, op1, imm);
              case 1:
                return new BaseD<int16_t>(machInst, dest, op1, imm);
              case 2:
                return new BaseD<int32_t>(machInst, dest, op1, imm);
              case 3:
                return new BaseD<int64_t>(machInst, dest, op1, imm);
              default:
                return new Unknown(machInst);
            }
        }
    }


    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonUTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonUTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoShiftUSReg(unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1, imm);
          case 1:
            return new Base<int16_t>(machInst, dest, op1, imm);
          case 2:
            return new Base<int32_t>(machInst, dest, op1, imm);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoShiftSReg(bool q, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1, uint64_t imm)
    {
        if (q) {
            return decodeNeonSTwoShiftUSReg<BaseQ>(
                    size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftUSReg<BaseD>(
                    size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoShiftSReg(bool q, bool notSigned, unsigned size,
                             ExtMachInst machInst, IntRegIndex dest,
                             IntRegIndex op1, uint64_t imm)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1, imm);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUSReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscSReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscSReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUSReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUSReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonUTwoMiscUReg(unsigned size,
                           ExtMachInst machInst, IntRegIndex dest,
                           IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class Base>
    StaticInstPtr
    decodeNeonSTwoMiscUReg(unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        switch (size) {
          case 0:
            return new Base<int8_t>(machInst, dest, op1);
          case 1:
            return new Base<int16_t>(machInst, dest, op1);
          case 2:
            return new Base<int32_t>(machInst, dest, op1);
          case 3:
            return new Base<int64_t>(machInst, dest, op1);
          default:
            return new Unknown(machInst);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonSTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonSTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUTwoMiscReg(bool q, unsigned size,
                          ExtMachInst machInst, IntRegIndex dest,
                          IntRegIndex op1)
    {
        if (q) {
            return decodeNeonUTwoMiscUReg<BaseQ>(size, machInst, dest, op1);
        } else {
            return decodeNeonUTwoMiscUReg<BaseD>(size, machInst, dest, op1);
        }
    }

    template <template <typename T> class BaseD,
              template <typename T> class BaseQ>
    StaticInstPtr
    decodeNeonUSTwoMiscSReg(bool q, bool notSigned, unsigned size,
                            ExtMachInst machInst, IntRegIndex dest,
                            IntRegIndex op1)
    {
        if (notSigned) {
            return decodeNeonUTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        } else {
            return decodeNeonSTwoShiftSReg<BaseD, BaseQ>(
                    q, size, machInst, dest, op1);
        }
    }


template <class _Element>
class VhaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VhaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrhaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrhaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrhaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrhaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrhadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VhsubD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VhsubQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VhsubQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vhsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VandD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VandD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vand", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VandQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VandQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vand", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbicD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbicD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbicQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbicQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbic", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VorrD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VorrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VorrQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VorrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorr", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmovD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmovD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmov", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmovQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmovQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmov", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VornD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VornD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VornQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VornQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vorn", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VeorD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VeorD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("veor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VeorQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VeorQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("veor", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbifD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbifD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbifQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbifQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbif", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbitD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbitD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbitQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbitQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbit", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbslD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbslD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VbslQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VbslQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vbsl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VminD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VminQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVaddQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVaddQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddw : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddw(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vaddhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vaddhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaddhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vraddhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vraddhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vraddhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsubD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsubD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsubQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsubQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubw : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubw(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubw", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vsubhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vsubhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vsubhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vrsubhn : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vrsubhn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrsubhn", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqaddSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqaddSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqadd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqsubSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqsubSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqsub", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VshlD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VshlQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrshlD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrshlQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vrshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqshlSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqshlSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlUD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlUD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlUQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlUQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlSD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlSD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrshlSQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrshlSQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrshl", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabaD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabaQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabaQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vaba", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vabal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vabal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabal", machInst, SimdAddAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabd", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vabdl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vabdl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vabdl", machInst, SimdAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VtstD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VtstD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VtstQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VtstQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vtst", machInst, SimdAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmull : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmull(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlal : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlal(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlsl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlsl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmull : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmull(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmull", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlsl : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlsl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulpD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulpQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmullp : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmullp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpmax", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vpmin", machInst, SimdCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhD : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhQ : public RegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : RegRegRegOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmaxQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmaxQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VminDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VminQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VminQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpmaxQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpmaxQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmax", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpminQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpminQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpmin", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VaddDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VaddDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VaddQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VaddQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpaddDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpaddDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VpaddQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VpaddQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vpadd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VsubDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VsubDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VsubQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VsubQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vsub", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmulQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmulQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlaQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlaQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmlsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmlsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgtQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VcgeQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VcgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgtDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgtQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacgt", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgeDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VacgeQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VacgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vacge", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VceqQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VceqQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrecpsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrecpsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrecpsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrecpsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrecps", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrsqrtsDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrsqrtsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VrsqrtsQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VrsqrtsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vrsqrts", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdDFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VabdQFp : public FpRegRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VabdQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2)
        : FpRegRegRegOp("vabd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmla", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlasQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlasQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmla", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlals : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlals(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmls", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmlssQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmlssQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmls", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmlsls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmlsls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmul", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsDFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VmulsQFp : public FpRegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VmulsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : FpRegRegRegImmOp("vmul", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vmulls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vmulls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmulls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmulls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmull", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlals : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlals(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmlal", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class Vqdmlsls : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    Vqdmlsls(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmlsl", machInst, SimdMultAccOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqdmulhsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqdmulhsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhsD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class VqrdmulhsQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    VqrdmulhsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vqrdmulh", machInst, SimdMultOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsraD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsraD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsraQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsraQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshr", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsraD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsraD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsraQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsraQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrsra", machInst, SimdShiftAccOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsriD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsriD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsriQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsriQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsri", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshlD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshlQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsliD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsliD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVsliQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVsliQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vsli", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshl", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshluD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshluD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshluQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshluQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlu", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlusD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlusD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshlusQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshlusQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshlus", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshrun : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshrun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqshruns : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqshruns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshrn : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshrn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrn", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshrun : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshrun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqrshruns : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqrshruns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vqrshrun", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVshll : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVshll(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vshll", machInst, SimdShiftOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmovl : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmovl(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vmovl", machInst, SimdMiscOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2ufxD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2ufxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2ufxQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2ufxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2sfxD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2sfxD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvt2sfxQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvt2sfxQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvtu2fpD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvtu2fpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvtu2fpQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvtu2fpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2fpD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2fpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2fpQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2fpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvts2h : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvts2h(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcvth2s : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcvth2s(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcvt", machInst, SimdCvtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrsqrte", machInst, SimdSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrsqrteQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrsqrteQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrsqrte", machInst, SimdFloatSqrtOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrecpe", machInst, SimdMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrecpeQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrecpeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vrecpe", machInst, SimdFloatMultAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev16D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev16D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev16Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev16Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev16", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev32D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev32D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev32Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev32Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev32", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev64D : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev64D(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVrev64Q : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVrev64Q(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vrev64", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddlD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddlD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpaddl", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpaddlQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpaddlQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpaddl", machInst, SimdAddOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpadalD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpadalD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpadal", machInst, SimdAddAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVpadalQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVpadalQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vpadal", machInst, SimdAddAccOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcls", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclzD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclzD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVclzQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVclzQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclz", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcntD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcntD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcntQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcntQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcnt", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvnD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvnD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvnQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvnQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmvn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqabsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqabsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqabsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqnegD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqnegQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqnegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vabs", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVabsQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVabsQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vabs", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vneg", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVnegQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVnegQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vneg", machInst, SimdFloatAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcgt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgtQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgtQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcgt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcge", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcgeQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcgeQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcge", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vceq", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVceqQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVceqQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vceq", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vcle", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcleQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcleQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vcle", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vclt", machInst, SimdCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltDFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltDFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVcltQFp : public FpRegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVcltQFp(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : FpRegRegOp("vclt", machInst, SimdFloatCmpOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVswpD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVswpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vswp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVswpQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVswpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vswp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVtrnD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVtrnD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vtrn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVtrnQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVtrnQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vtrn", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVuzpD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVuzpD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vuzp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVuzpQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVuzpQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vuzp", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVzipD : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVzipD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vzip", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVzipQ : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVzipQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vzip", machInst, SimdAluOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (op1 + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmovn : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmovn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vmovn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupD : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vdup", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupQ : public RegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, uint64_t _imm)
        : RegRegImmOp("vdup", machInst, SimdAluOp,
                         _dest, _op1, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupDGpr : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupDGpr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vdup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVdupQGpr : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVdupQGpr(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vdup", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmoviD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmoviD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmoviQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmoviQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmov", machInst, SimdMiscOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVorriD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVorriD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVorriQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVorriQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vorr", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvniD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvniD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVmvniQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVmvniQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vmvn", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVbiciD : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVbiciD(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVbiciQ : public RegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVbiciQ(ExtMachInst machInst, IntRegIndex _dest, uint64_t _imm)
        : RegImmOp("vbic", machInst, SimdAluOp, _dest, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovn : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovn(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovn", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovun : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovun(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVqmovuns : public RegRegOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVqmovuns(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("vqmovun", machInst, SimdMiscOp,
                         _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_QC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVextD : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVextD(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

template <class _Element>
class NVextQ : public RegRegRegImmOp
{
  protected:
    typedef _Element Element;
  public:
    // Constructor
    NVextQ(ExtMachInst machInst,
                   IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2,
                   uint64_t _imm)
        : RegRegRegImmOp("vext", machInst, SimdMiscOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 3) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbl1 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl1(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbl2 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl2(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbl3 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl3(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbl4 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbl4(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbx1 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx1(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbx2 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx2(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbx3 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx3(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

class NVtbx4 : public RegRegRegOp
{
  protected:
    public:
        // Constructor
        NVtbx4(ExtMachInst machInst,
                       IntRegIndex _dest, IntRegIndex _op1, IntRegIndex _op2);
        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

};

    uint64_t join32to64(uint32_t r1, uint32_t r0);
    
        /**
         * Static instruction class for "arm".
         */
        class Arm : public PredOp
        {
          public:
                /// Constructor.
                Arm(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesce".
         */
        class Quiesce : public PredOp
        {
          public:
                /// Constructor.
                Quiesce(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceNs".
         */
        class QuiesceNs : public PredOp
        {
          public:
                /// Constructor.
                QuiesceNs(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceCycles".
         */
        class QuiesceCycles : public PredOp
        {
          public:
                /// Constructor.
                QuiesceCycles(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "quiesceTime".
         */
        class QuiesceTime : public PredOp
        {
          public:
                /// Constructor.
                QuiesceTime(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "rpns".
         */
        class Rpns : public PredOp
        {
          public:
                /// Constructor.
                Rpns(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "wakeCPU".
         */
        class WakeCPU : public PredOp
        {
          public:
                /// Constructor.
                WakeCPU(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_ivlb".
         */
        class Deprecated_ivlb : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_ivlb(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_ivle".
         */
        class Deprecated_ivle : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_ivle(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "deprecated_exit".
         */
        class Deprecated_exit : public PredOp
        {
          public:
                /// Constructor.
                Deprecated_exit(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5exit".
         */
        class M5exit : public PredOp
        {
          public:
                /// Constructor.
                M5exit(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5fail".
         */
        class M5fail : public PredOp
        {
          public:
                /// Constructor.
                M5fail(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "loadsymbol".
         */
        class Loadsymbol : public PredOp
        {
          public:
                /// Constructor.
                Loadsymbol(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "initparam".
         */
        class Initparam : public PredOp
        {
          public:
                /// Constructor.
                Initparam(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "resetstats".
         */
        class Resetstats : public PredOp
        {
          public:
                /// Constructor.
                Resetstats(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpstats".
         */
        class Dumpstats : public PredOp
        {
          public:
                /// Constructor.
                Dumpstats(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "dumpresetstats".
         */
        class Dumpresetstats : public PredOp
        {
          public:
                /// Constructor.
                Dumpresetstats(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5checkpoint".
         */
        class M5checkpoint : public PredOp
        {
          public:
                /// Constructor.
                M5checkpoint(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5readfile".
         */
        class M5readfile : public PredOp
        {
          public:
                /// Constructor.
                M5readfile(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5writefile".
         */
        class M5writefile : public PredOp
        {
          public:
                /// Constructor.
                M5writefile(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5break".
         */
        class M5break : public PredOp
        {
          public:
                /// Constructor.
                M5break(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5switchcpu".
         */
        class M5switchcpu : public PredOp
        {
          public:
                /// Constructor.
                M5switchcpu(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5addsymbol".
         */
        class M5addsymbol : public PredOp
        {
          public:
                /// Constructor.
                M5addsymbol(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5panic".
         */
        class M5panic : public PredOp
        {
          public:
                /// Constructor.
                M5panic(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workbegin".
         */
        class M5workbegin : public PredOp
        {
          public:
                /// Constructor.
                M5workbegin(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };

        /**
         * Static instruction class for "m5workend".
         */
        class M5workend : public PredOp
        {
          public:
                /// Constructor.
                M5workend(ExtMachInst machInst);
                
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;

        };


    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMemInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex ra,
                   const uint32_t imm, const unsigned extraMemFlags)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, ra, imm, extraMemFlags);
          case 1:
            return new Base<uint16_t>(machInst, dest, ra, imm, extraMemFlags);
          case 2:
            return new Base<uint32_t>(machInst, dest, ra, imm, extraMemFlags);
          case 3:
            return new Base<uint64_t>(machInst, dest, ra, imm, extraMemFlags);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }

    template<template <typename T> class Base>
    StaticInstPtr
    newNeonMixInst(const unsigned size,
                   const ExtMachInst &machInst,
                   const RegIndex dest, const RegIndex op1,
                   const uint32_t step)
    {
        switch (size) {
          case 0:
            return new Base<uint8_t>(machInst, dest, op1, step);
          case 1:
            return new Base<uint16_t>(machInst, dest, op1, step);
          case 2:
            return new Base<uint32_t>(machInst, dest, op1, step);
          case 3:
            return new Base<uint64_t>(machInst, dest, op1, step);
          default:
            panic("Unrecognized width %d for Neon mem inst.\n", (1 << size));
        }
    }


    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst);
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst);
    
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst);
    
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst);
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst);
    
    StaticInstPtr
    decodeMcrMrc15(ExtMachInst machInst);
    
    /**
     * Static instruction class for unimplemented instructions that
     * cause simulator termination.  Note that these are recognized
     * (legal) instructions that the simulator does not support; the
     * 'Unknown' class is used for unrecognized/illegal instructions.
     * This is a leaf class.
     */
    class FailUnimplemented : public ArmStaticInst
    {
      public:
        /// Constructor
        FailUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : ArmStaticInst(_mnemonic, _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    /**
     * Base class for unimplemented instructions that cause a warning
     * to be printed (but do not terminate simulation).  This
     * implementation is a little screwy in that it will print a
     * warning for each instance of a particular unimplemented machine
     * instruction, not just for each unimplemented opcode.  Should
     * probably make the 'warned' flag a static member of the derived
     * class.
     */
    class WarnUnimplemented : public ArmStaticInst
    {
      private:
        /// Have we warned on this instruction yet?
        mutable bool warned;

      public:
        /// Constructor
        WarnUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : ArmStaticInst(_mnemonic, _machInst, No_OpClass), warned(false)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

    class FlushPipeInst : public ArmStaticInst
    {
      public:
        FlushPipeInst(const char *_mnemonic, ExtMachInst _machInst)
            : ArmStaticInst(_mnemonic, _machInst, No_OpClass)
        {
            flags[IsNonSpeculative] = true;
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;

    };

    /**
     * Static instruction class for Breakpoint (illegal) instructions.
     * These cause simulator termination if they are executed in a
     * non-speculative mode.  This is a leaf class.
     */
    class Breakpoint : public ArmStaticInst
    {
      public:
        /// Constructor
        Breakpoint(ExtMachInst _machInst)
            : ArmStaticInst("Breakpoint", _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        
        Fault execute(O3DynInst *, Trace::InstRecord *) const;

        Fault execute(AtomicSimpleCPU *, Trace::InstRecord *) const;

        Fault execute(CheckerCPU *, Trace::InstRecord *) const;

        Fault execute(TimingSimpleCPU *, Trace::InstRecord *) const;


        std::string
        generateDisassembly(Addr pc, const SymbolTable *symtab) const;
    };

// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// Breakpoint::bkpt(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))


} // namespace ArmISAInst


