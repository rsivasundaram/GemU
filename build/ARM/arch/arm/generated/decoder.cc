
/*
 * DO NOT EDIT THIS FILE!!!
 *
 * It was automatically generated from the ISA description in arm/isa/main.isa
 */

#include "decoder.hh"


#include "cpu/simple/atomic.hh"
#include "arch/arm/decoder.hh"
#include "arch/arm/faults.hh"
#include "arch/arm/intregs.hh"
#include "arch/arm/isa_traits.hh"
#include "arch/arm/utility.hh"
#include "base/loader/symtab.hh"
#include "base/cprintf.hh"
#include "cpu/thread_context.hh"

using namespace ArmISA;


namespace ArmISAInst {


    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 1)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ4::LOAD_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 1)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ4::LOAD_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ4::LOAD_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ4::LOAD_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ4::LOAD_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ4::LOAD_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ4::LOAD_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ4::LOAD_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldr", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WN_SZ4::LOAD_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WN_SZ4::LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WN_SZ4::LOAD_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ4::LOAD_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ4::LOAD_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ4::LOAD_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ4::LOAD_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ4::LOAD_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ4::LOAD_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ4::LOAD_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ4::LOAD_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WN_SZ4::LOAD_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WN_SZ4::LOAD_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WN_SZ4::LOAD_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WN_SZ4::LOAD_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ1::LOAD_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ1::LOAD_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ1::LOAD_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ1::LOAD_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ1::LOAD_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ1::LOAD_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ1::LOAD_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ1::LOAD_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WN_SZ1::LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WN_SZ1::LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WN_SZ1::LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ1::LOAD_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ1::LOAD_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ1::LOAD_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ1::LOAD_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ1::LOAD_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ1::LOAD_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ1::LOAD_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ1::LOAD_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WN_SZ1::LOAD_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WN_SZ1::LOAD_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WN_SZ1::LOAD_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WN_SZ1::LOAD_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UN_WY_SZ1::LOAD_IMM_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UN_WY_SZ1::LOAD_REG_AY_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UN_WY_SZ1::LOAD_IMM_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UN_WY_SZ1::LOAD_REG_AN_PY_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WY_SZ1::LOAD_IMM_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WY_SZ1::LOAD_REG_AY_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WY_SZ1::LOAD_IMM_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WY_SZ1::LOAD_REG_AN_PN_SY_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WN_SZ1::LOAD_IMM_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WN_SZ1::LOAD_REG_AY_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WN_SZ1::LOAD_IMM_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WN_SZ1::LOAD_REG_AN_PN_SY_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UY_WY_SZ1::LOAD_IMM_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UY_WY_SZ1::LOAD_REG_AY_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UY_WY_SZ1::LOAD_IMM_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UY_WY_SZ1::LOAD_REG_AN_PY_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WY_SZ1::LOAD_IMM_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WY_SZ1::LOAD_REG_AY_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WY_SZ1::LOAD_IMM_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WY_SZ1::LOAD_REG_AN_PN_SY_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WN_SZ1::LOAD_IMM_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WN_SZ1::LOAD_REG_AY_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WN_SZ1::LOAD_IMM_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WN_SZ1::LOAD_REG_AN_PN_SY_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsbt", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UN_WY_SZ2::LOAD_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UN_WY_SZ2::LOAD_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UN_WY_SZ2::LOAD_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UN_WY_SZ2::LOAD_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WY_SZ2::LOAD_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WY_SZ2::LOAD_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WY_SZ2::LOAD_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WY_SZ2::LOAD_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UN_WN_SZ2::LOAD_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UN_WN_SZ2::LOAD_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UN_WN_SZ2::LOAD_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SN_UY_WY_SZ2::LOAD_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SN_UY_WY_SZ2::LOAD_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SN_UY_WY_SZ2::LOAD_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SN_UY_WY_SZ2::LOAD_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WY_SZ2::LOAD_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WY_SZ2::LOAD_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WY_SZ2::LOAD_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WY_SZ2::LOAD_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SN_UY_WN_SZ2::LOAD_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SN_UY_WN_SZ2::LOAD_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SN_UY_WN_SZ2::LOAD_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SN_UY_WN_SZ2::LOAD_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UN_WY_SZ2::LOAD_IMM_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UN_WY_SZ2::LOAD_REG_AY_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UN_WY_SZ2::LOAD_IMM_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UN_WY_SZ2::LOAD_REG_AN_PY_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WY_SZ2::LOAD_IMM_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WY_SZ2::LOAD_REG_AY_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WY_SZ2::LOAD_IMM_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WY_SZ2::LOAD_REG_AN_PN_SY_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("hdrsh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UN_WN_SZ2::LOAD_IMM_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UN_WN_SZ2::LOAD_REG_AY_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UN_WN_SZ2::LOAD_IMM_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UN_WN_SZ2::LOAD_REG_AN_PN_SY_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("hdrsh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PY_SY_UY_WY_SZ2::LOAD_IMM_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PY_SY_UY_WY_SZ2::LOAD_REG_AY_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PY_SY_UY_WY_SZ2::LOAD_IMM_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PY_SY_UY_WY_SZ2::LOAD_REG_AN_PY_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WY_SZ2::LOAD_IMM_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroAddiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WY_SZ2::LOAD_REG_AY_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WY_SZ2::LOAD_IMM_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new MicroSubiUop(machInst, base, base, imm);;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WY_SZ2::LOAD_REG_AN_PN_SY_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("ldrsht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AY_PN_SY_UY_WN_SZ2::LOAD_IMM_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AY_PN_SY_UY_WN_SZ2::LOAD_REG_AY_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AY_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMM_AN_PN_SY_UY_WN_SZ2::LOAD_IMM_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LOAD_IMM_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_REG_AN_PN_SY_UY_WN_SZ2::LOAD_REG_AN_PN_SY_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("ldrsht", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REG_AN_PN_SY_UY_WN_SZ2(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_REGD_AY_PY_SN_UN_WY_SZ4::LOAD_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_REGD_AN_PY_SN_UN_WY_SZ4::LOAD_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_REGD_AY_PN_SN_UN_WY_SZ4::LOAD_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroAddUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_REGD_AN_PN_SN_UN_WY_SZ4::LOAD_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("ldrd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new 
                     MicroSubUop(machInst, base, base, wbIndexReg, shiftAmt, shiftType);
                 ;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AY_PN_SN_UN_WN_SZ4::LOAD_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline LOAD_REGD_AN_PN_SN_UN_WN_SZ4::LOAD_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("ldrd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if ((_dest == _index) || (_dest2 == _index)) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#endif
    }

    inline RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, 8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 1 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 1
        uops[++uopIdx] = new MicroAddiUop(machInst, base, base, -8);;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, MemReadOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = urc;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = urb;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        uops = new StaticInstPtr[1 + 0 + 0];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 0
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
                                          uint32_t _base, int _mode, bool _wb)
        : RfeOp("rfe", machInst, IntAluOp,
                         (IntRegIndex)_base, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        uops = new StaticInstPtr[1 + 0 + 1];
        int uopIdx = 0;
        uops[uopIdx] = new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc(machInst, _base, _mode, _wb);
        uops[uopIdx]->setDelayedCommit();
#if 0
        uops[++uopIdx] = new None;
        uops[uopIdx]->setDelayedCommit();
#endif
#if 1
        uops[++uopIdx] = new MicroUopSetPCCPSR(machInst, INTREG_UREG0, INTREG_UREG1, INTREG_UREG2);;
#endif
        uops[uopIdx]->setLastMicroop();
#endif
    }

    inline PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pld", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pldw", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsDataPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                       _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            uops[2]->setLastMicroop();
        } else if(_dest == _index) {
            IntRegIndex wbIndexReg = INTREG_UREG0;
            uops[0] = new MicroUopRegMov(machInst, INTREG_UREG0, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[1]->setDelayedCommit();
            uops[2] = new None;
            uops[2]->setLastMicroop();
        } else {
            IntRegIndex wbIndexReg = index;
            uops[0] = new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                      _shiftAmt, _shiftType, _index);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();

        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("pli", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsInstPrefetch] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrex", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexh", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("ldrexb", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("ldrexd", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = dest2;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        bool conditional M5_VAR_USED = false;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            conditional = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        if (_dest == INTREG_PC && !isFloating()) {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, INTREG_UREG0, _base, _add,
                                   _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setDelayedCommit();
            uops[2] = new MicroUopRegMov(machInst, INTREG_PC, INTREG_UREG0);
            uops[2]->setFlag(StaticInst::IsControl);
            uops[2]->setFlag(StaticInst::IsIndirectControl);
            if (conditional)
                uops[2]->setFlag(StaticInst::IsCondControl);
            else
                uops[2]->setFlag(StaticInst::IsUncondControl);
            if (_base == INTREG_SP && _add && _imm == 4 && 0)
                uops[2]->setFlag(StaticInst::IsReturn);
            uops[2]->setLastMicroop();
        } else {
            uops[0] = new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
            uops[0]->setDelayedCommit();
            uops[1] = new None;
            uops[1]->setLastMicroop();
        }
#else
        if (_dest == INTREG_PC && !isFloating()) {
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (conditional)
                flags[IsCondControl] = true;
            else
                flags[IsUncondControl] = true;
        }
#endif
    }

    inline VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vldr", machInst, MemReadOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest2 + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

        Svc::Svc(ExtMachInst machInst)  : PredOp("svc", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSyscall] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    inline MrsCpsr::MrsCpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MrsSpsr::MrsSpsr(ExtMachInst machInst,
                                          IntRegIndex _dest)
        : MrsOp("mrs", machInst, IntAluOp, _dest)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MsrCpsrReg::MsrCpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MsrSpsrReg::MsrSpsrReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          uint8_t mask)
        : MsrRegOp("msr", machInst, IntAluOp, _op1, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MsrCpsrImm::MsrCpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MsrSpsrImm::MsrSpsrImm(ExtMachInst machInst,
                                          uint32_t imm,
                                          uint8_t mask)
        : MsrImmOp("msr", machInst, IntAluOp, imm, mask)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Rev::Rev(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Rev16::Rev16(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rev16", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Revsh::Revsh(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("revsh", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Rbit::Rbit(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("rbit", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Clz::Clz(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("clz", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Ssat::Ssat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("ssat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Usat::Usat(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : RegImmRegShiftOp("usat", machInst, IntAluOp,
                         _dest, _imm, _op1, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Ssat16::Ssat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("ssat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Usat16::Usat16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("usat16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxtb::Sxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxtab::Sxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxtb16::Sxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxtab16::Sxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxth::Sxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("sxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sxtah::Sxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("sxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxtb::Uxtb(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxtab::Uxtab(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxtb16::Uxtb16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxtb16", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxtab16::Uxtab16(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtab16", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxth::Uxth(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          uint64_t _imm,
                                          IntRegIndex _op1)
        : RegImmRegOp("uxth", machInst, IntAluOp,
                         _dest, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Uxtah::Uxtah(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          uint64_t _imm)
        : RegRegRegImmOp("uxtah", machInst, IntAluOp,
                         _dest, _op1, _op2, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sel::Sel(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sel", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_GE;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Usad8::Usad8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("usad8", machInst, IntAluOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Usada8::Usada8(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _op3)
        : RegRegRegRegOp("usada8", machInst, IntAluOp,
                         _dest, _op1, _op2, _op3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        BkptInst::BkptInst(ExtMachInst machInst)  : PredOp("bkpt", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        NopInst::NopInst(ExtMachInst machInst)  : PredOp("nop", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNop] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        YieldInst::YieldInst(ExtMachInst machInst)  : PredOp("yield", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfeInst::WfeInst(ExtMachInst machInst)  : PredOp("wfe", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WfiInst::WfiInst(ExtMachInst machInst)  : PredOp("wfi", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsSerializeAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        SevInst::SevInst(ExtMachInst machInst)  : PredOp("sev", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSquashAfter] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        ItInst::ItInst(ExtMachInst machInst)  : PredOp("it", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Unknown::Unknown(ExtMachInst machInst)  : UnknownOp("unknown", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    inline Ubfx::Ubfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("ubfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sbfx::Sbfx(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("sbfx", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Bfc::Bfc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfc", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Bfi::Bfi(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm1,
                                          uint64_t _imm2)
        : RegRegImmImmOp("bfi", machInst, IntAluOp,
                         _dest, _op1, _imm1, _imm2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mrc14::Mrc14(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mrc", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mcr14::Mcr14(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mcr", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mrc14User::Mrc14User(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mrc", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mcr14User::Mcr14User(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mcr", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mrc15::Mrc15(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mrc", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mcr15::Mcr15(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mcr", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mrc15User::Mrc15User(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mrc", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mcr15User::Mcr15User(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1)
        : RegRegOp("mcr", machInst, IntAluOp, _dest, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Enterx::Enterx(ExtMachInst machInst)  : PredOp("enterx", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Leavex::Leavex(ExtMachInst machInst)  : PredOp("leavex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsControl] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    inline Setend::Setend(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("setend", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        Clrex::Clrex(ExtMachInst machInst)  : PredOp("clrex", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = MISCREG_LOCKFLAG + Misc_Reg_Base;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Isb::Isb(ExtMachInst machInst)  : PredOp("isb", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsSerializeAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dsb::Dsb(ExtMachInst machInst)  : PredOp("dsb", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsMemBarrier] = true;
	flags[IsSerializeAfter] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dmb::Dmb(ExtMachInst machInst)  : PredOp("dmb", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsMemBarrier] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dbg::Dbg(ExtMachInst machInst)  : PredOp("dbg", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    inline Cps::Cps(ExtMachInst machInst, uint64_t _imm)
        : ImmOp("cps", machInst, IntAluOp, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ4::STORE_IMM_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ4::STORE_REG_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ4::STORE_IMM_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ4::STORE_REG_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ4::STORE_IMM_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ4::STORE_REG_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ4::STORE_IMM_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ4::STORE_REG_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("str", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WN_SZ4::STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WN_SZ4::STORE_REG_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WN_SZ4::STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WN_SZ4::STORE_REG_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("str", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ4::STORE_IMM_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ4::STORE_REG_AY_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ4::STORE_IMM_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ4::STORE_REG_AN_PY_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ4::STORE_IMM_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ4::STORE_REG_AY_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ4::STORE_IMM_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ4::STORE_REG_AN_PN_SN_UY_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ4Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WN_SZ4::STORE_IMM_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WN_SZ4::STORE_REG_AY_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WN_SZ4::STORE_IMM_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WN_SZ4::STORE_REG_AN_PN_SN_UY_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ4(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ1::STORE_IMM_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ1::STORE_REG_AY_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ1::STORE_IMM_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ1::STORE_REG_AN_PY_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ1::STORE_IMM_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ1::STORE_REG_AY_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ1::STORE_IMM_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ1::STORE_REG_AN_PN_SN_UN_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strb", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WN_SZ1::STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WN_SZ1::STORE_REG_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WN_SZ1::STORE_IMM_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WN_SZ1::STORE_REG_AN_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ1::STORE_IMM_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ1::STORE_REG_AY_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ1::STORE_IMM_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ1::STORE_REG_AN_PY_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ1::STORE_IMM_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ1::STORE_REG_AY_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ1::STORE_IMM_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ1::STORE_REG_AN_PN_SN_UY_WY_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strbt", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ1Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WN_SZ1::STORE_IMM_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WN_SZ1::STORE_REG_AY_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WN_SZ1::STORE_IMM_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WN_SZ1::STORE_REG_AN_PN_SN_UY_WN_SZ1(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strbt", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ1(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UN_WY_SZ2::STORE_IMM_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UN_WY_SZ2::STORE_REG_AY_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UN_WY_SZ2::STORE_IMM_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UN_WY_SZ2::STORE_REG_AN_PY_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WY_SZ2::STORE_IMM_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WY_SZ2::STORE_REG_AY_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WY_SZ2::STORE_IMM_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WY_SZ2::STORE_REG_AN_PN_SN_UN_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strh", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UN_WN_SZ2::STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UN_WN_SZ2::STORE_REG_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UN_WN_SZ2::STORE_IMM_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UN_WN_SZ2::STORE_REG_AN_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strh", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UN_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PY_SN_UY_WY_SZ2::STORE_IMM_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PY_SN_UY_WY_SZ2::STORE_REG_AY_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PY_SN_UY_WY_SZ2::STORE_IMM_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PY_SN_UY_WY_SZ2::STORE_REG_AN_PY_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PY_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WY_SZ2::STORE_IMM_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WY_SZ2::STORE_REG_AY_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WY_SZ2::STORE_IMM_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryImm>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WY_SZ2::STORE_REG_AN_PN_SN_UY_WY_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryReg>("strht", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WY_SZ2Acc(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AY_PN_SN_UY_WN_SZ2::STORE_IMM_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AY_PN_SN_UY_WN_SZ2::STORE_REG_AY_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AY_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMM_AN_PN_SN_UY_WN_SZ2::STORE_IMM_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMM_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REG_AN_PN_SN_UY_WN_SZ2::STORE_REG_AN_PN_SN_UY_WN_SZ2(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryReg>("strht", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REG_AN_PN_SN_UY_WN_SZ2(machInst, _dest, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, IntAluOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst,
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              intRegInMode((OperatingMode)regMode, INTREG_SP),
                              -8);;
        uops[1]->setLastMicroop();
#endif
    }

    inline SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(ExtMachInst machInst,
            uint32_t _regMode, int _mode, bool _wb)
         : SrsOp("srs", machInst, MemWriteOp,
                 (OperatingMode)_regMode, (AddrMode)_mode, _wb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = INTREG_LR;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = intRegInMode((OperatingMode)regMode, INTREG_SP);
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(machInst, _regMode, _mode, _wb);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AY_PY_SN_UN_WY_SZ4::STORE_IMMD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AY_PY_SN_UN_WY_SZ4::STORE_REGD_AY_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AN_PY_SN_UN_WY_SZ4::STORE_IMMD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPostIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AN_PY_SN_UN_WY_SZ4::STORE_REGD_AN_PY_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPostIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AY_PN_SN_UN_WY_SZ4::STORE_IMMD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroAddiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AY_PN_SN_UN_WY_SZ4::STORE_REGD_AY_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroAddUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AN_PN_SN_UN_WY_SZ4::STORE_IMMD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryPreIndex<MemoryDImm>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new MicroSubiUop(machInst, base, base, imm);;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AN_PN_SN_UN_WY_SZ4::STORE_REGD_AN_PN_SN_UN_WY_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryPreIndex<MemoryDReg>("strd", machInst, IntAluOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	flags[IsMacroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 1
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new 
                     MicroSubUop(machInst, base, base, index, shiftAmt, shiftType);
                 ;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AY_PN_SN_UN_WN_SZ4::STORE_REGD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_IMMD_AN_PN_SN_UN_WN_SZ4::STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STORE_REGD_AN_PN_SN_UN_WN_SZ4::STORE_REGD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2, uint32_t _base, bool _add,
            int32_t _shiftAmt, uint32_t _shiftType, uint32_t _index)
         : MemoryOffset<MemoryDReg>("strd", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add,
                 _shiftAmt, (ArmShiftType)_shiftType,
                 (IntRegIndex)_index)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	_srcRegIdx[_numSrcRegs++] = index;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STORE_REGD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add,
                                   _shiftAmt, _shiftType, _index);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strex", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexh", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _base,
            bool _add, int32_t _imm)
         : MemoryOffset<MemoryExImm>("strexb", machInst, MemWriteOp,
                 (IntRegIndex)_result, (IntRegIndex)_dest,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, _result, _dest,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _result, uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryExDImm>("strexd", machInst, MemWriteOp,
                 (IntRegIndex)_result,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = result;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = dest;
	_srcRegIdx[_numSrcRegs++] = dest2;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _result, _dest, _dest2,
                                   _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(ExtMachInst machInst,
            uint32_t _dest, uint32_t _dest2,
            uint32_t _base, bool _add, int32_t _imm)
         : MemoryOffset<MemoryDImm>("vstr", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_dest2,
                 (IntRegIndex)_base, _add, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
#if 0
        assert(numMicroops >= 2);
        uops = new StaticInstPtr[numMicroops];
        uops[0] = new VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, _dest, _dest2, _base, _add, _imm);
        uops[0]->setDelayedCommit();
        uops[1] = new None;
        uops[1]->setLastMicroop();
#endif
    }

    inline Swp::Swp(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swp", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Swpb::Swpb(ExtMachInst machInst,
            uint32_t _dest, uint32_t _op1, uint32_t _base)
         : Swap("swpb", machInst, MemWriteOp,
                 (IntRegIndex)_dest, (IntRegIndex)_op1, (IntRegIndex)_base)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsStore] = true;
	flags[IsStoreConditional] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrUop::MicroLdrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrRetUop::MicroLdrRetUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldr_ret_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_NZ;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_V;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrFpUop::MicroLdrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDBFpUop::MicroLdrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroLdrDTFpUop::MicroLdrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("ldrfp_uop", machInst, MemReadOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrUop::MicroStrUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("str_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrFpUop::MicroStrFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDBFpUop::MicroStrDBFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroStrDTFpUop::MicroStrDTFpUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   bool _up,
                                   uint8_t _imm)
        : MicroMemOp("strfp_uop", machInst, MemWriteOp,
                         _ura, _urb, _up, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = ura + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsMemRef] = true;
	flags[IsMicroop] = true;
	flags[IsStore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddiUop::MicroAddiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("addi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubiUop::MicroSubiUop(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb,
                                   int32_t _imm)
        : MicroIntImmOp("subi_uop", machInst, IntAluOp,
                         _ura, _urb, _imm)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroAddUop::MicroAddUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("add_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroSubUop::MicroSubUop(ExtMachInst machInst,
                                   RegIndex _ura, RegIndex _urb, RegIndex _urc,
                                   int32_t _shiftAmt, ArmShiftType _shiftType)
        : MicroIntRegOp("sub_uop", machInst, IntAluOp,
                         _ura, _urb, _urc, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_srcRegIdx[_numSrcRegs++] = urc;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopRegMov::MicroUopRegMov(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("uopReg_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = ura;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopRegMovRet::MicroUopRegMovRet(ExtMachInst machInst,
                                   RegIndex _ura,
                                   RegIndex _urb)
        : MicroIntMov("movret_uop", machInst, IntAluOp,
                         _ura, _urb)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    MicroUopSetPCCPSR::MicroUopSetPCCPSR(ExtMachInst machInst,
                                   IntRegIndex _ura,
                                   IntRegIndex _urb,
                                   IntRegIndex _urc)
          : MicroSetPCCPSR("uopSet_uop", machInst, IntAluOp,
                           _ura, _urb, _urc)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = urc;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = ura;
	_srcRegIdx[_numSrcRegs++] = urb;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsMicroop] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            flags[IsCondControl] = true;
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        } else {
            flags[IsUncondControl] = true;
        }
    }

LdmStm::LdmStm(ExtMachInst machInst, IntRegIndex rn,
        bool index, bool up, bool user, bool writeback, bool load,
        uint32_t reglist)
    : MacroMemOp("ldmstm", machInst, IntAluOp, rn,
                     index, up, user, writeback, load, reglist)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


VldMult::VldMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VldMultOp("vldmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VldSingle::VldSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VldSingleOp("vldsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstMult::VstMult(ExtMachInst machInst, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm)
    : VstMultOp("vstmult", machInst, IntAluOp, width,
                     rn, vd, regs, inc, size, align, rm)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VstSingle::VstSingle(ExtMachInst machInst, bool all, unsigned width,
        RegIndex rn, RegIndex vd, unsigned regs, unsigned inc,
        uint32_t size, uint32_t align, RegIndex rm, unsigned lane)
    : VstSingleOp("vstsingle", machInst, IntAluOp, all, width,
                     rn, vd, regs, inc, size, align, rm, lane)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}

VLdmStm::VLdmStm(ExtMachInst machInst, IntRegIndex rn,
        RegIndex vd, bool single, bool up, bool writeback, bool load,
        uint32_t offset)
    : MacroVFPMemOp("vldmstm", machInst, IntAluOp, rn,
                     vd, single, up, writeback, load, offset)
{
    
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;;
    if (!(condCode == COND_AL || condCode == COND_UC)) {
        for (int x = 0; x < _numDestRegs; x++) {
            _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
        }
    }
}


    inline AndImm::AndImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("and", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AndImmCc::AndImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AndReg::AndReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AndRegCc::AndRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AndRegReg::AndRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("and", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AndRegRegCc::AndRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AndsImmPclr::AndsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("ands", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AndsRegPclr::AndsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ands", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline EorImm::EorImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eor", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline EorImmCc::EorImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline EorReg::EorReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline EorRegCc::EorRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline EorRegReg::EorRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eor", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline EorRegRegCc::EorRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline EorsImmPclr::EorsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("eors", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline EorsRegPclr::EorsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("eors", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SubImm::SubImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sub", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SubImmCc::SubImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SubReg::SubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SubRegCc::SubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SubRegReg::SubRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SubRegRegCc::SubRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SubsImmPclr::SubsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("subs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SubsRegPclr::SubsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("subs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RsbImm::RsbImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RsbImmCc::RsbImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RsbReg::RsbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RsbRegCc::RsbRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RsbRegReg::RsbRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline RsbRegRegCc::RsbRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline RsbsImmPclr::RsbsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RsbsRegPclr::RsbsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsbs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AddImm::AddImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("add", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AddImmCc::AddImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AddReg::AddReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AddRegCc::AddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AddRegReg::AddRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("add", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AddRegRegCc::AddRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AddsImmPclr::AddsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adds", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AddsRegPclr::AddsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AdrImm::AdrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AdrImmCc::AdrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AdcImm::AdcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AdcImmCc::AdcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AdcReg::AdcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AdcRegCc::AdcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline AdcRegReg::AdcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AdcRegRegCc::AdcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline AdcsImmPclr::AdcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline AdcsRegPclr::AdcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("adcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SbcImm::SbcImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SbcImmCc::SbcImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SbcReg::SbcReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SbcRegCc::SbcRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SbcRegReg::SbcRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SbcRegRegCc::SbcRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SbcsImmPclr::SbcsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline SbcsRegPclr::SbcsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sbcs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RscImm::RscImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RscImmCc::RscImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RscReg::RscReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RscRegCc::RscRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline RscRegReg::RscRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rsc", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline RscRegRegCc::RscRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline RscsImmPclr::RscsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline RscsRegPclr::RscsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("rscs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TstImm::TstImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tst", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TstImmCc::TstImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TstReg::TstReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TstRegCc::TstRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TstRegReg::TstRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tst", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline TstRegRegCc::TstRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline TstsImmPclr::TstsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TstsRegPclr::TstsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("tsts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TeqImm::TeqImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teq", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TeqImmCc::TeqImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TeqReg::TeqReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TeqRegCc::TeqRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline TeqRegReg::TeqRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teq", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline TeqRegRegCc::TeqRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline TeqsImmPclr::TeqsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline TeqsRegPclr::TeqsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("teqs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmpImm::CmpImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmpImmCc::CmpImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmpReg::CmpReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmpRegCc::CmpRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmpRegReg::CmpRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmp", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline CmpRegRegCc::CmpRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline CmpsImmPclr::CmpsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmpsRegPclr::CmpsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmps", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmnImm::CmnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmnImmCc::CmnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmnReg::CmnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmnRegCc::CmnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline CmnRegReg::CmnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline CmnRegRegCc::CmnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline CmnsImmPclr::CmnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline CmnsRegPclr::CmnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("cmns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrrImm::OrrImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orr", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrrImmCc::OrrImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrrReg::OrrReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrrRegCc::OrrRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrrRegReg::OrrRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orr", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline OrrRegRegCc::OrrRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline OrrsImmPclr::OrrsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrrsRegPclr::OrrsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orrs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrnImm::OrnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrnImmCc::OrnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrnReg::OrnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrnRegCc::OrnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline OrnRegReg::OrnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline OrnRegRegCc::OrnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline OrnsImmPclr::OrnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("orns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline OrnsRegPclr::OrnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("orns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovImm::MovImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mov", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovImmCc::MovImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovReg::MovReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovRegCc::MovRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (dest == INTREG_PC && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (op2 == INTREG_LR) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovRegReg::MovRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mov", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MovRegRegCc::MovRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MovsImmPclr::MovsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movs", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovsRegPclr::MovsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline BicImm::BicImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bic", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline BicImmCc::BicImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline BicReg::BicReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline BicRegCc::BicRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline BicRegReg::BicRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bic", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline BicRegRegCc::BicRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline BicsImmPclr::BicsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("bics", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline BicsRegPclr::BicsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("bics", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MvnImm::MvnImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MvnImmCc::MvnImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MvnReg::MvnReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MvnRegCc::MvnRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MvnRegReg::MvnRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvn", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MvnRegRegCc::MvnRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MvnsImmPclr::MvnsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MvnsRegPclr::MvnsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("mvns", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovtImm::MovtImm(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movt", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovtImmCc::MovtImmCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovtReg::MovtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovtRegCc::MovtRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline MovtRegReg::MovtRegReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MovtRegRegCc::MovtRegRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          IntRegIndex _shift,
                                          ArmShiftType _shiftType)
        : DataRegRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shift, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = shift;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MovtsImmPclr::MovtsImmPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint32_t _imm,
                                          bool _rotC)
        : DataImmOp("movts", machInst, IntAluOp,
                         _dest, _op1, _imm, _rotC)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;
        }
    }

    inline MovtsRegPclr::MovtsRegPclr(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("movts", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = INTREG_CONDCODES_C;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SPSR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = MISCREG_SEV_MAILBOX + Misc_Reg_Base;
	flags[IsControl] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QaddRegCc::QaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Qadd16Reg::Qadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Qadd8Reg::Qadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QdaddRegCc::QdaddRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdadds", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QsubReg::QsubReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QsubRegCc::QsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Qsub16Reg::Qsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Qsub8Reg::Qsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QdsubRegCc::QdsubRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qdsubs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QasxReg::QasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline QsaxReg::QsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("qsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Sadd8RegCc::Sadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Sadd16RegCc::Sadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Ssub8RegCc::Ssub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Ssub16RegCc::Ssub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SasxReg::SasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SasxRegCc::SasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("sasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SsaxReg::SsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline SsaxRegCc::SsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("ssaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Shadd8Reg::Shadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Shadd16Reg::Shadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Shsub8Reg::Shsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Shsub16Reg::Shsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline ShasxReg::ShasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline ShasxRegCc::ShasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline ShsaxReg::ShsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline ShsaxRegCc::ShsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("shsaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uqadd16Reg::Uqadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uqadd8Reg::Uqadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uqsub16Reg::Uqsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uqsub8Reg::Uqsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UqasxReg::UqasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UqsaxReg::UqsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uqsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uadd16RegCc::Uadd16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uadd8RegCc::Uadd8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uadd8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Usub16RegCc::Usub16RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub16s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Usub8RegCc::Usub8RegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usub8s", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UasxRegCc::UasxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uasxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UsaxRegCc::UsaxRegCc(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("usaxs", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_GE;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uhadd16Reg::Uhadd16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uhadd8Reg::Uhadd8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhadd8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uhsub16Reg::Uhsub16Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub16", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline Uhsub8Reg::Uhsub8Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsub8", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UhasxReg::UhasxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhasx", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline UhsaxReg::UhsaxReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("uhsax", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline PkhbtReg::PkhbtReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhbt", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline PkhtbReg::PkhtbReg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          int32_t _shiftAmt,
                                          ArmShiftType _shiftType)
        : DataRegOp("pkhtb", machInst, IntAluOp,
                         _dest, _op1, _op2, _shiftAmt, _shiftType)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC ||
                shiftType == ROR) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }

        if (0 && !isFloating()){
            flags[IsControl] = true;
            flags[IsIndirectControl] = true;
            if (condCode == COND_AL || condCode == COND_UC)
                flags[IsUncondControl] = true;
            else
                flags[IsCondControl] = true;

            if (0) {
                flags[IsReturn] = true;
            }
        }

    }

    inline B::B(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("b", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    B::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC(branchPC.instPC() + imm);
        pcs.advance();
        return pcs;
    }

    inline Bl::Bl(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("bl", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    Bl::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.instNPC(branchPC.instPC() + imm);
        pcs.advance();
        return pcs;
    }

    inline BlxImm::BlxImm(ExtMachInst machInst,
                                          int32_t _imm,
                                          ConditionCode _condCode)
        : BranchImmCond("blx", machInst, IntAluOp,
                         _imm, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }


    ArmISA::PCState
    BlxImm::branchTarget(const ArmISA::PCState &branchPC) const
    {
        ;
        ;

        ArmISA::PCState pcs = branchPC;
        pcs.nextThumb(!branchPC.thumb());

            pcs.instNPC((branchPC.thumb() ? (roundDown(branchPC.instPC(),4) + imm) :
                                (branchPC.instPC() + imm)));
            
        pcs.advance();
        return pcs;
    }

    inline BlxReg::BlxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("blx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = INTREG_LR;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsCall] = true;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (0)
            flags[IsReturn] = true;
    }

    inline BxReg::BxReg(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          ConditionCode _condCode)
        : BranchRegCond("bx", machInst, IntAluOp,
                         _op1, _condCode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
        if (op1 == INTREG_LR)
            flags[IsReturn] = true;
    }

    inline Cbz::Cbz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }

    inline Cbnz::Cbnz(ExtMachInst machInst,
                                          int32_t _imm,
                                          IntRegIndex _op1)
        : BranchImmReg("cbnz", machInst, IntAluOp, _imm, _op1)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;;
        flags[IsCondControl] = true;
    }

    inline Tbb::Tbb(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbb", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    inline Tbh::Tbh(ExtMachInst machInst,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : BranchRegReg("tbh", machInst, MemReadOp, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op1;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsControl] = true;
	flags[IsIndirectControl] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;
	flags[IsMemRef] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
            flags[IsCondControl] = true;
        } else {
            flags[IsUncondControl] = true;
        }
    }

    inline Mla::Mla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MlaCc::MlaCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mlas", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mls::Mls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("mls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Mul::Mul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("mul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline MulCc::MulCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("muls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlabbCc::SmlabbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlabtCc::SmlabtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlabts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlatbCc::SmlatbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlattCc::SmlattCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlatts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmladCc::SmladCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmladxCc::SmladxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smladxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlal::Smlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlalCc::SmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlalbb::Smlalbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlalbt::Smlalbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlalbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlaltb::Smlaltb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlaltt::Smlaltt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaltt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlald::Smlald(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlald", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlaldx::Smlaldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlaldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlawbCc::SmlawbCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawbs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlawtCc::SmlawtCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlawts", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlsdCc::SmlsdCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsds", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmlsdxCc::SmlsdxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsdxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlsld::Smlsld(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsld", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smlsldx::Smlsldx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smlsldx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmla::Smmla(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmla", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmlar::Smmlar(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlar", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmls::Smmls(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmlsr::Smmlsr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smmlsr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmul::Smmul(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmul", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smmulr::Smmulr(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smmulr", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmuadCc::SmuadCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuads", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmuadxCc::SmuadxCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smuadxs", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_destRegIdx[_numDestRegs++] = MISCREG_CPSR_Q + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smulbb::Smulbb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smulbt::Smulbt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulbt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smultb::Smultb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smultt::Smultt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smultt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smull::Smull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline SmullCc::SmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("smulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smulwb::Smulwb(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwb", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smulwt::Smulwt(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smulwt", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smusd::Smusd(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusd", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Smusdx::Smusdx(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2)
        : Mult3("smusdx", machInst, IntMultOp,
                         _reg0, _reg1, _reg2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_srcRegIdx[_numSrcRegs++] = reg2;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Umaal::Umaal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umaal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Umlal::Umlal(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlal", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline UmlalCc::UmlalCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umlals", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_srcRegIdx[_numSrcRegs++] = reg0;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = reg1;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Umull::Umull(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umull", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline UmullCc::UmullCc(ExtMachInst machInst,
                                          IntRegIndex _reg0,
                                          IntRegIndex _reg1,
                                          IntRegIndex _reg2,
                                          IntRegIndex _reg3)
        : Mult4("umulls", machInst, IntMultOp,
                         _reg0, _reg1, _reg2, _reg3)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = reg2;
	_srcRegIdx[_numSrcRegs++] = reg3;
	_destRegIdx[_numDestRegs++] = reg1;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = reg0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Sdiv::Sdiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("sdiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Udiv::Udiv(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("udiv", machInst, IntDivOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = op2;
	_srcRegIdx[_numSrcRegs++] = MISCREG_SCTLR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Vmsr::Vmsr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmsr", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmsrFpscr::VmsrFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmsr", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSquashAfter] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Vmrs::Vmrs(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmrs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1 + Misc_Reg_Base;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmrsFpscr::VmrsFpscr(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmrs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_FPCONDCODES;
	flags[IsInteger] = true;
	flags[IsSerializeBefore] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

        VmrsApsrFpscr::VmrsApsrFpscr(ExtMachInst machInst)  : PredOp("vmrs", machInst, SimdFloatMiscOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = INTREG_FPCONDCODES;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_NZ;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_C;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = INTREG_CONDCODES_V;
	_numIntDestRegs++;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    inline VmovImmS::VmovImmS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovImmD::VmovImmD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovImmQ::VmovImmQ(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegS::VmovRegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegD::VmovRegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegQ::VmovRegQ(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 2) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 3) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovCoreRegB::VmovCoreRegB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovCoreRegH::VmovCoreRegH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovCoreRegW::VmovCoreRegW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegCoreUB::VmovRegCoreUB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegCoreUH::VmovRegCoreUH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegCoreSB::VmovRegCoreSB(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegCoreSH::VmovRegCoreSH(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmovRegCoreW::VmovRegCoreW(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vmov", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Vmov2Reg2Core::Vmov2Reg2Core(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op1;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = op2;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline Vmov2Core2Reg::Vmov2Core2Reg(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmov", machInst, SimdFloatMiscOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = dest;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = op1;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VaddS::VaddS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vadds", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VaddD::VaddD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vaddd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VsubS::VsubS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubs", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VsubD::VsubD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vsubd", machInst, SimdFloatAddOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VdivS::VdivS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivs", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VdivD::VdivD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vdivd", machInst, SimdFloatDivOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmulS::VmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmulD::VmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VsqrtS::VsqrtS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrts", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VsqrtD::VsqrtD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vsqrtd", machInst, SimdFloatSqrtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnegS::VnegS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegs", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnegD::VnegD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vnegd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VabsS::VabsS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabss", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VabsD::VabsD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vabsd", machInst, SimdFloatMiscOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmlaS::VmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmlaD::VmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmlsS::VmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VmlsD::VmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmlaS::VnmlaS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlas", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmlaD::VnmlaD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlad", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmlsS::VnmlsS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlss", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmlsD::VnmlsD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmlsd", machInst, SimdFloatMultAccOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmulS::VnmulS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuls", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VnmulD::VnmulD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2,
                                          VfpMicroMode mode)
        : FpRegRegRegOp("vnmuld", machInst, SimdFloatMultOp,
                         _dest, _op1, _op2, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUIntFpS::VcvtUIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUIntFpD::VcvtUIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSIntFpS::VcvtSIntFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSIntFpD::VcvtSIntFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUIntSR::VcvtFpUIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUIntDR::VcvtFpUIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSIntSR::VcvtFpSIntSR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSIntDR::VcvtFpSIntDR(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtr", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUIntS::VcvtFpUIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUIntD::VcvtFpUIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSIntS::VcvtFpSIntS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSIntD::VcvtFpSIntD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSFpD::VcvtFpSFpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpDFpS::VcvtFpDFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpHTFpS::VcvtFpHTFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpHBFpS::VcvtFpHBFpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSFpHT::VcvtFpSFpHT(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtt", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSFpHB::VcvtFpSFpHB(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcvtb", machInst, SimdFloatCvtOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpS::VcmpS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmps", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpD::VcmpD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpd", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpZeroS::VcmpZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpZeroD::VcmpZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpeS::VcmpeS(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmpes", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpeD::VcmpeD(ExtMachInst machInst,
                                          IntRegIndex _dest, IntRegIndex _op1,
                                          VfpMicroMode mode)
        : FpRegRegOp("vcmped", machInst, SimdFloatCmpOp,
                _dest, _op1, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpeZeroS::VcmpeZeroS(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZeros", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcmpeZeroD::VcmpeZeroD(ExtMachInst machInst,
            IntRegIndex _dest, uint64_t _imm, VfpMicroMode mode)
        : FpRegImmOp("vcmpeZerod", machInst, SimdFloatCmpOp,
                _dest, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = INTREG_FPCONDCODES;
	_numIntDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSFixedS::VcvtFpSFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSFixedD::VcvtFpSFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUFixedS::VcvtFpUFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUFixedD::VcvtFpUFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSFixedFpS::VcvtSFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSFixedFpD::VcvtSFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUFixedFpS::VcvtUFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUFixedFpD::VcvtUFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSHFixedS::VcvtFpSHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpSHFixedD::VcvtFpSHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUHFixedS::VcvtFpUHFixedS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtFpUHFixedD::VcvtFpUHFixedD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSHFixedFpS::VcvtSHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtSHFixedFpD::VcvtSHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUHFixedFpS::VcvtUHFixedFpS(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline VcvtUHFixedFpD::VcvtUHFixedFpD(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          uint64_t _imm,
                                          VfpMicroMode mode)
        : FpRegRegImmOp("vcvt", machInst, SimdFloatCvtOp,
                         _dest, _op1, _imm, mode)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPSR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = MISCREG_CPACR + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPEXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_destRegIdx[_numDestRegs++] = MISCREG_FPSCR_EXC + Misc_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbl1::NVtbl1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbl2::NVtbl2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbl3::NVtbl3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbl4::NVtbl4(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbl", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbx1::NVtbx1(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbx2::NVtbx2(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbx3::NVtbx3(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    inline NVtbx4::NVtbx4(ExtMachInst machInst,
                                          IntRegIndex _dest,
                                          IntRegIndex _op1,
                                          IntRegIndex _op2)
        : RegRegRegOp("vtbx", machInst, SimdMiscOp,
                         _dest, _op1, _op2)
    {
        
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (op2 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op2 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (dest + 0) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 0) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (dest + 1) + FP_Reg_Base;
	_destRegIdx[_numDestRegs++] = (dest + 1) + FP_Reg_Base;
	_numFPDestRegs++;
	_srcRegIdx[_numSrcRegs++] = (op1 + 0) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 1) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 2) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 3) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 4) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 5) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 6) + FP_Reg_Base;
	_srcRegIdx[_numSrcRegs++] = (op1 + 7) + FP_Reg_Base;
	flags[IsFloating] = true;;
        if (!(condCode == COND_AL || condCode == COND_UC)) {
            for (int x = 0; x < _numDestRegs; x++) {
                _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
            }
        }
    }

    uint64_t join32to64(uint32_t r1, uint32_t r0)
    {
        uint64_t r = r1;
        r <<= 32;
        r |= r0;
        return r;
    }
    
        Arm::Arm(ExtMachInst machInst)  : PredOp("arm", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Quiesce::Quiesce(ExtMachInst machInst)  : PredOp("quiesce", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceNs::QuiesceNs(ExtMachInst machInst)  : PredOp("quiesceNs", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceCycles::QuiesceCycles(ExtMachInst machInst)  : PredOp("quiesceCycles", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsQuiesce] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        QuiesceTime::QuiesceTime(ExtMachInst machInst)  : PredOp("quiesceTime", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Rpns::Rpns(ExtMachInst machInst)  : PredOp("rpns", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        WakeCPU::WakeCPU(ExtMachInst machInst)  : PredOp("wakeCPU", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_ivlb::Deprecated_ivlb(ExtMachInst machInst)  : PredOp("deprecated_ivlb", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_ivle::Deprecated_ivle(ExtMachInst machInst)  : PredOp("deprecated_ivle", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Deprecated_exit::Deprecated_exit(ExtMachInst machInst)  : PredOp("deprecated_exit", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5exit::M5exit(ExtMachInst machInst)  : PredOp("m5exit", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5fail::M5fail(ExtMachInst machInst)  : PredOp("m5fail", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Loadsymbol::Loadsymbol(ExtMachInst machInst)  : PredOp("loadsymbol", machInst, No_OpClass)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Initparam::Initparam(ExtMachInst machInst)  : PredOp("initparam", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_destRegIdx[_numDestRegs++] = 1;
	_numIntDestRegs++;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Resetstats::Resetstats(ExtMachInst machInst)  : PredOp("resetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpstats::Dumpstats(ExtMachInst machInst)  : PredOp("dumpstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        Dumpresetstats::Dumpresetstats(ExtMachInst machInst)  : PredOp("dumpresetstats", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5checkpoint::M5checkpoint(ExtMachInst machInst)  : PredOp("m5checkpoint", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5readfile::M5readfile(ExtMachInst machInst)  : PredOp("m5readfile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsUnverifiable] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5writefile::M5writefile(ExtMachInst machInst)  : PredOp("m5writefile", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 0;
	_destRegIdx[_numDestRegs++] = 0;
	_numIntDestRegs++;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5break::M5break(ExtMachInst machInst)  : PredOp("m5break", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5switchcpu::M5switchcpu(ExtMachInst machInst)  : PredOp("m5switchcpu", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5addsymbol::M5addsymbol(ExtMachInst machInst)  : PredOp("m5addsymbol", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5panic::M5panic(ExtMachInst machInst)  : PredOp("m5panic", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workbegin::M5workbegin(ExtMachInst machInst)  : PredOp("m5workbegin", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

        M5workend::M5workend(ExtMachInst machInst)  : PredOp("m5workend", machInst, IntAluOp)
        {
                
	_numSrcRegs = 0;
	_numDestRegs = 0;
	_numFPDestRegs = 0;
	_numIntDestRegs = 0;
	_numCCDestRegs = 0;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_AL || condCode == COND_UC ||
                condCode == COND_CC || condCode == COND_CS ||
                condCode == COND_VS || condCode == COND_VC) ?
               INTREG_ZERO : INTREG_CONDCODES_NZ;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_HI || condCode == COND_LS ||
                condCode == COND_CS || condCode == COND_CC) ?
               INTREG_CONDCODES_C : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = (condCode == COND_VS || condCode == COND_VC ||
                condCode == COND_GE || condCode == COND_LT ||
                condCode == COND_GT || condCode == COND_LE) ?
               INTREG_CONDCODES_V : INTREG_ZERO;
	_srcRegIdx[_numSrcRegs++] = 1;
	_srcRegIdx[_numSrcRegs++] = 0;
	_srcRegIdx[_numSrcRegs++] = 3;
	_srcRegIdx[_numSrcRegs++] = 2;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;;
                if (!(condCode == COND_AL || condCode == COND_UC)) {
                    for (int x = 0; x < _numDestRegs; x++) {
                        _srcRegIdx[_numSrcRegs++] = _destRegIdx[x];
                    }
                }
        }

    StaticInstPtr
    decodeNeonMem(ExtMachInst machInst)
    {
        const uint32_t b = bits(machInst, 11, 8);
        const bool single = bits(machInst, 23);
        const bool singleAll = single && (bits(b, 3, 2) == 3);
        const bool load = bits(machInst, 21);
        unsigned width = 0;
        if (single) {
            width = bits(b, 1, 0) + 1;
        } else {
            switch (bits(b, 3, 1)) {
              case 0x0: width = 4;
                break;
              case 0x1: width = (b & 0x1) ? 2 : 1;
                break;
              case 0x2: width = 3;
                break;
              case 0x3: width = 1;
                break;
              case 0x4: width = 2;
                break;
              case 0x5:
                if ((b & 0x1) == 0) {
                    width = 1;
                    break;
                }
                // Fall through on purpose.
              default:
                return new Unknown(machInst);
            }
        }
        assert(width > 0 && width <= 4);
        const RegIndex rm = (RegIndex)(uint32_t)bits(machInst, 3, 0);
        const RegIndex rn = (RegIndex)(uint32_t)bits(machInst, 19, 16);
        const RegIndex vd = (RegIndex)(uint32_t)(bits(machInst, 15, 12) |
                                                 bits(machInst, 22) << 4);
        const uint32_t type = bits(machInst, 11, 8);
        uint32_t size = 0;
        uint32_t align = TLB::MustBeOne;
        unsigned inc = 1;
        unsigned regs = 1;
        unsigned lane = 0;
        if (single) {
            if (singleAll) {
                size = bits(machInst, 7, 6);
                bool t = bits(machInst, 5);
                unsigned eBytes = (1 << size);
                align = (eBytes - 1) | TLB::AllowUnaligned;
                if (width == 1) {
                    regs = t ? 2 : 1;
                    inc = 1;
                } else {
                    regs = width;
                    inc = t ? 2 : 1;
                }
                switch (width) {
                  case 1:
                  case 2:
                    if (bits(machInst, 4))
                        align = width * eBytes - 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    if (size == 3) {
                        if (bits(machInst, 4) == 0)
                            return new Unknown(machInst);
                        size = 2;
                        align = 0xf;
                    } else if (size == 2) {
                        if (bits(machInst, 4))
                            align = 7;
                    } else {
                        if (bits(machInst, 4))
                            align = 4 * eBytes - 1;
                    }
                    break;
                }
            } else {
                size = bits(machInst, 11, 10);
                unsigned eBytes = (1 << size);
                align = (eBytes - 1) | TLB::AllowUnaligned;
                regs = width;
                unsigned indexAlign = bits(machInst, 7, 4);
                // If width is 1, inc is always 1. That's overridden later.
                switch (size) {
                  case 0:
                    inc = 1;
                    lane = bits(indexAlign, 3, 1);
                    break;
                  case 1:
                    inc = bits(indexAlign, 1) ? 2 : 1;
                    lane = bits(indexAlign, 3, 2);
                    break;
                  case 2:
                    inc = bits(indexAlign, 2) ? 2 : 1;
                    lane = bits(indexAlign, 3);
                    break;
                }
                // Override inc for width of 1.
                if (width == 1) {
                    inc = 1;
                }
                switch (width) {
                  case 1:
                    switch (size) {
                      case 0:
                        break;
                      case 1:
                        if (bits(indexAlign, 0))
                            align = 1;
                        break;
                      case 2:
                        if (bits(indexAlign, 1, 0))
                            align = 3;
                        break;
                    }
                    break;
                  case 2:
                    if (bits(indexAlign, 0))
                        align = (2 * eBytes) - 1;
                    break;
                  case 3:
                    break;
                  case 4:
                    switch (size) {
                      case 0:
                      case 1:
                        if (bits(indexAlign, 0))
                            align = (4 * eBytes) - 1;
                        break;
                      case 2:
                        if (bits(indexAlign, 0))
                            align = (4 << bits(indexAlign, 1, 0)) - 1;
                        break;
                    }
                    break;
                }
            }
            if (size == 0x3) {
                return new Unknown(machInst);
            }
        } else {
            size = bits(machInst, 7, 6);
            align = bits(machInst, 5, 4);
            if (align == 0) {
                // @align wasn't specified, so alignment can be turned off.
                align = ((1 << size) - 1) | TLB::AllowUnaligned;
            } else {
                align = ((4 << align) - 1);
            }
            switch (width) {
              case 1:
                switch (type) {
                  case 0x7: regs = 1;
                    break;
                  case 0xa: regs = 2;
                    break;
                  case 0x6: regs = 3;
                    break;
                  case 0x2: regs = 4;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 2:
                // Regs doesn't behave exactly as it does in the manual
                // because they loop over regs registers twice and we break
                // it down in the macroop.
                switch (type) {
                  case 0x8: regs = 2; inc = 1;
                    break;
                  case 0x9: regs = 2; inc = 2;
                    break;
                  case 0x3: regs = 4; inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 3:
                regs = 3;
                switch (type) {
                  case 0x4: inc = 1;
                    break;
                  case 0x5: inc = 2;;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
              case 4:
                regs = 4;
                switch (type) {
                  case 0: inc = 1;
                    break;
                  case 1: inc = 2;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                break;
            }
        }
        if (load) {
            // Load instructions.
            if (single) {
                return new VldSingle(machInst, singleAll, width, rn, vd,
                                     regs, inc, size, align, rm, lane);
            } else {
                return new VldMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        } else {
            // Store instructions.
            if (single) {
                if (singleAll) {
                    return new Unknown(machInst);
                } else {
                    return new VstSingle(machInst, false, width, rn, vd,
                                         regs, inc, size, align, rm, lane);
                }
            } else {
                return new VstMult(machInst, width, rn, vd,
                                   regs, inc, size, align, rm);
            }
        }
        return new Unknown(machInst);
    }
    
    static StaticInstPtr
    decodeNeonThreeRegistersSameLength(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const bool b = bits(machInst, 4);
        const uint32_t c = bits(machInst, 21, 20);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 21, 20);
        const bool q = bits(machInst, 6);
        if (q && ((vd & 0x1) || (vn & 0x1) || (vm & 0x1)))
            return new Unknown(machInst);
        switch (a) {
          case 0x0:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqaddUD, VqaddUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqaddSD, VqaddSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhaddD, VhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x1:
            if (!b) {
                return decodeNeonUSThreeReg<VrhaddD, VrhaddQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (u) {
                    switch (c) {
                      case 0:
                        if (q) {
                            return new VeorQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VeorD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbslQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbslD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (q) {
                            return new VbitQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbitD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 3:
                        if (q) {
                            return new VbifQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbifD<uint64_t>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    switch (c) {
                      case 0:
                        if (q) {
                            return new VandQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VandD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 1:
                        if (q) {
                            return new VbicQ<uint64_t>(machInst, vd, vn, vm);
                        } else {
                            return new VbicD<uint64_t>(machInst, vd, vn, vm);
                        }
                      case 2:
                        if (vn == vm) {
                            if (q) {
                                return new VmovQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VmovD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        } else {
                            if (q) {
                                return new VorrQ<uint64_t>(
                                        machInst, vd, vn, vm);
                            } else {
                                return new VorrD<uint64_t>(
                                        machInst, vd, vn, vm);
                            }
                        }
                      case 3:
                        if (q) {
                            return new VornQ<uint64_t>(
                                    machInst, vd, vn, vm);
                        } else {
                            return new VornD<uint64_t>(
                                    machInst, vd, vn, vm);
                        }
                    }
                }
            }
          case 0x2:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqsubUD, VqsubUQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<VqsubSD, VqsubSQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (size == 3)
                    return new Unknown(machInst);
                return decodeNeonUSThreeReg<VhsubD, VhsubQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x3:
            if (b) {
                return decodeNeonUSThreeReg<VcgeD, VcgeQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VcgtD, VcgtQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x4:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqshlUD, VqshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqshlSD, VqshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VshlD, VshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x5:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VqrshlUD, VqrshlUQ>(
                            q, size, machInst, vd, vm, vn);
                } else {
                    return decodeNeonSThreeReg<VqrshlSD, VqrshlSQ>(
                            q, size, machInst, vd, vm, vn);
                }
            } else {
                return decodeNeonUSThreeReg<VrshlD, VrshlQ>(
                        q, u, size, machInst, vd, vm, vn);
            }
          case 0x6:
            if (b) {
                return decodeNeonUSThreeReg<VminD, VminQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VmaxD, VmaxQ>(
                        q, u, size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (b) {
                return decodeNeonUSThreeReg<VabaD, VabaQ>(
                        q, u, size, machInst, vd, vn, vm);
            } else {
                if (bits(machInst, 23) == 1) {
                    if (q) {
                        return new Unknown(machInst);
                    } else {
                        return decodeNeonUSThreeUSReg<Vabdl>(
                                u, size, machInst, vd, vn, vm);
                    }
                } else {
                    return decodeNeonUSThreeReg<VabdD, VabdQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0x8:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<VceqD, VceqQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<VtstD, VtstQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUThreeReg<NVsubD, NVsubQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUThreeReg<NVaddD, NVaddQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0x9:
            if (b) {
                if (u) {
                    return decodeNeonUThreeReg<NVmulpD, NVmulpQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeReg<NVmulD, NVmulQ>(
                            q, size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonUSThreeReg<NVmlsD, NVmlsQ>(
                            q, u, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonUSThreeReg<NVmlaD, NVmlaQ>(
                            q, u, size, machInst, vd, vn, vm);
                }
            }
          case 0xa:
            if (q)
                return new Unknown(machInst);
            if (b) {
                return decodeNeonUSThreeUSReg<VpminD>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeUSReg<VpmaxD>(
                        u, size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (b) {
                if (u || q) {
                    return new Unknown(machInst);
                } else {
                    return decodeNeonUThreeUSReg<NVpaddD>(
                            size, machInst, vd, vn, vm);
                }
            } else {
                if (u) {
                    return decodeNeonSThreeSReg<VqrdmulhD, VqrdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                } else {
                    return decodeNeonSThreeSReg<VqdmulhD, VqdmulhQ>(
                            q, size, machInst, vd, vn, vm);
                }
            }
          case 0xc:
            return new Unknown(machInst);
          case 0xd:
            if (b) {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new NVmulQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmulDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new NVmlaQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlaDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new NVmlsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new NVmlsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VpaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VabdQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VabdDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VaddQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VaddDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VsubQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VsubDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
          case 0xe:
            if (b) {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VacgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VacgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VacgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    return new Unknown(machInst);
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VcgeQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgeDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VcgtQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VcgtDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VceqQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VceqDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xf:
            if (b) {
                if (u) {
                    return new Unknown(machInst);
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VrecpsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrecpsDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VrsqrtsQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VrsqrtsDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            } else {
                if (u) {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VpmaxQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpmaxDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VpminQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VpminDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                } else {
                    if (bits(c, 1) == 0) {
                        if (q) {
                            return new VmaxQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VmaxDFp<float>(machInst, vd, vn, vm);
                        }
                    } else {
                        if (q) {
                            return new VminQFp<float>(machInst, vd, vn, vm);
                        } else {
                            return new VminDFp<float>(machInst, vd, vn, vm);
                        }
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonOneRegModImm(ExtMachInst machInst)
    {
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const bool q = bits(machInst, 6);
        const bool op = bits(machInst, 5);
        const uint8_t cmode = bits(machInst, 11, 8);
        const uint8_t imm = ((THUMB ? bits(machInst, 28) :
                                      bits(machInst, 24)) << 7) |
                            (bits(machInst, 18, 16) << 4) |
                            (bits(machInst, 3, 0) << 0);
        // Check for invalid immediate encodings and return an unknown op
        // if it happens
        bool immValid = true;
        const uint64_t bigImm = simd_modified_imm(op, cmode, imm, immValid);
        if (!immValid) {
            return new Unknown(machInst);
        }
        if (op) {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    switch (bits(cmode, 1, 0)) {
                      case 0:
                      case 1:
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                      case 2:
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                      case 3:
                        if (q)
                            return new Unknown(machInst);
                        else
                            return new Unknown(machInst);
                    }
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmvniQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmvniD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVbiciQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVbiciD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        } else {
            if (bits(cmode, 3) == 0) {
                if (bits(cmode, 0) == 0) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (q)
                        return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVorriD<uint64_t>(machInst, vd, bigImm);
                }
            } else {
                if (bits(cmode, 2) == 1) {
                    if (q)
                        return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                    else
                        return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                } else {
                    if (bits(cmode, 0) == 0) {
                        if (q)
                            return new NVmoviQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVmoviD<uint64_t>(machInst, vd, bigImm);
                    } else {
                        if (q)
                            return new NVorriQ<uint64_t>(machInst, vd, bigImm);
                        else
                            return new NVorriD<uint64_t>(machInst, vd, bigImm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegAndShift(ExtMachInst machInst)
    {
        const uint32_t a = bits(machInst, 11, 8);
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const bool b = bits(machInst, 6);
        const bool l = bits(machInst, 7);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        unsigned imm6 = bits(machInst, 21, 16);
        unsigned imm = ((l ? 1 : 0) << 6) | imm6;
        unsigned size = 3;
        unsigned lShiftAmt = 0;
        unsigned bitSel;
        for (bitSel = 1 << 6; true; bitSel >>= 1) {
            if (bitSel & imm)
                break;
            else if (!size)
                return new Unknown(machInst);
            size--;
        }
        lShiftAmt = imm6 & ~bitSel;
        unsigned rShiftAmt = 0;
        if (a != 0xe && a != 0xf) {
            if (size > 2)
                rShiftAmt = 64 - imm6;
            else
                rShiftAmt = 2 * (8 << size) - imm6;
        }
        switch (a) {
          case 0x0:
            return decodeNeonUSTwoShiftReg<NVshrD, NVshrQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x1:
            return decodeNeonUSTwoShiftReg<NVsraD, NVsraQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x2:
            return decodeNeonUSTwoShiftReg<NVrshrD, NVrshrQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x3:
            return decodeNeonUSTwoShiftReg<NVrsraD, NVrsraQ>(
                    b, u, size, machInst, vd, vm, rShiftAmt);
          case 0x4:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsriD, NVsriQ>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return new Unknown(machInst);
            }
          case 0x5:
            if (u) {
                return decodeNeonUTwoShiftReg<NVsliD, NVsliQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            } else {
                return decodeNeonUTwoShiftReg<NVshlD, NVshlQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x6:
          case 0x7:
            if (u) {
                if (a == 0x6) {
                    return decodeNeonSTwoShiftReg<NVqshlusD, NVqshlusQ>(
                            b, size, machInst, vd, vm, lShiftAmt);
                } else {
                    return decodeNeonUTwoShiftReg<NVqshluD, NVqshluQ>(
                            b, size, machInst, vd, vm, lShiftAmt);
                }
            } else {
                return decodeNeonSTwoShiftReg<NVqshlD, NVqshlQ>(
                        b, size, machInst, vd, vm, lShiftAmt);
            }
          case 0x8:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonSTwoShiftSReg<NVqshruns, NVqrshruns>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonUTwoShiftSReg<NVshrn, NVrshrn>(
                        b, size, machInst, vd, vm, rShiftAmt);
            }
          case 0x9:
            if (l) {
                return new Unknown(machInst);
            } else if (u) {
                return decodeNeonUTwoShiftSReg<NVqshrun, NVqrshrun>(
                        b, size, machInst, vd, vm, rShiftAmt);
            } else {
                return decodeNeonSTwoShiftSReg<NVqshrn, NVqrshrn>(
                        b, size, machInst, vd, vm, rShiftAmt);
            }
          case 0xa:
            if (l || b) {
                return new Unknown(machInst);
            } else {
                return decodeNeonUSTwoShiftSReg<NVmovl, NVshll>(
                        lShiftAmt, u, size, machInst, vd, vm, lShiftAmt);
            }
          case 0xe:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (b) {
                        return new NVcvtu2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvtu2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (b) {
                        return new NVcvts2fpQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvts2fpD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
          case 0xf:
            if (l) {
                return new Unknown(machInst);
            } else {
                if (bits(imm6, 5) == 0)
                    return new Unknown(machInst);
                if (u) {
                    if (b) {
                        return new NVcvt2ufxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2ufxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                } else {
                    if (b) {
                        return new NVcvt2sfxQ<float>(
                                machInst, vd, vm, 64 - imm6);
                    } else {
                        return new NVcvt2sfxD<float>(
                                machInst, vd, vm, 64 - imm6);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonThreeRegDiffLengths(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 21, 20);
        switch (a) {
          case 0x0:
            return decodeNeonUSThreeUSReg<Vaddl>(
                    u, size, machInst, vd, vn, vm);
          case 0x1:
            return decodeNeonUSThreeUSReg<Vaddw>(
                    u, size, machInst, vd, vn, vm);
          case 0x2:
            return decodeNeonUSThreeUSReg<Vsubl>(
                    u, size, machInst, vd, vn, vm);
          case 0x3:
            return decodeNeonUSThreeUSReg<Vsubw>(
                    u, size, machInst, vd, vn, vm);
          case 0x4:
            if (u) {
                return decodeNeonUThreeUSReg<Vraddhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vaddhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x5:
            return decodeNeonUSThreeUSReg<Vabal>(
                    u, size, machInst, vd, vn, vm);
          case 0x6:
            if (u) {
                return decodeNeonUThreeUSReg<Vrsubhn>(
                        size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUThreeUSReg<Vsubhn>(
                        size, machInst, vd, vn, vm);
            }
          case 0x7:
            if (bits(machInst, 23)) {
                return decodeNeonUSThreeUSReg<Vabdl>(
                        u, size, machInst, vd, vn, vm);
            } else {
                return decodeNeonUSThreeReg<VabdD, VabdQ>(
                        bits(machInst, 6), u, size, machInst, vd, vn, vm);
            }
          case 0x8:
            return decodeNeonUSThreeUSReg<Vmlal>(
                    u, size, machInst, vd, vn, vm);
          case 0xa:
            return decodeNeonUSThreeUSReg<Vmlsl>(
                    u, size, machInst, vd, vn, vm);
          case 0x9:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlal>(
                        size, machInst, vd, vn, vm);
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmlsl>(
                        size, machInst, vd, vn, vm);
            }
          case 0xc:
            return decodeNeonUSThreeUSReg<Vmull>(
                    u, size, machInst, vd, vn, vm);
          case 0xd:
            if (u) {
                return new Unknown(machInst);
            } else {
                return decodeNeonSThreeUSReg<Vqdmull>(
                        size, machInst, vd, vn, vm);
            }
          case 0xe:
            return decodeNeonUThreeUSReg<Vmullp>(
                    size, machInst, vd, vn, vm);
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegScalar(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 11, 8);
        const unsigned size = bits(machInst, 21, 20);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vn =
            (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                               (bits(machInst, 7) << 4)));
        const IntRegIndex vm = (size == 2) ?
            (IntRegIndex)(2 * bits(machInst, 3, 0)) :
            (IntRegIndex)(2 * bits(machInst, 2, 0));
        const unsigned index = (size == 2) ? (unsigned)bits(machInst, 5) :
            (bits(machInst, 3) | (bits(machInst, 5) << 1));
        switch (a) {
          case 0x0:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlasQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlasD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlasD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x1:
            if (u)
                return new VmlasQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlasDFp<float>(machInst, vd, vn, vm, index);
          case 0x4:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmlssQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmlssD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmlssD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x5:
            if (u)
                return new VmlssQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmlssDFp<float>(machInst, vd, vn, vm, index);
          case 0x2:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlals<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x6:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmlsls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x3:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlals<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlals<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x7:
            if (u) {
                return new Unknown(machInst);
            } else {
                switch (size) {
                  case 1:
                    return new Vqdmlsls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vqdmlsls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x8:
            if (u) {
                switch (size) {
                  case 1:
                    return new VmulsQ<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsQ<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VmulsD<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new VmulsD<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0x9:
            if (u)
                return new VmulsQFp<float>(machInst, vd, vn, vm, index);
            else
                return new VmulsDFp<float>(machInst, vd, vn, vm, index);
          case 0xa:
            if (u) {
                switch (size) {
                  case 1:
                    return new Vmulls<uint16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<uint32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new Vmulls<int16_t>(machInst, vd, vn, vm, index);
                  case 2:
                    return new Vmulls<int32_t>(machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xb:
            if (u) {
                return new Unknown(machInst);
            } else {
                if (u) {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<uint16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<uint32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (size) {
                      case 1:
                        return new Vqdmulls<int16_t>(
                                machInst, vd, vn, vm, index);
                      case 2:
                        return new Vqdmulls<int32_t>(
                                machInst, vd, vn, vm, index);
                      default:
                        return new Unknown(machInst);
                    }
                }
            }
          case 0xc:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
          case 0xd:
            if (u) {
                switch (size) {
                  case 1:
                    return new VqrdmulhsQ<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsQ<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            } else {
                switch (size) {
                  case 1:
                    return new VqrdmulhsD<int16_t>(
                            machInst, vd, vn, vm, index);
                  case 2:
                    return new VqrdmulhsD<int32_t>(
                            machInst, vd, vn, vm, index);
                  default:
                    return new Unknown(machInst);
                }
            }
        }
        return new Unknown(machInst);
    }
    static StaticInstPtr
    decodeNeonTwoRegMisc(ExtMachInst machInst)
    {
        const uint32_t a = bits(machInst, 17, 16);
        const uint32_t b = bits(machInst, 10, 6);
        const bool q = bits(machInst, 6);
        const IntRegIndex vd =
            (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                               (bits(machInst, 22) << 4)));
        const IntRegIndex vm =
            (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                               (bits(machInst, 5) << 4)));
        const unsigned size = bits(machInst, 19, 18);
        switch (a) {
          case 0x0:
            switch (bits(b, 4, 1)) {
              case 0x0:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev64Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev64Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint16_t>(machInst, vd, vm);
                    }
                  case 2:
                    if (q) {
                        return new NVrev64Q<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrev64D<uint32_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x1:
                switch (size) {
                  case 0:
                    if (q) {
                        return new NVrev32Q<uint8_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint8_t>(machInst, vd, vm);
                    }
                  case 1:
                    if (q) {
                        return new NVrev32Q<uint16_t>(machInst, vd, vm);
                    } else {
                        return new NVrev32D<uint16_t>(machInst, vd, vm);
                    }
                  default:
                    return new Unknown(machInst);
                }
              case 0x2:
                if (size != 0) {
                    return new Unknown(machInst);
                } else if (q) {
                    return new NVrev16Q<uint8_t>(machInst, vd, vm);
                } else {
                    return new NVrev16D<uint8_t>(machInst, vd, vm);
                }
              case 0x4:
                return decodeNeonSTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x5:
                return decodeNeonUTwoMiscSReg<NVpaddlD, NVpaddlQ>(
                        q, size, machInst, vd, vm);
              case 0x8:
                return decodeNeonSTwoMiscReg<NVclsD, NVclsQ>(
                        q, size, machInst, vd, vm);
              case 0x9:
                return decodeNeonSTwoMiscReg<NVclzD, NVclzQ>(
                        q, size, machInst, vd, vm);
              case 0xa:
                return decodeNeonUTwoMiscReg<NVcntD, NVcntQ>(
                        q, size, machInst, vd, vm);
              case 0xb:
                if (q)
                    return new NVmvnQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVmvnD<uint64_t>(machInst, vd, vm);
              case 0xc:
                return decodeNeonSTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xd:
                return decodeNeonUTwoMiscSReg<NVpadalD, NVpadalQ>(
                        q, size, machInst, vd, vm);
              case 0xe:
                return decodeNeonSTwoMiscReg<NVqabsD, NVqabsQ>(
                        q, size, machInst, vd, vm);
              case 0xf:
                return decodeNeonSTwoMiscReg<NVqnegD, NVqnegQ>(
                        q, size, machInst, vd, vm);
              default:
                return new Unknown(machInst);
            }
          case 0x1:
            switch (bits(b, 3, 1)) {
              case 0x0:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgtQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgtDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgtD, NVcgtQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x1:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcgeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcgeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcgeD, NVcgeQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x2:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVceqQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVceqDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVceqD, NVceqQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x3:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcleQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcleDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcleD, NVcleQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x4:
                if (bits(b, 4)) {
                    if (q) {
                        return new NVcltQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVcltDFp<float>(machInst, vd, vm);
                    }
                } else {
                    return decodeNeonSTwoMiscReg<NVcltD, NVcltQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x6:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVabsQFp<float>(machInst, vd, vm);
                    else
                        return new NVabsDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVabsD, NVabsQ>(
                            q, size, machInst, vd, vm);
                }
              case 0x7:
                if (bits(machInst, 10)) {
                    if (q)
                        return new NVnegQFp<float>(machInst, vd, vm);
                    else
                        return new NVnegDFp<float>(machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscReg<NVnegD, NVnegQ>(
                            q, size, machInst, vd, vm);
                }
            }
          case 0x2:
            switch (bits(b, 4, 1)) {
              case 0x0:
                if (q)
                    return new NVswpQ<uint64_t>(machInst, vd, vm);
                else
                    return new NVswpD<uint64_t>(machInst, vd, vm);
              case 0x1:
                return decodeNeonUTwoMiscSReg<NVtrnD, NVtrnQ>(
                        q, size, machInst, vd, vm);
              case 0x2:
                return decodeNeonUTwoMiscReg<NVuzpD, NVuzpQ>(
                        q, size, machInst, vd, vm);
              case 0x3:
                return decodeNeonUTwoMiscReg<NVzipD, NVzipQ>(
                        q, size, machInst, vd, vm);
              case 0x4:
                if (b == 0x8) {
                    return decodeNeonUTwoMiscUSReg<NVmovn>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovuns>(
                            size, machInst, vd, vm);
                }
              case 0x5:
                if (q) {
                    return decodeNeonUTwoMiscUSReg<NVqmovun>(
                            size, machInst, vd, vm);
                } else {
                    return decodeNeonSTwoMiscUSReg<NVqmovn>(
                            size, machInst, vd, vm);
                }
              case 0x6:
                if (b == 0xc) {
                    return decodeNeonSTwoShiftUSReg<NVshll>(
                            size, machInst, vd, vm, 8 << size);
                } else {
                    return new Unknown(machInst);
                }
              case 0xc:
              case 0xe:
                if (b == 0x18) {
                    if (size != 1 || (vm % 2))
                        return new Unknown(machInst);
                    return new NVcvts2h<uint16_t>(machInst, vd, vm);
                } else if (b == 0x1c) {
                    if (size != 1 || (vd % 2))
                        return new Unknown(machInst);
                    return new NVcvth2s<uint16_t>(machInst, vd, vm);
                } else {
                    return new Unknown(machInst);
                }
              default:
                return new Unknown(machInst);
            }
          case 0x3:
            if (bits(b, 4, 3) == 0x3) {
                if ((q && (vd % 2 || vm % 2)) || size != 2) {
                    return new Unknown(machInst);
                } else {
                    if (bits(b, 2)) {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvt2ufxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2ufxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvt2sfxQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvt2sfxD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    } else {
                        if (bits(b, 1)) {
                            if (q) {
                                return new NVcvtu2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvtu2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        } else {
                            if (q) {
                                return new NVcvts2fpQ<float>(
                                        machInst, vd, vm, 0);
                            } else {
                                return new NVcvts2fpD<float>(
                                        machInst, vd, vm, 0);
                            }
                        }
                    }
                }
            } else if ((b & 0x1a) == 0x10) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrecpeQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrecpeDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrecpeQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrecpeD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else if ((b & 0x1a) == 0x12) {
                if (bits(b, 2)) {
                    if (q) {
                        return new NVrsqrteQFp<float>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteDFp<float>(machInst, vd, vm);
                    }
                } else {
                    if (q) {
                        return new NVrsqrteQ<uint32_t>(machInst, vd, vm);
                    } else {
                        return new NVrsqrteD<uint32_t>(machInst, vd, vm);
                    }
                }
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    StaticInstPtr
    decodeNeonData(ExtMachInst machInst)
    {
        const bool u = THUMB ? bits(machInst, 28) : bits(machInst, 24);
        const uint32_t a = bits(machInst, 23, 19);
        const uint32_t b = bits(machInst, 11, 8);
        const uint32_t c = bits(machInst, 7, 4);
        if (bits(a, 4) == 0) {
            return decodeNeonThreeRegistersSameLength(machInst);
        } else if ((c & 0x9) == 1) {
            if ((a & 0x7) == 0) {
                return decodeNeonOneRegModImm(machInst);
            } else {
                return decodeNeonTwoRegAndShift(machInst);
            }
        } else if ((c & 0x9) == 9) {
            return decodeNeonTwoRegAndShift(machInst);
        } else if (bits(a, 2, 1) != 0x3) {
            if ((c & 0x5) == 0) {
                return decodeNeonThreeRegDiffLengths(machInst);
            } else if ((c & 0x5) == 4) {
                return decodeNeonTwoRegScalar(machInst);
            }
        } else if ((a & 0x16) == 0x16) {
            const IntRegIndex vd =
                (IntRegIndex)(2 * (bits(machInst, 15, 12) |
                                   (bits(machInst, 22) << 4)));
            const IntRegIndex vn =
                (IntRegIndex)(2 * (bits(machInst, 19, 16) |
                                   (bits(machInst, 7) << 4)));
            const IntRegIndex vm =
                (IntRegIndex)(2 * (bits(machInst, 3, 0) |
                                   (bits(machInst, 5) << 4)));
            if (!u) {
                if (bits(c, 0) == 0) {
                    unsigned imm4 = bits(machInst, 11, 8);
                    bool q = bits(machInst, 6);
                    if (imm4 >= 16 && !q)
                        return new Unknown(machInst);
                    if (q) {
                        return new NVextQ<uint8_t>(machInst, vd, vn, vm, imm4);
                    } else {
                        return new NVextD<uint8_t>(machInst, vd, vn, vm, imm4);
                    }
                }
            } else if (bits(b, 3) == 0 && bits(c, 0) == 0) {
                return decodeNeonTwoRegMisc(machInst);
            } else if (bits(b, 3, 2) == 0x2 && bits(c, 0) == 0) {
                unsigned length = bits(machInst, 9, 8) + 1;
                if ((uint32_t)vn / 2 + length > 32)
                    return new Unknown(machInst);
                if (bits(machInst, 6) == 0) {
                    switch (length) {
                      case 1:
                        return new NVtbl1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbl2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbl3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbl4(machInst, vd, vn, vm);
                    }
                } else {
                    switch (length) {
                      case 1:
                        return new NVtbx1(machInst, vd, vn, vm);
                      case 2:
                        return new NVtbx2(machInst, vd, vn, vm);
                      case 3:
                        return new NVtbx3(machInst, vd, vn, vm);
                      case 4:
                        return new NVtbx4(machInst, vd, vn, vm);
                    }
                }
            } else if (b == 0xc && (c & 0x9) == 0) {
                unsigned imm4 = bits(machInst, 19, 16);
                if (bits(imm4, 2, 0) == 0)
                    return new Unknown(machInst);
                unsigned size = 0;
                while ((imm4 & 0x1) == 0) {
                    size++;
                    imm4 >>= 1;
                }
                unsigned index = imm4 >> 1;
                const bool q = bits(machInst, 6);
                return decodeNeonUTwoShiftSReg<NVdupD, NVdupQ>(
                        q, size, machInst, vd, vm, index);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeExtensionRegLoadStore(ExtMachInst machInst)
    {
        const uint32_t opcode = bits(machInst, 24, 20);
        const uint32_t offset = bits(machInst, 7, 0);
        const bool single = (bits(machInst, 8) == 0);
        const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
        RegIndex vd;
        if (single) {
            vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                      bits(machInst, 22));
        } else {
            vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                      (bits(machInst, 22) << 5));
        }
        switch (bits(opcode, 4, 3)) {
          case 0x0:
            if (bits(opcode, 4, 1) == 0x2 &&
                    !(machInst.thumb == 1 && bits(machInst, 28) == 1) &&
                    !(machInst.thumb == 0 && machInst.condCode == 0xf)) {
                if ((bits(machInst, 7, 4) & 0xd) != 1) {
                    break;
                }
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                const IntRegIndex rt2 =
                    (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                const bool op = bits(machInst, 20);
                uint32_t vm;
                if (single) {
                    vm = (bits(machInst, 3, 0) << 1) | bits(machInst, 5);
                } else {
                    vm = (bits(machInst, 3, 0) << 1) |
                         (bits(machInst, 5) << 5);
                }
                if (op) {
                    return new Vmov2Core2Reg(machInst, rt, rt2,
                                             (IntRegIndex)vm);
                } else {
                    return new Vmov2Reg2Core(machInst, (IntRegIndex)vm,
                                             rt, rt2);
                }
            }
            break;
          case 0x1:
            {
                if (offset == 0 || vd + offset/2 > NumFloatArchRegs) {
                    break;
                }
                switch (bits(opcode, 1, 0)) {
                  case 0x0:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, false, offset);
                  case 0x1:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, false, true, offset);
                  case 0x2:
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, false, offset);
                  case 0x3:
                    // If rn == sp, then this is called vpop.
                    return new VLdmStm(machInst, rn, vd, single,
                                       true, true, true, offset);
                }
            }
          case 0x2:
            if (bits(opcode, 1, 0) == 0x2) {
                // If rn == sp, then this is called vpush.
                return new VLdmStm(machInst, rn, vd, single,
                                   false, true, false, offset);
            } else if (bits(opcode, 1, 0) == 0x3) {
                return new VLdmStm(machInst, rn, vd, single,
                                   false, true, true, offset);
            }
            // Fall through on purpose
          case 0x3:
            const bool up = (bits(machInst, 23) == 1);
            const uint32_t imm = bits(machInst, 7, 0) << 2;
            if (single) {
                vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                          (bits(machInst, 22)));
            } else {
                vd = (RegIndex)(uint32_t)((bits(machInst, 15, 12) << 1) |
                                          (bits(machInst, 22) << 5));
            }
            if (bits(opcode, 1, 0) == 0x0) {
                if (single) {
                    if (up) {
                        return new VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            } else if (bits(opcode, 1, 0) == 0x1) {
                if (single) {
                    if (up) {
                        return new VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, vd, rn, up, imm);
                    }
                } else {
                    if (up) {
                        return new VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                               rn, up, imm);
                    } else {
                        return new VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, vd, vd + 1,
                                              rn, up, imm);
                    }
                }
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeShortFpTransfer(ExtMachInst machInst)
    {
        const uint32_t l = bits(machInst, 20);
        const uint32_t c = bits(machInst, 8);
        const uint32_t a = bits(machInst, 23, 21);
        const uint32_t b = bits(machInst, 6, 5);
        if ((machInst.thumb == 1 && bits(machInst, 28) == 1) ||
            (machInst.thumb == 0 && machInst.condCode == 0xf)) {
            return new Unknown(machInst);
        }
        if (l == 0 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (IntRegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vn, rt);
                }
            } else if (a == 0x7) {
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t specReg = bits(machInst, 19, 16);
                switch (specReg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (specReg == MISCREG_FPSCR) {
                    return new VmsrFpscr(machInst, (IntRegIndex)specReg, rt);
                } else {
                    return new Vmsr(machInst, (IntRegIndex)specReg, rt);
                }
            }
        } else if (l == 0 && c == 1) {
            if (bits(a, 2) == 0) {
                uint32_t vd = (bits(machInst, 7) << 5) |
                              (bits(machInst, 19, 16) << 1);
                // Handle accessing each single precision half of the vector.
                vd += bits(machInst, 21);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 22) == 1) {
                    return new VmovCoreRegB(machInst, (IntRegIndex)vd,
                                            rt, bits(machInst, 6, 5));
                } else if (bits(machInst, 5) == 1) {
                    return new VmovCoreRegH(machInst, (IntRegIndex)vd,
                                            rt, bits(machInst, 6));
                } else if (bits(machInst, 6) == 0) {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vd, rt);
                } else {
                    return new Unknown(machInst);
                }
            } else if (bits(b, 1) == 0) {
                bool q = bits(machInst, 21);
                unsigned be = (bits(machInst, 22) << 1) | (bits(machInst, 5));
                IntRegIndex vd = (IntRegIndex)(2 * (uint32_t)
                    (bits(machInst, 19, 16) | (bits(machInst, 7) << 4)));
                IntRegIndex rt = (IntRegIndex)(uint32_t)
                    bits(machInst, 15, 12);
                if (q) {
                    switch (be) {
                      case 0:
                        return new NVdupQGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupQGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupQGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                } else {
                    switch (be) {
                      case 0:
                        return new NVdupDGpr<uint32_t>(machInst, vd, rt);
                      case 1:
                        return new NVdupDGpr<uint16_t>(machInst, vd, rt);
                      case 2:
                        return new NVdupDGpr<uint8_t>(machInst, vd, rt);
                      case 3:
                        return new Unknown(machInst);
                    }
                }
            }
        } else if (l == 1 && c == 0) {
            if (a == 0) {
                const uint32_t vn = (bits(machInst, 19, 16) << 1) |
                                    bits(machInst, 7);
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                if (bits(machInst, 20) == 1) {
                    return new VmovRegCoreW(machInst, rt, (IntRegIndex)vn);
                } else {
                    return new VmovCoreRegW(machInst, (IntRegIndex)vn, rt);
                }
            } else if (a == 7) {
                const IntRegIndex rt =
                    (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                uint32_t specReg = bits(machInst, 19, 16);
                switch (specReg) {
                  case 0:
                    specReg = MISCREG_FPSID;
                    break;
                  case 1:
                    specReg = MISCREG_FPSCR;
                    break;
                  case 6:
                    specReg = MISCREG_MVFR1;
                    break;
                  case 7:
                    specReg = MISCREG_MVFR0;
                    break;
                  case 8:
                    specReg = MISCREG_FPEXC;
                    break;
                  default:
                    return new Unknown(machInst);
                }
                if (rt == 0xf) {
                    if (specReg == MISCREG_FPSCR) {
                        return new VmrsApsrFpscr(machInst);
                    } else {
                        return new Unknown(machInst);
                    }
                } else if (specReg == MISCREG_FPSCR) {
                    return new VmrsFpscr(machInst, rt, (IntRegIndex)specReg);
                } else {
                    return new Vmrs(machInst, rt, (IntRegIndex)specReg);
                }
            }
        } else {
            uint32_t vd = (bits(machInst, 7) << 5) |
                          (bits(machInst, 19, 16) << 1);
            // Handle indexing into each single precision half of the vector.
            vd += bits(machInst, 21);
            uint32_t index;
            const IntRegIndex rt =
                (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
            const bool u = (bits(machInst, 23) == 1);
            if (bits(machInst, 22) == 1) {
                index = bits(machInst, 6, 5);
                if (u) {
                    return new VmovRegCoreUB(machInst, rt,
                                             (IntRegIndex)vd, index);
                } else {
                    return new VmovRegCoreSB(machInst, rt,
                                             (IntRegIndex)vd, index);
                }
            } else if (bits(machInst, 5) == 1) {
                index = bits(machInst, 6);
                if (u) {
                    return new VmovRegCoreUH(machInst, rt,
                                             (IntRegIndex)vd, index);
                } else {
                    return new VmovRegCoreSH(machInst, rt,
                                             (IntRegIndex)vd, index);
                }
            } else if (bits(machInst, 6) == 0 && !u) {
                return new VmovRegCoreW(machInst, rt, (IntRegIndex)vd);
            } else {
                return new Unknown(machInst);
            }
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeVfpData(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 20);
        const uint32_t opc2 = bits(machInst, 19, 16);
        const uint32_t opc3 = bits(machInst, 7, 6);
        //const uint32_t opc4 = bits(machInst, 3, 0);
        const bool single = (bits(machInst, 8) == 0);
        // Used to select between vcmp and vcmpe.
        const bool e = (bits(machInst, 7) == 1);
        IntRegIndex vd;
        IntRegIndex vm;
        IntRegIndex vn;
        if (single) {
            vd = (IntRegIndex)(bits(machInst, 22) |
                    (bits(machInst, 15, 12) << 1));
            vm = (IntRegIndex)(bits(machInst, 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (IntRegIndex)(bits(machInst, 7) |
                    (bits(machInst, 19, 16) << 1));
        } else {
            vd = (IntRegIndex)((bits(machInst, 22) << 5) |
                    (bits(machInst, 15, 12) << 1));
            vm = (IntRegIndex)((bits(machInst, 5) << 5) |
                    (bits(machInst, 3, 0) << 1));
            vn = (IntRegIndex)((bits(machInst, 7) << 5) |
                    (bits(machInst, 19, 16) << 1));
        }
        switch (opc1 & 0xb /* 1011 */) {
          case 0x0:
            if (bits(machInst, 6) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x1:
            if (bits(machInst, 6) == 1) {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlaS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlaD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmlsS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmlsD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x2:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VmulD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VnmulS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VnmulD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x3:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VaddS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VaddD>(
                            machInst, vd, vn, vm, true);
                }
            } else {
                if (single) {
                    return decodeVfpRegRegRegOp<VsubS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VsubD>(
                            machInst, vd, vn, vm, true);
                }
            }
          case 0x8:
            if ((opc3 & 0x1) == 0) {
                if (single) {
                    return decodeVfpRegRegRegOp<VdivS>(
                            machInst, vd, vn, vm, false);
                } else {
                    return decodeVfpRegRegRegOp<VdivD>(
                            machInst, vd, vn, vm, true);
                }
            }
            break;
          case 0xb:
            if ((opc3 & 0x1) == 0) {
                const uint32_t baseImm =
                    bits(machInst, 3, 0) | (bits(machInst, 19, 16) << 4);
                if (single) {
                    uint32_t imm = vfp_modified_imm(baseImm, false);
                    return decodeVfpRegImmOp<VmovImmS>(
                            machInst, vd, imm, false);
                } else {
                    uint64_t imm = vfp_modified_imm(baseImm, true);
                    return decodeVfpRegImmOp<VmovImmD>(
                            machInst, vd, imm, true);
                }
            }
            switch (opc2) {
              case 0x0:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VmovRegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VmovRegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VabsS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VabsD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x1:
                if (opc3 == 1) {
                    if (single) {
                        return decodeVfpRegRegOp<VnegS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VnegD>(
                                machInst, vd, vm, true);
                    }
                } else {
                    if (single) {
                        return decodeVfpRegRegOp<VsqrtS>(
                                machInst, vd, vm, false);
                    } else {
                        return decodeVfpRegRegOp<VsqrtD>(
                                machInst, vd, vm, true);
                    }
                }
              case 0x2:
              case 0x3:
                {
                    const bool toHalf = bits(machInst, 16);
                    const bool top = bits(machInst, 7);
                    if (top) {
                        if (toHalf) {
                            return new VcvtFpSFpHT(machInst, vd, vm);
                        } else {
                            return new VcvtFpHTFpS(machInst, vd, vm);
                        }
                    } else {
                        if (toHalf) {
                            return new VcvtFpSFpHB(machInst, vd, vm);
                        } else {
                            return new VcvtFpHBFpS(machInst, vd, vm);
                        }
                    }
                }
              case 0x4:
                if (single) {
                    if (e) {
                        return new VcmpeS(machInst, vd, vm);
                    } else {
                        return new VcmpS(machInst, vd, vm);
                    }
                } else {
                    if (e) {
                        return new VcmpeD(machInst, vd, vm);
                    } else {
                        return new VcmpD(machInst, vd, vm);
                    }
                }
              case 0x5:
                if (single) {
                    if (e) {
                        return new VcmpeZeroS(machInst, vd, 0);
                    } else {
                        return new VcmpZeroS(machInst, vd, 0);
                    }
                } else {
                    if (e) {
                        return new VcmpeZeroD(machInst, vd, 0);
                    } else {
                        return new VcmpZeroD(machInst, vd, 0);
                    }
                }
              case 0x7:
                if (opc3 == 0x3) {
                    if (single) {
                        vd = (IntRegIndex)((bits(machInst, 22) << 5) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSFpD(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpDFpS(machInst, vd, vm);
                    }
                }
                break;
              case 0x8:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtUIntFpS(machInst, vd, vm);
                    } else {
                        vm = (IntRegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtUIntFpD(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtSIntFpS(machInst, vd, vm);
                    } else {
                        vm = (IntRegIndex)(bits(machInst, 5) |
                                (bits(machInst, 3, 0) << 1));
                        return new VcvtSIntFpD(machInst, vd, vm);
                    }
                }
              case 0xa:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtSHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtSHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtSFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xb:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtUHFixedFpS(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtUHFixedFpD(machInst, vd, vd, size);
                        } else {
                            return new VcvtUFixedFpD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xc:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpUIntSR(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpUIntS(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpUIntD(machInst, vd, vm);
                    }
                }
              case 0xd:
                if (bits(machInst, 7) == 0) {
                    if (single) {
                        return new VcvtFpSIntSR(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntDR(machInst, vd, vm);
                    }
                } else {
                    if (single) {
                        return new VcvtFpSIntS(machInst, vd, vm);
                    } else {
                        vd = (IntRegIndex)(bits(machInst, 22) |
                                (bits(machInst, 15, 12) << 1));
                        return new VcvtFpSIntD(machInst, vd, vm);
                    }
                }
              case 0xe:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpSHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpSHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpSFixedD(machInst, vd, vd, size);
                        }
                    }
                }
              case 0xf:
                {
                    const bool half = (bits(machInst, 7) == 0);
                    const uint32_t imm = bits(machInst, 5) |
                                         (bits(machInst, 3, 0) << 1);
                    const uint32_t size =
                        (bits(machInst, 7) == 0 ? 16 : 32) - imm;
                    if (single) {
                        if (half) {
                            return new VcvtFpUHFixedS(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedS(machInst, vd, vd, size);
                        }
                    } else {
                        if (half) {
                            return new VcvtFpUHFixedD(machInst, vd, vd, size);
                        } else {
                            return new VcvtFpUFixedD(machInst, vd, vd, size);
                        }
                    }
                }
            }
            break;
        }
        return new Unknown(machInst);
    }
    
    StaticInstPtr
    decodeMcrMrc14(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex miscReg = decodeCP14Reg(crn, opc1, crm, opc2);
        const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool isRead = bits(machInst, 20);
        switch (miscReg) {
          case MISCREG_NOP:
            return new NopInst(machInst);
          case NUM_MISCREGS:
            return new FailUnimplemented(
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, isRead ? "read" : "write").c_str(),
                    machInst);
          default:
            if (isRead) {
                return new Mrc14(machInst, rt, (IntRegIndex)miscReg);
            } else {
                return new Mcr14(machInst, (IntRegIndex)miscReg, rt);
            }
        }
    }
    
    StaticInstPtr
    decodeMcrMrc15(ExtMachInst machInst)
    {
        const uint32_t opc1 = bits(machInst, 23, 21);
        const uint32_t crn = bits(machInst, 19, 16);
        const uint32_t opc2 = bits(machInst, 7, 5);
        const uint32_t crm = bits(machInst, 3, 0);
        const MiscRegIndex miscReg = decodeCP15Reg(crn, opc1, crm, opc2);
        const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
        const bool isRead = bits(machInst, 20);
        switch (miscReg) {
          case MISCREG_NOP:
            return new NopInst(machInst);
          case NUM_MISCREGS:
            return new FailUnimplemented(
                    csprintf("miscreg crn:%d opc1:%d crm:%d opc2:%d %s unknown",
                    crn, opc1, crm, opc2, isRead ? "read" : "write").c_str(),
                    machInst);
          case MISCREG_DCCISW:
            return new WarnUnimplemented(
                    isRead ? "mrc dccisw" : "mcr dcisw", machInst);
          case MISCREG_DCCIMVAC:
            return new WarnUnimplemented(
                    isRead ? "mrc dccimvac" : "mcr dccimvac", machInst);
          case MISCREG_DCIMVAC:
            return new WarnUnimplemented(
                    isRead ? "mrc dcimvac" : "mcr dcimvac", machInst);
          case MISCREG_DCCMVAC:
            return new FlushPipeInst(
                    isRead ? "mrc dccmvac" : "mcr dccmvac", machInst);
          case MISCREG_DCCMVAU:
            return new WarnUnimplemented(
                    isRead ? "mrc dccmvau" : "mcr dccmvau", machInst);
          case MISCREG_CP15ISB:
            return new Isb(machInst);
          case MISCREG_CP15DSB:
            return new Dsb(machInst);
          case MISCREG_CP15DMB:
            return new Dmb(machInst);
          case MISCREG_ICIALLUIS:
            return new WarnUnimplemented(
                    isRead ? "mrc icialluis" : "mcr icialluis", machInst);
          case MISCREG_ICIMVAU:
            return new WarnUnimplemented(
                    isRead ? "mrc icimvau" : "mcr icimvau", machInst);
          case MISCREG_BPIMVA:
            return new WarnUnimplemented(
                    isRead ? "mrc bpimva" : "mcr bpimva", machInst);
          case MISCREG_BPIALLIS:
            return new WarnUnimplemented(
                    isRead ? "mrc bpiallis" : "mcr bpiallis", machInst);
          case MISCREG_BPIALL:
            return new WarnUnimplemented(
                    isRead ? "mrc bpiall" : "mcr bpiall", machInst);
          case MISCREG_L2LATENCY:
            return new WarnUnimplemented(
                    isRead ? "mrc l2latency" : "mcr l2latency", machInst);
          case MISCREG_CRN15:
            return new WarnUnimplemented(
                    isRead ? "mrc crn15" : "mcr crn15", machInst);
            // Write only.
          case MISCREG_TLBIALLIS:
          case MISCREG_TLBIMVAIS:
          case MISCREG_TLBIASIDIS:
          case MISCREG_TLBIMVAAIS:
          case MISCREG_ITLBIALL:
          case MISCREG_ITLBIMVA:
          case MISCREG_ITLBIASID:
          case MISCREG_DTLBIALL:
          case MISCREG_DTLBIMVA:
          case MISCREG_DTLBIASID:
          case MISCREG_TLBIALL:
          case MISCREG_TLBIMVA:
          case MISCREG_TLBIASID:
          case MISCREG_TLBIMVAA:
            if (isRead) {
                return new Unknown(machInst);
            } else {
                return new Mcr15(machInst, (IntRegIndex)miscReg, rt);
            }
            // Read only in user mode.
          case MISCREG_TPIDRURO:
            if (isRead) {
                return new Mrc15User(machInst, rt, (IntRegIndex)miscReg);
            } else {
                return new Mcr15(machInst, (IntRegIndex)miscReg, rt);
            }
            // Read/write in user mode.
          case MISCREG_TPIDRURW:
            if (isRead) {
                return new Mrc15User(machInst, rt, (IntRegIndex)miscReg);
            } else {
                return new Mcr15User(machInst, (IntRegIndex)miscReg, rt);
            }
            // Read/write, priveleged only.
          default:
            if (miscReg >= MISCREG_CP15_UNIMP_START)
                return new FailUnimplemented(csprintf("%s %s",
                    isRead ? "mrc" : "mcr", miscRegName[miscReg]).c_str(),
                    machInst);
            if (isRead) {
                return new Mrc15(machInst, rt, (IntRegIndex)miscReg);
            } else {
                return new Mcr15(machInst, (IntRegIndex)miscReg, rt);
            }
        }
    }
    
    std::string
    FailUnimplemented::generateDisassembly(Addr pc,
                                           const SymbolTable *symtab) const
    {
        return csprintf("%-10s (unimplemented)", mnemonic);
    }

    std::string
    WarnUnimplemented::generateDisassembly(Addr pc,
                                           const SymbolTable *symtab) const
    {
        return csprintf("%-10s (unimplemented)", mnemonic);
    }

    std::string
    FlushPipeInst::generateDisassembly(Addr pc,
                                   const SymbolTable *symtab) const
    {
        return csprintf("%-10s (pipe flush)", mnemonic);
    }

    std::string
    Breakpoint::generateDisassembly(Addr pc, const SymbolTable *symtab) const
    {
        return csprintf("%-10s (inst 0x%x)", "Breakpoint", machInst);
    }

// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// Breakpoint::bkpt(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))


} // namespace ArmISAInst


StaticInstPtr
ArmISA::Decoder::decodeInst(ArmISA::ExtMachInst machInst)
{
    using namespace ArmISAInst;
  switch (THUMB) {
    
    case 0x0:
      switch (COND_CODE) {
        
        case 0xf:  
          // ArmUnconditional::armUnconditional(([], {}))
          
              {
                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                  const uint32_t op1 = bits(machInst, 27, 20);
                  if (bits(op1, 7) == 0) {
                      const uint32_t op2 = bits(machInst, 7, 4);
                      if (op1 == 0x10) {
                          if (bits((uint32_t)rn, 0) == 1 && op2 == 0) {
                              return new Setend(machInst, bits(machInst, 9));
                          } else if (bits((uint32_t)rn, 0) == 0 && bits(op2, 1) == 0) {
                              const bool enable = bits(machInst, 19, 18) == 0x2;
                              const uint32_t mods = bits(machInst, 4, 0) |
                                                    (bits(machInst, 8, 6) << 5) |
                                                    (bits(machInst, 17) << 8) |
                                                    ((enable ? 1 : 0) << 9);
                              return new Cps(machInst, mods);
                          }
                      } else if (bits(op1, 6, 5) == 0x1) {
                          return decodeNeonData(machInst);
                      } else if (bits(op1, 6, 4) == 0x4) {
                          if (bits(op1, 0) == 0) {
                              return decodeNeonMem(machInst);
                          } else if (bits(op1, 2, 0) == 1) {
                              // Unallocated memory hint
                              return new NopInst(machInst);
                          } else if (bits(op1, 2, 0) == 5) {
                              const bool add = bits(machInst, 23);
                              const uint32_t imm12 = bits(machInst, 11, 0);
                              if (add) {
                                  return new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                          rn, add, imm12);
                              } else {
                                  return new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                          rn, add, imm12);
                              }
                          }
                      } else if (bits(op1, 6, 4) == 0x5) {
                          if (bits(op1, 1, 0) == 0x1) {
                              const bool add = bits(machInst, 23);
                              const bool pldw = bits(machInst, 22);
                              const uint32_t imm12 = bits(machInst, 11, 0);
                              if (pldw) {
                                  if (add) {
                                      return new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                               rn, add, imm12);
                                  } else {
                                      return new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                               rn, add, imm12);
                                  }
                              } else {
                                  if (add) {
                                      return new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                              rn, add, imm12);
                                  } else {
                                      return new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                              rn, add, imm12);
                                  }
                              }
                          } else if (op1 == 0x57) {
                              switch (op2) {
                                case 0x1:
                                  return new Clrex(machInst);
                                case 0x4:
                                  return new Dsb(machInst);
                                case 0x5:
                                  return new Dmb(machInst);
                                case 0x6:
                                  return new Isb(machInst);
                              }
                          }
                      } else if (bits(op2, 0) == 0) {
                          switch (op1 & 0xf7) {
                            case 0x61:
                              // Unallocated memory hint
                              return new NopInst(machInst);
                            case 0x65:
                              {
                                  const uint32_t imm5 = bits(machInst, 11, 7);
                                  const uint32_t type = bits(machInst, 6, 5);
                                  const bool add = bits(machInst, 23);
                                  const IntRegIndex rm =
                                      (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  if (add) {
                                      return new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO, rn,
                                                              add, imm5, type, rm);
                                  } else {
                                      return new PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO, rn,
                                                              add, imm5, type, rm);
                                  }
                              }
                            case 0x71:
                            case 0x75:
                              {
                                  const uint32_t imm5 = bits(machInst, 11, 7);
                                  const uint32_t type = bits(machInst, 6, 5);
                                  const bool add = bits(machInst, 23);
                                  const bool pldw = bits(machInst, 22);
                                  const IntRegIndex rm =
                                      (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  if (pldw) {
                                      if (add) {
                                          return new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                   rn, add, imm5,
                                                                   type, rm);
                                      } else {
                                          return new PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                   rn, add, imm5,
                                                                   type, rm);
                                      }
                                  } else {
                                      if (add) {
                                          return new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                  rn, add, imm5,
                                                                  type, rm);
                                      } else {
                                          return new PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                  rn, add, imm5,
                                                                  type, rm);
                                      }
                                  }
                              }
                          }
                      }
                  } else {
                      switch (bits(machInst, 26, 25)) {
                        case 0x0:
                          {
                              const uint32_t val = ((machInst >> 20) & 0x5);
                              if (val == 0x4) {
                                  const uint32_t mode = bits(machInst, 4, 0);
                                  if (badMode((OperatingMode)mode))
                                      return new Unknown(machInst);
                                  switch (bits(machInst, 24, 21)) {
                                    case 0x2:
                                      return new SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8(machInst, mode,
                                              SrsOp::DecrementAfter, false);
                                    case 0x3:
                                      return new SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8(machInst, mode,
                                              SrsOp::DecrementAfter, true);
                                    case 0x6:
                                      return new SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(machInst, mode,
                                              SrsOp::IncrementAfter, false);
                                    case 0x7:
                                      return new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(machInst, mode,
                                              SrsOp::IncrementAfter, true);
                                    case 0xa:
                                      return new SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(machInst, mode,
                                              SrsOp::DecrementBefore, false);
                                    case 0xb:
                                      return new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(machInst, mode,
                                              SrsOp::DecrementBefore, true);
                                    case 0xe:
                                      return new SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8(machInst, mode,
                                              SrsOp::IncrementBefore, false);
                                    case 0xf:
                                      return new SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8(machInst, mode,
                                              SrsOp::IncrementBefore, true);
                                  }
                                  return new Unknown(machInst);
                              } else if (val == 0x1) {
                                  switch (bits(machInst, 24, 21)) {
                                    case 0x0:
                                      return new RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8(machInst, rn,
                                              RfeOp::DecrementAfter, false);
                                    case 0x1:
                                      return new RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8(machInst, rn,
                                              RfeOp::DecrementAfter, true);
                                    case 0x4:
                                      return new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(machInst, rn,
                                              RfeOp::IncrementAfter, false);
                                    case 0x5:
                                      return new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(machInst, rn,
                                              RfeOp::IncrementAfter, true);
                                    case 0x8:
                                      return new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(machInst, rn,
                                              RfeOp::DecrementBefore, false);
                                    case 0x9:
                                      return new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(machInst, rn,
                                              RfeOp::DecrementBefore, true);
                                    case 0xc:
                                      return new RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8(machInst, rn,
                                              RfeOp::IncrementBefore, false);
                                    case 0xd:
                                      return new RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8(machInst, rn,
                                              RfeOp::IncrementBefore, true);
                                  }
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                        case 0x1:
                          {
                              const uint32_t imm =
                                  (sext<26>(bits(machInst, 23, 0) << 2)) |
                                  (bits(machInst, 24) << 1);
                              return new BlxImm(machInst, imm, COND_UC);
                          }
                        case 0x2:
                          if (bits(op1, 4, 0) != 0) {
                              if (CPNUM == 0xa || CPNUM == 0xb) {
                                  return decodeExtensionRegLoadStore(machInst);
                              }
                              if (bits(op1, 0) == 1) {
                                  if (rn == INTREG_PC) {
                                      if (bits(op1, 4, 3) != 0x0) {
                                          return new WarnUnimplemented(
                                                  "ldc, ldc2 (literal)", machInst);
                                      }
                                  } else {
                                      if (op1 == 0xC3 || op1 == 0xC7) {
                                          return new WarnUnimplemented(
                                                  "ldc, ldc2 (immediate)", machInst);
                                      }
                                  }
                                  if (op1 == 0xC5) {
                                      return new WarnUnimplemented(
                                              "mrrc, mrrc2", machInst);
                                  }
                              } else {
                                  if (bits(op1, 4, 3) != 0 || bits(op1, 1) == 1) {
                                      return new WarnUnimplemented(
                                              "stc, stc2", machInst);
                                  } else if (op1 == 0xC4) {
                                      return new WarnUnimplemented(
                                              "mcrr, mcrrc", machInst);
                                  }
                              }
                          }
                          break;
                        case 0x3:
                          if (bits(op1, 4) == 0) {
                              if (CPNUM == 0xa || CPNUM == 0xb) {
                                  return decodeShortFpTransfer(machInst);
                              } else if (CPNUM == 0xe) {
                                  return decodeMcrMrc14(machInst);
                              } else if (CPNUM == 0xf) {
                                  return decodeMcrMrc15(machInst);
                              }
                              const bool op = bits(machInst, 4);
                              if (op) {
                                  if (bits(op1, 0)) {
                                      return new WarnUnimplemented(
                                              "mrc, mrc2", machInst);
                                  } else {
                                      return new WarnUnimplemented(
                                              "mcr, mcr2", machInst);
                                  }
                              } else {
                                  return new WarnUnimplemented("cdp, cdp2", machInst);
                              }
                          }
                          break;
                      }
                  }
                  return new Unknown(machInst);
              }
              break;
        
        default:
          switch (ENCODING) {
            
            case 0x0:
              switch (SEVEN_AND_FOUR) {
                
                case 0x1:
                  switch (MISC_OPCODE) {
                    
                    case 0x9:
                      switch (PREPOST) {
                        
                        case 0x0:  
                          // ArmMultAndMultAcc::armMultAndMultAcc(([], {}))
                          
                              {
                                  // The manual defines this field as 23-20, but bit 20 is usually
                                  // ignored.
                                  const uint32_t op = bits(machInst, 23, 21);
                                  const bool s = bits(machInst, 20);
                                  const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                  const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                          	//const uint32_t imm5 = bits(machInst, 11, 7);
                                  const ArmShiftType type = (ArmShiftType)(uint32_t)bits(machInst, 6, 5);
                                  switch (op) {
                                      case 0x0:
                                        if (s) {
                                            return new MulCc(machInst, rd, rm, rn);
                                        } else {
                          		  uint32_t faults;
                          		  faults=checkFaults();
                          		  if ((faults & 1) == 1){
                                            	return new Sdiv(machInst, rd, rn, rm);
                          		  }else if ((faults & 8) == 8){
                          			return new AddReg(machInst, rd, rn, rm, 0, type);
                          		  }else if ((faults & 64) == 64){
                          			return new RsbReg(machInst, rd, rm, rn, 0, type);
                          		  }else{
                          			return new Mul(machInst, rd, rn, rm);
                          		  }
                                        }
                                      case 0x1:
                                        if (s) {
                                            return new MlaCc(machInst, rd, rn, rm, ra);
                                        } else {
                                            return new Mla(machInst, rd, rn, rm, ra);
                                        }
                                      case 0x2:
                                        return new Umaal(machInst, ra, rd, rn, rm);
                                      case 0x3:
                                        return new Mls(machInst, rd, rn, rm, ra);
                                      case 0x4:
                                        if (s) {
                                            return new UmullCc(machInst, ra, rd, rn, rm);
                                        } else {
                                            return new Umull(machInst, ra, rd, rn, rm);
                                        }
                                      case 0x5:
                                        if (s) {
                                            return new UmlalCc(machInst, ra, rd, rn, rm);
                                        } else {
                                            return new Umlal(machInst, ra, rd, rn, rm);
                                        }
                                      case 0x6:
                                        if (s) {
                                            return new SmullCc(machInst, ra, rd, rn, rm);
                                        } else {
                                            return new Smull(machInst, ra, rd, rn, rm);
                                        }
                                      case 0x7:
                                        if (s) {
                                            return new SmlalCc(machInst, ra, rd, rn, rm);
                                        } else {
                                            return new Smlal(machInst, ra, rd, rn, rm);
                                        }
                                  }
                              }
                              break;
                        
                        case 0x1:  
                          // ArmSyncMem::armSyncMem(([], {}))
                          
                              {
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                  const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const IntRegIndex rt2 = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  switch (PUBWL) {
                                    case 0x10:
                                      return new Swp(machInst, rt, rt2, rn);
                                    case 0x14:
                                      return new Swpb(machInst, rt, rt2, rn);
                                    case 0x18:
                                      return new STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, true, 0);
                                    case 0x19:
                                      return new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, rt, rn, true, 0);
                                    case 0x1a:
                                      return new STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rt2 + 1, rn, true, 0);
                                    case 0x1b:
                                      return new LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt + 1, rn, true, 0);
                                    case 0x1c:
                                      return new STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rt, rt2, rn, true, 0);
                                    case 0x1d:
                                      return new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true, 0);
                                    case 0x1e:
                                      return new STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rt, rt2, rn, true, 0);
                                    case 0x1f:
                                      return new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true, 0);
                                    default:
                                      return new Unknown(machInst);
                                  }
                              }
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    case 0xb: case 0xd: case 0xf:  
                      // AddrMode3::addrMode3(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 24, 20);
                              const uint32_t op2 = bits(machInst, 6, 5);
                              const uint32_t puiw = bits(machInst, 24, 21);
                              const uint32_t imm = IMMED_HI_11_8 << 4 | IMMED_LO_3_0;
                              switch (op2) {
                                case 0x1:
                                  if (op1 & 0x1) {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new LOAD_REG_AN_PY_SN_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new LOAD_REG_AN_PY_SN_UY_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new LOAD_IMM_AN_PY_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x3:
                                  return new LOAD_IMM_AN_PY_SN_UY_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x4:
                                  return new LOAD_REG_AY_PY_SN_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new LOAD_REG_AY_PY_SN_UY_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new LOAD_IMM_AY_PY_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x7:
                                  return new LOAD_IMM_AY_PY_SN_UY_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x8:
                                  return new LOAD_REG_AN_PN_SN_UN_WN_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new LOAD_REG_AN_PN_SN_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xb:
                                  return new LOAD_IMM_AN_PN_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xc:
                                  return new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new LOAD_REG_AY_PN_SN_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0xf:
                                  return new LOAD_IMM_AY_PN_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  } else {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new STORE_REG_AN_PY_SN_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new STORE_REG_AN_PY_SN_UY_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new STORE_IMM_AN_PY_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x3:
                                  return new STORE_IMM_AN_PY_SN_UY_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x4:
                                  return new STORE_REG_AY_PY_SN_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new STORE_REG_AY_PY_SN_UY_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new STORE_IMM_AY_PY_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x7:
                                  return new STORE_IMM_AY_PY_SN_UY_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x8:
                                  return new STORE_REG_AN_PN_SN_UN_WN_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new STORE_REG_AN_PN_SN_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new STORE_IMM_AN_PN_SN_UN_WN_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xb:
                                  return new STORE_IMM_AN_PN_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xc:
                                  return new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new STORE_REG_AY_PN_SN_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0xf:
                                  return new STORE_IMM_AY_PN_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  }
                                case 0x2:
                                  if (op1 & 0x1) {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new LOAD_REG_AN_PY_SY_UN_WY_SZ1(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new LOAD_REG_AN_PY_SY_UY_WY_SZ1(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new LOAD_IMM_AN_PY_SY_UN_WY_SZ1(machInst, RT, RN, false, imm);
                      
                                case 0x3:
                                  return new LOAD_IMM_AN_PY_SY_UY_WY_SZ1(machInst, RT, RN, false, imm);
                      
                                case 0x4:
                                  return new LOAD_REG_AY_PY_SY_UN_WY_SZ1(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new LOAD_REG_AY_PY_SY_UY_WY_SZ1(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new LOAD_IMM_AY_PY_SY_UN_WY_SZ1(machInst, RT, RN, true, imm);
                      
                                case 0x7:
                                  return new LOAD_IMM_AY_PY_SY_UY_WY_SZ1(machInst, RT, RN, true, imm);
                      
                                case 0x8:
                                  return new LOAD_REG_AN_PN_SY_UN_WN_SZ1(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new LOAD_REG_AN_PN_SY_UN_WY_SZ1(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, RT, RN, false, imm);
                      
                                case 0xb:
                                  return new LOAD_IMM_AN_PN_SY_UN_WY_SZ1(machInst, RT, RN, false, imm);
                      
                                case 0xc:
                                  return new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new LOAD_REG_AY_PN_SY_UN_WY_SZ1(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, RT, RN, true, imm);
                      
                                case 0xf:
                                  return new LOAD_IMM_AY_PN_SY_UN_WY_SZ1(machInst, RT, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  } else if ((RT % 2) == 0) {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new LOAD_REGD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new LOAD_REGD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0x3:
                                  return new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0x4:
                                  return new LOAD_REGD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new LOAD_REGD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0x7:
                                  return new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0x8:
                                  return new LOAD_REGD_AN_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new LOAD_REGD_AN_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0xb:
                                  return new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0xc:
                                  return new LOAD_REGD_AY_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new LOAD_REGD_AY_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0xf:
                                  return new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  } else {
                                      return new Unknown(machInst);
                                  }
                                case 0x3:
                                  if (op1 & 0x1) {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new LOAD_REG_AN_PY_SY_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new LOAD_REG_AN_PY_SY_UY_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new LOAD_IMM_AN_PY_SY_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x3:
                                  return new LOAD_IMM_AN_PY_SY_UY_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0x4:
                                  return new LOAD_REG_AY_PY_SY_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new LOAD_REG_AY_PY_SY_UY_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new LOAD_IMM_AY_PY_SY_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x7:
                                  return new LOAD_IMM_AY_PY_SY_UY_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0x8:
                                  return new LOAD_REG_AN_PN_SY_UN_WN_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new LOAD_REG_AN_PN_SY_UN_WY_SZ2(machInst, RT, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xb:
                                  return new LOAD_IMM_AN_PN_SY_UN_WY_SZ2(machInst, RT, RN, false, imm);
                      
                                case 0xc:
                                  return new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new LOAD_REG_AY_PN_SY_UN_WY_SZ2(machInst, RT, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, RT, RN, true, imm);
                      
                                case 0xf:
                                  return new LOAD_IMM_AY_PN_SY_UN_WY_SZ2(machInst, RT, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  } else {
                                      switch (puiw) {
                      
                                case 0x0:
                                  return new STORE_REGD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x1:
                                  return new STORE_REGD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x2:
                                  return new STORE_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0x3:
                                  return new STORE_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0x4:
                                  return new STORE_REGD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0x5:
                                  return new STORE_REGD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0x6:
                                  return new STORE_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0x7:
                                  return new STORE_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0x8:
                                  return new STORE_REGD_AN_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0x9:
                                  return new STORE_REGD_AN_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, 0, LSL, RM);
                      
                                case 0xa:
                                  return new STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0xb:
                                  return new STORE_IMMD_AN_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, false, imm);
                      
                                case 0xc:
                                  return new STORE_REGD_AY_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0xd:
                                  return new STORE_REGD_AY_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, 0, LSL, RM);
                      
                                case 0xe:
                                  return new STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                case 0xf:
                                  return new STORE_IMMD_AY_PN_SN_UN_WY_SZ4(machInst, RT & ~1, RT | 1, RN, true, imm);
                      
                                default:
                                  return new Unknown(machInst);
                              }
                              
                                  }
                                default:
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x0:
                  switch (IS_MISC) {
                    
                    case 0x0:  
                      // ArmDataProcReg::armDataProcReg(([], {}))
                      
                          {
                              const bool immShift = (bits(machInst, 4) == 0);
                              const bool setCc = (bits(machInst, 20) == 1);
                              const uint32_t imm5 = bits(machInst, 11, 7);
                              const ArmShiftType type = (ArmShiftType)(uint32_t)bits(machInst, 6, 5);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)RD;
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)RN;
                              const IntRegIndex rm = (IntRegIndex)(uint32_t)RM;
                              const IntRegIndex rs = (IntRegIndex)(uint32_t)RS;
                              switch (OPCODE) {
                          
                                case 0x0:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new AndsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new AndRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AndReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new AndReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AndReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new AndReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new AndRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new AndRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x1:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new EorsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new EorRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new EorReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new EorReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new EorReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new EorReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new EorRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new EorRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x2:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new SubsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new SubRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new SubReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new SubReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new SubReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new SubReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new SubRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new SubRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x3:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new RsbsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new RsbRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new RsbReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new RsbReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new RsbReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new RsbReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new RsbRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new RsbRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x4:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new AddsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new AddRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AddReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new AddReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AddReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new AddReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new AddRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new AddRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x5:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new AdcsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new AdcRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AdcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new AdcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new AdcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new AdcReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new AdcRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new AdcRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x6:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new SbcsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new SbcRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new SbcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new SbcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new SbcReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new SbcReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new SbcRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new SbcRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x7:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new RscsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new RscRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new RscReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new RscReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new RscReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new RscReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new RscRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new RscRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x8:
                                  if (immShift) {
                                      if (setCc) {
                                          if (INTREG_ZERO == INTREG_PC) {
                                              
                                          } else {
                                              return new TstRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new TstReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rm, rn);		}else{
                                          		return new TstReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, INTREG_ZERO, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new TstReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new TstReg(machInst, INTREG_ZERO, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new TstRegRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new TstRegReg(machInst, INTREG_ZERO,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0x9:
                                  if (immShift) {
                                      if (setCc) {
                                          if (INTREG_ZERO == INTREG_PC) {
                                              
                                          } else {
                                              return new TeqRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new TeqReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rm, rn);		}else{
                                          		return new TeqReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, INTREG_ZERO, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new TeqReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new TeqReg(machInst, INTREG_ZERO, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new TeqRegRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new TeqRegReg(machInst, INTREG_ZERO,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xa:
                                  if (immShift) {
                                      if (setCc) {
                                          if (INTREG_ZERO == INTREG_PC) {
                                              
                                          } else {
                                              return new CmpRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new CmpReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rm, rn);		}else{
                                          		return new CmpReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, INTREG_ZERO, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new CmpReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new CmpReg(machInst, INTREG_ZERO, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new CmpRegRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new CmpRegReg(machInst, INTREG_ZERO,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xb:
                                  if (immShift) {
                                      if (setCc) {
                                          if (INTREG_ZERO == INTREG_PC) {
                                              
                                          } else {
                                              return new CmnRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new CmnReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, INTREG_ZERO, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, INTREG_ZERO, rm, rn);		}else{
                                          		return new CmnReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, INTREG_ZERO, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, INTREG_ZERO, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, INTREG_ZERO, rn, rm);			}else{
                                          		return new CmnReg(machInst, INTREG_ZERO, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new CmnReg(machInst, INTREG_ZERO, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new CmnRegRegCc(machInst, INTREG_ZERO,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new CmnRegReg(machInst, INTREG_ZERO,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xc:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new OrrsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new OrrRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new OrrReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new OrrReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new OrrReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new OrrReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new OrrRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new OrrRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xd:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new MovsRegPclr(machInst, rd,
                                                              INTREG_ZERO, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new MovRegCc(machInst, rd,
                                                                            INTREG_ZERO, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, INTREG_ZERO, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, INTREG_ZERO, rm);			}else{
                                          		return new MovReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, INTREG_ZERO, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, INTREG_ZERO);		}else{
                                          		return new MovReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, INTREG_ZERO, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, INTREG_ZERO, rm);			}else{
                                          		return new MovReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new MovReg(machInst, rd, INTREG_ZERO,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new MovRegRegCc(machInst, rd,
                                                                            INTREG_ZERO, rm, rs, type);
                                      } else {
                                          return new MovRegReg(machInst, rd,
                                                                          INTREG_ZERO, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xe:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new BicsRegPclr(machInst, rd,
                                                              rn, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new BicRegCc(machInst, rd,
                                                                            rn, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new BicReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, rn, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, rn);		}else{
                                          		return new BicReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, rn, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, rn, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, rn, rm);			}else{
                                          		return new BicReg(machInst, rd, rn,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new BicReg(machInst, rd, rn,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new BicRegRegCc(machInst, rd,
                                                                            rn, rm, rs, type);
                                      } else {
                                          return new BicRegReg(machInst, rd,
                                                                          rn, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                case 0xf:
                                  if (immShift) {
                                      if (setCc) {
                                          if (rd == INTREG_PC) {
                                              
                              return new MvnsRegPclr(machInst, rd,
                                                              INTREG_ZERO, rm, imm5,
                                                              type);
                          
                                          } else {
                                              return new MvnRegCc(machInst, rd,
                                                                            INTREG_ZERO, rm, imm5, type);
                                          }
                                      } else {
                      		   if (OPCODE==0x2){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, INTREG_ZERO, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, INTREG_ZERO, rm);			}else{
                                          		return new MvnReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x3){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 4) == 4){
                      				return new AddReg(machInst, rd, INTREG_ZERO, rm, 	imm5, type);	}else if ((faults & 128) == 128){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 256) == 256){
                      				return new Sdiv(machInst, rd, rm, INTREG_ZERO);		}else{
                                          		return new MvnReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else if (OPCODE==0x4){
                      		    	uint32_t faults;
                      		    	faults=checkFaults();
                      		    	if ((faults & 2) == 2){
                      				return new RsbReg(machInst, rd, rm, INTREG_ZERO, 	imm5, type);	}else if ((faults & 16) == 16){
                      				return new Mul(machInst, rd, INTREG_ZERO, rm);
                      			}else if ((faults & 32) == 32){
                      				return new Sdiv(machInst, rd, INTREG_ZERO, rm);			}else{
                                          		return new MvnReg(machInst, rd, INTREG_ZERO,rm, imm5, type);
                      		    	}
                      		    }else{
                      			return new MvnReg(machInst, rd, INTREG_ZERO,
                                                                       rm, imm5, type);
                      		    }
                                      }
                                  } else {
                                      if (setCc) {
                                          return new MvnRegRegCc(machInst, rd,
                                                                            INTREG_ZERO, rm, rs, type);
                                      } else {
                                          return new MvnRegReg(machInst, rd,
                                                                          INTREG_ZERO, rm, rs, type);
                                      }
                                  }
                                  break;
                          
                                default:
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                    
                    case 0x1:
                      switch (OPCODE_7) {
                        
                        case 0x0:
                          switch (MISC_OPCODE) {
                            
                            case 0x0:  
                              // ArmMsrMrs::armMsrMrs(([], {}))
                              
                                  {
                                      const uint8_t byteMask = bits(machInst, 19, 16);
                                      const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const uint32_t opcode = bits(machInst, 24, 21);
                                      const bool useImm = bits(machInst, 25);
                                      const uint32_t unrotated = bits(machInst, 7, 0);
                                      const uint32_t rotation = (bits(machInst, 11, 8) << 1);
                                      const uint32_t imm = rotate_imm(unrotated, rotation);
                                      switch (opcode) {
                                        case 0x8:
                                          return new MrsCpsr(machInst, rd);
                                        case 0x9:
                                          if (useImm) {
                                              return new MsrCpsrImm(machInst, imm, byteMask);
                                          } else {
                                              return new MsrCpsrReg(machInst, rn, byteMask);
                                          }
                                        case 0xa:
                                          return new MrsSpsr(machInst, rd);
                                        case 0xb:
                                          if (useImm) {
                                              return new MsrSpsrImm(machInst, imm, byteMask);
                                          } else {
                                              return new MsrSpsrReg(machInst, rn, byteMask);
                                          }
                                        default:
                                          return new Unknown(machInst);
                                      }
                                  }
                                  break;
                            
                            case 0x1: case 0x2:  
                              // ArmBxClz::armBxClz(([], {}))
                              
                                  {
                                      const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      if (OPCODE == 0x9) {
                                          return new BxReg(machInst, rm,
                                                  (ConditionCode)(uint32_t)machInst.condCode);
                                      } else if (OPCODE == 0xb) {
                                          return new Clz(machInst, rd, rm);
                                      } else {
                                          return new Unknown(machInst);
                                      }
                                  }
                                  break;
                            
                            case 0x3:
                              switch (OPCODE) {
                                
                                case 0x9:  
                                  // ArmBlxReg::armBlxReg(([], {}))
                                  
                                          return new BlxReg(machInst, (IntRegIndex)(uint32_t)bits(machInst, 3, 0),
                                                            (ConditionCode)(uint32_t)machInst.condCode);
                                      break;
                                
                                default:
                                  
                                  // Unknown::unknown(([], {}))
                                  return new Unknown(machInst);
                                  break;
                                }
                              
                            case 0x5:  
                              // ArmSatAddSub::armSatAddSub(([], {}))
                              
                                  {
                                      IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      switch (OPCODE) {
                                        case 0x8:
                                              return new QaddRegCc(machInst, rd, rm, rn, 0, LSL);
                                        case 0x9:
                                          return new QsubRegCc(machInst, rd, rm, rn, 0, LSL);
                                        case 0xa:
                                          	return new QdaddRegCc(machInst, rd, rm, rn, 0, LSL);
                                        case 0xb:
                                          return new QdsubRegCc(machInst, rd, rm, rn, 0, LSL);
                                        default:
                                          return new Unknown(machInst);
                                      }
                                  }
                                  break;
                            
                            case 0x7:  
                              // Breakpoint::bkpt(([], {}))
                              return new Breakpoint(machInst);
                              break;
                            
                            default:
                              
                              // Unknown::unknown(([], {}))
                              return new Unknown(machInst);
                              break;
                            }
                          
                        case 0x1:  
                          // ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))
                          
                              {
                                  const uint32_t op1 = bits(machInst, 22, 21);
                                  const bool op = bits(machInst, 5);
                                  const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                  const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  switch (op1) {
                                    case 0x0:
                                      switch (bits(machInst, 6, 5)) {
                                        case 0x0:
                                          return new SmlabbCc(machInst, rd, rn, rm, ra);
                                        case 0x1:
                                          return new SmlatbCc(machInst, rd, rn, rm, ra);
                                        case 0x2:
                                          return new SmlabtCc(machInst, rd, rn, rm, ra);
                                        case 0x3:
                                          return new SmlattCc(machInst, rd, rn, rm, ra);
                                      }
                                    case 0x1:
                                      if (op) {
                                          if (bits(machInst, 6)) {
                                              return new Smulwt(machInst, rd, rn, rm);
                                          } else {
                                              return new Smulwb(machInst, rd, rn, rm);
                                          }
                                      } else {
                                          if (bits(machInst, 6)) {
                                              return new SmlawtCc(machInst, rd, rn, rm, ra);
                                          } else {
                                              return new SmlawbCc(machInst, rd, rn, rm, ra);
                                          }
                                      }
                                    case 0x2:
                                      switch (bits(machInst, 6, 5)) {
                                        case 0x0:
                                          return new Smlalbb(machInst, ra, rd, rn, rm);
                                        case 0x1:
                                          return new Smlaltb(machInst, ra, rd, rn, rm);
                                        case 0x2:
                                          return new Smlalbt(machInst, ra, rd, rn, rm);
                                        case 0x3:
                                          return new Smlaltt(machInst, ra, rd, rn, rm);
                                      }
                                    case 0x3:
                                      switch (bits(machInst, 6, 5)) {
                                        case 0x0:
                                          return new Smulbb(machInst, rd, rn, rm);
                                        case 0x1:
                                          return new Smultb(machInst, rd, rn, rm);
                                        case 0x2:
                                          return new Smulbt(machInst, rd, rn, rm);
                                        case 0x3:
                                          return new Smultt(machInst, rd, rn, rm);
                                      }
                                  }
                              }
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x1:
              switch (IS_MISC) {
                
                case 0x0:  
                  // ArmDataProcImm::armDataProcImm(([], {}))
                  
                      {
                          const bool setCc = (bits(machInst, 20) == 1);
                          const uint32_t unrotated = bits(machInst, 7, 0);
                          const uint32_t rotation = (bits(machInst, 11, 8) << 1);
                          const bool rotC = (rotation != 0);
                          const uint32_t imm = rotate_imm(unrotated, rotation);
                          const IntRegIndex rd = (IntRegIndex)(uint32_t)RD;
                          const IntRegIndex rn = (IntRegIndex)(uint32_t)RN;
                          switch (OPCODE) {
                      
                            case 0x0:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new AndsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new AndImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new AndImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x1:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new EorsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new EorImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new EorImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x2:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new SubsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new SubImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (true && rn == INTREG_PC) {
                                      
                          return new AdrImm(machInst, rd, (IntRegIndex)0,
                                                       imm, false);
                      
                                  } else {
                                      return new SubImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x3:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new RsbsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new RsbImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new RsbImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x4:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new AddsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new AddImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (true && rn == INTREG_PC) {
                                      
                          return new AdrImm(machInst, rd, (IntRegIndex)1,
                                                       imm, false);
                      
                                  } else {
                                      return new AddImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x5:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new AdcsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new AdcImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new AdcImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x6:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new SbcsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new SbcImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new SbcImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x7:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new RscsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new RscImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new RscImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x8:
                              if (setCc) {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new TstImmCc(machInst, INTREG_ZERO, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new TstImm(machInst, INTREG_ZERO, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0x9:
                              if (setCc) {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new TeqImmCc(machInst, INTREG_ZERO, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new TeqImm(machInst, INTREG_ZERO, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xa:
                              if (setCc) {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new CmpImmCc(machInst, INTREG_ZERO, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new CmpImm(machInst, INTREG_ZERO, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xb:
                              if (setCc) {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new CmnImmCc(machInst, INTREG_ZERO, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new CmnImm(machInst, INTREG_ZERO, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xc:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new OrrsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new OrrImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new OrrImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xd:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new MovsImmPclr(machInst, rd,
                                                          INTREG_ZERO, imm, false);
                      
                                  } else {
                                      return new MovImmCc(machInst, rd, INTREG_ZERO,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new MovImm(machInst, rd, INTREG_ZERO,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xe:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new BicsImmPclr(machInst, rd,
                                                          rn, imm, false);
                      
                                  } else {
                                      return new BicImmCc(machInst, rd, rn,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && rn == INTREG_PC) {
                                      
                                  } else {
                                      return new BicImm(machInst, rd, rn,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            case 0xf:
                              if (setCc) {
                                  if (true && rd == INTREG_PC) {
                                      
                          return new MvnsImmPclr(machInst, rd,
                                                          INTREG_ZERO, imm, false);
                      
                                  } else {
                                      return new MvnImmCc(machInst, rd, INTREG_ZERO,
                                                                     imm, rotC);
                                  }
                              } else {
                                  if (false && INTREG_ZERO == INTREG_PC) {
                                      
                                  } else {
                                      return new MvnImm(machInst, rd, INTREG_ZERO,
                                                                   imm, rotC);
                                  }
                              }
                              break;
                      
                            default:
                              return new Unknown(machInst);
                          }
                      }
                      break;
                
                case 0x1:  
                  // ArmMisc::armMisc(([], {}))
                  
                      {
                          const uint32_t unrotated = bits(machInst, 7, 0);
                          const uint32_t rotation = (bits(machInst, 11, 8) << 1);
                          const uint32_t imm = rotate_imm(unrotated, rotation);
                          const uint8_t byteMask = bits(machInst, 19, 16);
                          switch (OPCODE) {
                            case 0x8:
                              return new MovImm(machInst, (IntRegIndex)(uint32_t)RD,
                                      (IntRegIndex)INTREG_ZERO,
                                      bits(machInst, 11, 0) | (bits(machInst, 19, 16) << 12),
                                      false);
                            case 0x9:
                              if (RN == 0) {
                                  switch (IMM) {
                                    case 0x0:
                                      return new NopInst(machInst);
                                    case 0x1:
                                      return new YieldInst(machInst);
                                    case 0x2:
                                      return new WfeInst(machInst);
                                    case 0x3:
                                      return new WfiInst(machInst);
                                    case 0x4:
                                      return new SevInst(machInst);
                                    default:
                                      return new Unknown(machInst);
                                  }
                              } else {
                                  return new MsrCpsrImm(machInst, imm, byteMask);
                              }
                            case 0xa:
                              {
                                  const uint32_t timm = (bits(machInst, 19, 16) << 12) |
                                                         bits(machInst, 11, 0);
                                  return new MovtImm(machInst, (IntRegIndex)(uint32_t)RD,
                                                     (IntRegIndex)(uint32_t)RD, timm, true);
                              }
                            case 0xb:
                              return new MsrSpsrImm(machInst, imm, byteMask);
                            default:
                              return new Unknown(machInst);
                          }
                      }
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x2:  
              // AddrMode2::addrMode2((['True'], {}))
              switch(PUBWL) {
              
                                      case 0x1:
                                        {return new LOAD_IMM_AN_PY_SN_UN_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x0:
                                        {return new STORE_IMM_AN_PY_SN_UN_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x3:
                                        {return new LOAD_IMM_AN_PY_SN_UY_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x2:
                                        {return new STORE_IMM_AN_PY_SN_UY_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x5:
                                        {return new LOAD_IMM_AN_PY_SN_UN_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x4:
                                        {return new STORE_IMM_AN_PY_SN_UN_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x7:
                                        {return new LOAD_IMM_AN_PY_SN_UY_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x6:
                                        {return new STORE_IMM_AN_PY_SN_UY_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x9:
                                        {return new LOAD_IMM_AY_PY_SN_UN_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x8:
                                        {return new STORE_IMM_AY_PY_SN_UN_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xb:
                                        {return new LOAD_IMM_AY_PY_SN_UY_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xa:
                                        {return new STORE_IMM_AY_PY_SN_UY_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xd:
                                        {return new LOAD_IMM_AY_PY_SN_UN_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xc:
                                        {return new STORE_IMM_AY_PY_SN_UN_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xf:
                                        {return new LOAD_IMM_AY_PY_SN_UY_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0xe:
                                        {return new STORE_IMM_AY_PY_SN_UY_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x11:
                                        {return new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x10:
                                        {return new STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x13:
                                        {return new LOAD_IMM_AN_PN_SN_UN_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x12:
                                        {return new STORE_IMM_AN_PN_SN_UN_WY_SZ4(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x15:
                                        {return new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x14:
                                        {return new STORE_IMM_AN_PN_SN_UN_WN_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x17:
                                        {return new LOAD_IMM_AN_PN_SN_UN_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x16:
                                        {return new STORE_IMM_AN_PN_SN_UN_WY_SZ1(machInst, RD, RN,false, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x19:
                                        {return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x18:
                                        {return new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1b:
                                        {return new LOAD_IMM_AY_PN_SN_UN_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1a:
                                        {return new STORE_IMM_AY_PN_SN_UN_WY_SZ4(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1d:
                                        {return new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1c:
                                        {return new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1f:
                                        {return new LOAD_IMM_AY_PN_SN_UN_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                                      case 0x1e:
                                        {return new STORE_IMM_AY_PN_SN_UN_WY_SZ1(machInst, RD, RN,true, machInst.immed11_0);}
                                        break;
                                  
                      default:
                        return new Unknown(machInst);
                      break;
                  }break;
            
            case 0x3:
              switch (OPCODE_4) {
                
                case 0x0:  
                  // AddrMode2::addrMode2((['False'], {}))
                  switch(PUBWL) {
                  
                                          case 0x1:
                                            {return new LOAD_REG_AN_PY_SN_UN_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x0:
                                            {return new STORE_REG_AN_PY_SN_UN_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x3:
                                            {return new LOAD_REG_AN_PY_SN_UY_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x2:
                                            {return new STORE_REG_AN_PY_SN_UY_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x5:
                                            {return new LOAD_REG_AN_PY_SN_UN_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x4:
                                            {return new STORE_REG_AN_PY_SN_UN_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x7:
                                            {return new LOAD_REG_AN_PY_SN_UY_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x6:
                                            {return new STORE_REG_AN_PY_SN_UY_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x9:
                                            {return new LOAD_REG_AY_PY_SN_UN_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x8:
                                            {return new STORE_REG_AY_PY_SN_UN_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xb:
                                            {return new LOAD_REG_AY_PY_SN_UY_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xa:
                                            {return new STORE_REG_AY_PY_SN_UY_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xd:
                                            {return new LOAD_REG_AY_PY_SN_UN_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xc:
                                            {return new STORE_REG_AY_PY_SN_UN_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xf:
                                            {return new LOAD_REG_AY_PY_SN_UY_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0xe:
                                            {return new STORE_REG_AY_PY_SN_UY_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x11:
                                            {return new LOAD_REG_AN_PN_SN_UN_WN_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x10:
                                            {return new STORE_REG_AN_PN_SN_UN_WN_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x13:
                                            {return new LOAD_REG_AN_PN_SN_UN_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x12:
                                            {return new STORE_REG_AN_PN_SN_UN_WY_SZ4(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x15:
                                            {return new LOAD_REG_AN_PN_SN_UN_WN_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x14:
                                            {return new STORE_REG_AN_PN_SN_UN_WN_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x17:
                                            {return new LOAD_REG_AN_PN_SN_UN_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x16:
                                            {return new STORE_REG_AN_PN_SN_UN_WY_SZ1(machInst, RD, RN, false,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x19:
                                            {return new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x18:
                                            {return new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1b:
                                            {return new LOAD_REG_AY_PN_SN_UN_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1a:
                                            {return new STORE_REG_AY_PN_SN_UN_WY_SZ4(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1d:
                                            {return new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1c:
                                            {return new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1f:
                                            {return new LOAD_REG_AY_PN_SN_UN_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                                          case 0x1e:
                                            {return new STORE_REG_AY_PN_SN_UN_WY_SZ1(machInst, RD, RN, true,machInst.shiftSize,machInst.shift, RM);}
                                            break;
                                      
                          default:
                            return new Unknown(machInst);
                          break;
                      }break;
                
                case 0x1:
                  switch (OPCODE_24_23) {
                    
                    case 0x0:  
                      // ArmParallelAddSubtract::armParallelAddSubtract(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 21, 20);
                              const uint32_t op2 = bits(machInst, 7, 5);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                              const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                              if (bits(machInst, 22) == 0) {
                                  switch (op1) {
                                    case 0x1:
                                      switch (op2) {
                                        case 0x0:
                                          return new Sadd16RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new SasxRegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new SsaxRegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Ssub16RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Sadd8RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Ssub8RegCc(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                    case 0x2:
                                      switch (op2) {
                                        case 0x0:
                                          return new Qadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new QasxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new QsaxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Qsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Qadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Qsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                    case 0x3:
                                      switch (op2) {
                                        case 0x0:
                                          return new Shadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new ShasxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new ShsaxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Shsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Shadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Shsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                  }
                              } else {
                                  switch (op1) {
                                    case 0x1:
                                      switch (op2) {
                                        case 0x0:
                                          return new Uadd16RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new UasxRegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new UsaxRegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Usub16RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Uadd8RegCc(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Usub8RegCc(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                    case 0x2:
                                      switch (op2) {
                                        case 0x0:
                                          return new Uqadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new UqasxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new UqsaxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Uqsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Uqadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Uqsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                    case 0x3:
                                      switch (op2) {
                                        case 0x0:
                                          return new Uhadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x1:
                                          return new UhasxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x2:
                                          return new UhsaxReg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x3:
                                          return new Uhsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x4:
                                          return new Uhadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                        case 0x7:
                                          return new Uhsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                      }
                                      break;
                                  }
                              }
                              return new Unknown(machInst);
                          }
                          break;
                    
                    case 0x1:  
                      // ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 22, 20);
                              const uint32_t a = bits(machInst, 19, 16);
                              const uint32_t op2 = bits(machInst, 7, 5);
                              if (bits(op2, 0) == 0) {
                                  const IntRegIndex rn =
                                      (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  const IntRegIndex rd =
                                      (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const uint32_t satImm = bits(machInst, 20, 16);
                                  const uint32_t imm = bits(machInst, 11, 7);
                                  const ArmShiftType type =
                                      (ArmShiftType)(uint32_t)bits(machInst, 6, 5);
                                  if (op1 == 0) {
                                      if (type) {
                                          return new PkhtbReg(machInst, rd, (IntRegIndex)a,
                                                              rn, imm, type);
                                      } else {
                                          return new PkhbtReg(machInst, rd, (IntRegIndex)a,
                                                              rn, imm, type);
                                      }
                                  } else if (bits(op1, 2, 1) == 1) {
                                      return new Ssat(machInst, rd, satImm + 1, rn, imm, type);
                                  } else if (bits(op1, 2, 1) == 3) {
                                      return new Usat(machInst, rd, satImm, rn, imm, type);
                                  }
                                  return new Unknown(machInst);
                              }
                              switch (op1) {
                                case 0x0:
                                  {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      if (op2 == 0x3) {
                                          const uint32_t rotation =
                                              (uint32_t)bits(machInst, 11, 10) << 3;
                                          if (a == 0xf) {
                                              return new Sxtb16(machInst, rd, rotation, rm);
                                          } else {
                                              return new Sxtab16(machInst, rd, rn, rm, rotation);
                                          }
                                      } else if (op2 == 0x5) {
                                          return new Sel(machInst, rd, rn, rm);
                                      }
                                  }
                                  break;
                                case 0x2:
                                  if (op2 == 0x1) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const uint32_t satImm = bits(machInst, 20, 16);
                                      return new Ssat16(machInst, rd, satImm + 1, rn);
                                  } else if (op2 == 0x3) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const uint32_t rotation =
                                          (uint32_t)bits(machInst, 11, 10) << 3;
                                      if (a == 0xf) {
                                          return new Sxtb(machInst, rd, rotation, rm);
                                      } else {
                                          return new Sxtab(machInst, rd, rn, rm, rotation);
                                      }
                                  }
                                  break;
                                case 0x3:
                                  if (op2 == 0x1) {
                                      IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      return new Rev(machInst, rd, rm);
                                  } else if (op2 == 0x3) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const uint32_t rotation =
                                          (uint32_t)bits(machInst, 11, 10) << 3;
                                      if (a == 0xf) {
                                          return new Sxth(machInst, rd, rotation, rm);
                                      } else {
                                          return new Sxtah(machInst, rd, rn, rm, rotation);
                                      }
                                  } else if (op2 == 0x5) {
                                      IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      return new Rev16(machInst, rd, rm);
                                  }
                                  break;
                                case 0x4:
                                  if (op2 == 0x3) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const uint32_t rotation =
                                          (uint32_t)bits(machInst, 11, 10) << 3;
                                      if (a == 0xf) {
                                          return new Uxtb16(machInst, rd, rotation, rm);
                                      } else {
                                          return new Uxtab16(machInst, rd, rn, rm, rotation);
                                      }
                                  }
                                  break;
                                case 0x6:
                                  if (op2 == 0x1) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const uint32_t satImm = bits(machInst, 20, 16);
                                      return new Usat16(machInst, rd, satImm, rn);
                                  } else if (op2 == 0x3) {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const uint32_t rotation =
                                          (uint32_t)bits(machInst, 11, 10) << 3;
                                      if (a == 0xf) {
                                          return new Uxtb(machInst, rd, rotation, rm);
                                      } else {
                                          return new Uxtab(machInst, rd, rn, rm, rotation);
                                      }
                                  }
                                  break;
                                case 0x7:
                                  {
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      if (op2 == 0x1) {
                                          return new Rbit(machInst, rd, rm);
                                      } else if (op2 == 0x3) {
                                          const uint32_t rotation =
                                              (uint32_t)bits(machInst, 11, 10) << 3;
                                          if (a == 0xf) {
                                              return new Uxth(machInst, rd, rotation, rm);
                                          } else {
                                              return new Uxtah(machInst, rd, rn, rm, rotation);
                                          }
                                      } else if (op2 == 0x5) {
                                          return new Revsh(machInst, rd, rm);
                                      }
                                  }
                                  break;
                              }
                              return new Unknown(machInst);
                          }
                          break;
                    
                    case 0x2:  
                      // ArmSignedMultiplies::armSignedMultiplies(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 22, 20);
                              // This is 7-5 in the manual, but bit 5 is always ignored.
                              const uint32_t op2 = bits(machInst, 7, 6);
                              const bool aIsF = (bits(machInst, 15, 12) == 0xf);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                              const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                              const bool m = bits(machInst, 5);
                              switch (op1) {
                                case 0x0:
                                  if (op2 == 0) {
                                      if (aIsF) {
                                          if (m) {
                                              return new SmuadxCc(machInst, rd, rn, rm);
                                          } else {
                                              return new SmuadCc(machInst, rd, rn, rm);
                                          }
                                      } else {
                                          if (m) {
                                              return new SmladxCc(machInst, rd, rn, rm, ra);
                                          } else {
                                              return new SmladCc(machInst, rd, rn, rm, ra);
                                          }
                                      }
                                  } else if (op2 == 1) {
                                      if (aIsF) {
                                          if (m) {
                                              return new Smusdx(machInst, rd, rn, rm);
                                          } else {
                                              return new Smusd(machInst, rd, rn, rm);
                                          }
                                      } else {
                                          if (m) {
                                              return new SmlsdxCc(machInst, rd, rn, rm, ra);
                                          } else {
                                              return new SmlsdCc(machInst, rd, rn, rm, ra);
                                          }
                                      }
                                  }
                                  break;
                                case 0x1:
                                  if (op2 == 0 && m == 0 && ra == 0xf) {
                      		char faults;
                      		faults=checkFaults();
                      		if (faults=='b'){
                      			return new Mul(machInst, rd, rn, rm);
                      		}else{
                                      	return new Sdiv(machInst, rd, rn, rm);
                      		}
                                  }
                                  break;
                                case 0x3:
                                  if (op2 == 0 && m == 0 && ra == 0xf) {
                                      return new Udiv(machInst, rd, rn, rm);
                                  }
                                  break;
                                case 0x4:
                                  if (op2 == 0) {
                                      if (m) {
                                          return new Smlaldx(machInst, ra, rd, rn, rm);
                                      } else {
                                          return new Smlald(machInst, ra, rd, rn, rm);
                                      }
                                  } else if (op2 == 1) {
                                      if (m) {
                                          return new Smlsldx(machInst, ra, rd, rn, rm);
                                      } else {
                                          return new Smlsld(machInst, ra, rd, rn, rm);
                                      }
                                  }
                                  break;
                                case 0x5:
                                  if (op2 == 0) {
                                      if (aIsF) {
                                          if (m) {
                                              return new Smmulr(machInst, rd, rn, rm);
                                          } else {
                                              return new Smmul(machInst, rd, rn, rm);
                                          }
                                      } else {
                                          if (m) {
                                              return new Smmlar(machInst, rd, rn, rm, ra);
                                          } else {
                                              return new Smmla(machInst, rd, rn, rm, ra);
                                          }
                                      }
                                  } else if (op2 == 0x3) {
                                      if (m) {
                                          return new Smmlsr(machInst, rd, rn, rm, ra);
                                      } else {
                                          return new Smmls(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                  break;
                                default:
                                  break;
                              }
                              return new Unknown(machInst);
                          }
                          break;
                    
                    case 0x3:
                      switch (MEDIA_OPCODE) {
                        
                        case 0x1f:
                          switch (OPC2) {
                            
                            default:  
                              // ArmMiscMedia::armMiscMedia(([], {}))
                              
                                  {
                                      const uint32_t op1 = bits(machInst, 22, 20);
                                      const uint32_t op2 = bits(machInst, 7, 5);
                                      const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                      if (op1 == 0 && op2 == 0) {
                                          const IntRegIndex rd =
                                              (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                          const IntRegIndex rm =
                                              (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                          if (ra == 0xf) {
                                              return new Usad8(machInst, rd, rn, rm);
                                          } else {
                                              return new Usada8(machInst, rd, rn, rm, ra);
                                          }
                                      } else if (bits(op2, 1, 0) == 0x2) {
                                          const uint32_t lsb = bits(machInst, 11, 7);
                                          const uint32_t msb = lsb + bits(machInst, 20, 16);
                                          if (bits(op1, 2, 1) == 0x3) {
                                              return new Ubfx(machInst, ra, rn, lsb, msb);
                                          } else if (bits(op1, 2, 1) == 0x1) {
                                              return new Sbfx(machInst, ra, rn, lsb, msb);
                                          }
                                      } else if (bits(op2, 1, 0) == 0x0 && bits(op1, 2, 1) == 0x2) {
                                          const uint32_t lsb = bits(machInst, 11, 7);
                                          const uint32_t msb = bits(machInst, 20, 16);
                                          if (rn == 0xf) {
                                              return new Bfc(machInst, ra, ra, lsb, msb);
                                          } else {
                                              return new Bfi(machInst, ra, rn, lsb, msb);
                                          }
                                      }
                                      return new Unknown(machInst);
                                  }
                                  break;
                            }
                          
                        default:  
                          // ArmMiscMedia::armMiscMedia(([], {}))
                          
                              {
                                  const uint32_t op1 = bits(machInst, 22, 20);
                                  const uint32_t op2 = bits(machInst, 7, 5);
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  if (op1 == 0 && op2 == 0) {
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                      if (ra == 0xf) {
                                          return new Usad8(machInst, rd, rn, rm);
                                      } else {
                                          return new Usada8(machInst, rd, rn, rm, ra);
                                      }
                                  } else if (bits(op2, 1, 0) == 0x2) {
                                      const uint32_t lsb = bits(machInst, 11, 7);
                                      const uint32_t msb = lsb + bits(machInst, 20, 16);
                                      if (bits(op1, 2, 1) == 0x3) {
                                          return new Ubfx(machInst, ra, rn, lsb, msb);
                                      } else if (bits(op1, 2, 1) == 0x1) {
                                          return new Sbfx(machInst, ra, rn, lsb, msb);
                                      }
                                  } else if (bits(op2, 1, 0) == 0x0 && bits(op1, 2, 1) == 0x2) {
                                      const uint32_t lsb = bits(machInst, 11, 7);
                                      const uint32_t msb = bits(machInst, 20, 16);
                                      if (rn == 0xf) {
                                          return new Bfc(machInst, ra, ra, lsb, msb);
                                      } else {
                                          return new Bfi(machInst, ra, rn, lsb, msb);
                                      }
                                  }
                                  return new Unknown(machInst);
                              }
                              break;
                        }
                      
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x4:  
              // ArmMacroMem::armMacroMem(([], {}))
              
                  return new LdmStm(machInst, (IntRegIndex)(uint32_t)RN, !PREPOST, UP,
                                    PSRUSER, WRITEBACK, LOADOP, machInst.regList);
                  break;
            
            case 0x5:
              switch (OPCODE_24) {
                
                case 0x0:  
                  // ArmBBlxImm::armBBlxImm(([], {}))
                  
                          if (machInst.condCode == 0xF) {
                              int32_t imm = (sext<26>(bits(machInst, 23, 0) << 2)) |
                                            (bits(machInst, 24) << 1);
                              return new BlxImm(machInst, imm, COND_UC);
                          } else {
                              return new B(machInst, sext<26>(bits(machInst, 23, 0) << 2),
                                           (ConditionCode)(uint32_t)machInst.condCode);
                          }
                      break;
                
                case 0x1:  
                  // ArmBlBlxImm::armBlBlxImm(([], {}))
                  
                          if (machInst.condCode == 0xF) {
                              int32_t imm = (sext<26>(bits(machInst, 23, 0) << 2)) |
                                            (bits(machInst, 24) << 1);
                              return new BlxImm(machInst, imm, COND_UC);
                          } else {
                              return new Bl(machInst, sext<26>(bits(machInst, 23, 0) << 2),
                                            (ConditionCode)(uint32_t)machInst.condCode);
                          }
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x6:
              switch (CPNUM) {
                
                case 0xa: case 0xb:  
                  // ExtensionRegLoadStore::extensionRegLoadStore(([], {}))
                  
                      return decodeExtensionRegLoadStore(machInst);
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x7:
              switch (OPCODE_24) {
                
                case 0x0:
                  switch (OPCODE_4) {
                    
                    case 0x0:
                      switch (CPNUM) {
                        
                        case 0xa: case 0xb:  
                          // VfpData::vfpData(([], {}))
                          
                              return decodeVfpData(machInst);
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    case 0x1:
                      switch (CPNUM) {
                        
                        case 0x1:  
                          // M5ops::m5ops(([], {}))
                          
                              {
                                  const uint32_t m5func = bits(machInst, 23, 16);
                                  switch(m5func) {
                                      case 0x00: return new Arm(machInst);
                                      case 0x01: return new Quiesce(machInst);
                                      case 0x02: return new QuiesceNs(machInst);
                                      case 0x03: return new QuiesceCycles(machInst);
                                      case 0x04: return new QuiesceTime(machInst);
                                      case 0x07: return new Rpns(machInst);
                                      case 0x09: return new WakeCPU(machInst);
                                      case 0x10: return new Deprecated_ivlb(machInst);
                                      case 0x11: return new Deprecated_ivle(machInst);
                                      case 0x20: return new Deprecated_exit (machInst);
                                      case 0x21: return new M5exit(machInst);
                                      case 0x22: return new M5fail(machInst);
                                      case 0x31: return new Loadsymbol(machInst);
                                      case 0x30: return new Initparam(machInst);
                                      case 0x40: return new Resetstats(machInst);
                                      case 0x41: return new Dumpstats(machInst);
                                      case 0x42: return new Dumpresetstats(machInst);
                                      case 0x43: return new M5checkpoint(machInst);
                                      case 0x4F: return new M5writefile(machInst);
                                      case 0x50: return new M5readfile(machInst);
                                      case 0x51: return new M5break(machInst);
                                      case 0x52: return new M5switchcpu(machInst);
                                      case 0x53: return new M5addsymbol(machInst);
                                      case 0x54: return new M5panic(machInst);
                                      case 0x5a: return new M5workbegin(machInst);
                                      case 0x5b: return new M5workend(machInst);
                                  }
                             }
                             break;
                        
                        case 0xa: case 0xb:  
                          // ShortFpTransfer::shortFpTransfer(([], {}))
                          
                              return decodeShortFpTransfer(machInst);
                              break;
                        
                        case 0xe:  
                          // McrMrc14::mcrMrc14(([], {}))
                          
                              return decodeMcrMrc14(machInst);
                              break;
                        
                        case 0xf:  
                          // McrMrc15::mcrMrc15(([], {}))
                          
                              return decodeMcrMrc15(machInst);
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x1:  
                  // Svc::svc(([], {}))
                  return new Svc(machInst);break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          }
      
    case 0x1:
      switch (BIGTHUMB) {
        
        case 0x0:
          switch (TOPCODE_15_13) {
            
            case 0x0: case 0x1:  
              // Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))
              
                  {
                      const uint32_t imm5 = bits(machInst, 10, 6);
                      const uint32_t imm3 = bits(machInst, 8, 6);
                      const uint32_t imm8 = bits(machInst, 7, 0);
                      const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 2, 0);
                      const IntRegIndex rd8 = (IntRegIndex)(uint32_t)bits(machInst, 10, 8);
                      const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 5, 3);
                      const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 8, 6);
                      switch (bits(machInst, 13, 11)) {
                        case 0x0: // lsl
                          if (machInst.itstateMask) {
                              return new MovReg(machInst, rd, INTREG_ZERO, rn, imm5, LSL);
                          } else {
                              return new MovRegCc(machInst, rd, INTREG_ZERO, rn, imm5, LSL);
                          }
                        case 0x1: // lsr
                          if (machInst.itstateMask) {
                              return new MovReg(machInst, rd, INTREG_ZERO, rn, imm5, LSR);
                          } else {
                              return new MovRegCc(machInst, rd, INTREG_ZERO, rn, imm5, LSR);
                          }
                        case 0x2: // asr
                          if (machInst.itstateMask) {
                              return new MovReg(machInst, rd, INTREG_ZERO, rn, imm5, ASR);
                          } else {
                              return new MovRegCc(machInst, rd, INTREG_ZERO, rn, imm5, ASR);
                          }
                        case 0x3:
                          switch (bits(machInst, 10, 9)) {
                            case 0x0:
                              if (machInst.itstateMask) {
                                 return new AddReg(machInst, rd, rn, rm, 0, LSL);
                              } else {
                                  return new AddRegCc(machInst, rd, rn, rm, 0, LSL);
                              }
                            case 0x1:
                              if (machInst.itstateMask) {
                                  return new SubReg(machInst, rd, rn, rm, 0, LSL);
                              } else {
                                  return new SubRegCc(machInst, rd, rn, rm, 0, LSL);
                              }
                            case 0x2:
                              if (machInst.itstateMask) {
                                  	return new AddImm(machInst, rd, rn, imm3, true);
                              } else {
                                  return new AddImmCc(machInst, rd, rn, imm3, true);
                              }
                            case 0x3:
                              if (machInst.itstateMask) {
                                  return new SubImm(machInst, rd, rn, imm3, true);
                              } else {
                                  return new SubImmCc(machInst, rd, rn, imm3, true);
                              }
                          }
                        case 0x4:
                          if (machInst.itstateMask) {
                              return new MovImm(machInst, rd8, INTREG_ZERO, imm8, false);
                          } else {
                              return new MovImmCc(machInst, rd8, INTREG_ZERO, imm8, false);
                          }
                        case 0x5:
                          return new CmpImmCc(machInst, INTREG_ZERO, rd8, imm8, true);
                        case 0x6:
                          if (machInst.itstateMask) {
                              return new AddImm(machInst, rd8, rd8, imm8, true);
                          } else {
                              return new AddImmCc(machInst, rd8, rd8, imm8, true);
                          }
                        case 0x7:
                          if (machInst.itstateMask) {
                              return new SubImm(machInst, rd8, rd8, imm8, true);
                          } else {
                              return new SubImmCc(machInst, rd8, rd8, imm8, true);
                          }
                      }
                  }
                  break;
            
            case 0x2:
              switch (TOPCODE_12_10) {
                
                case 0x0:  
                  // Thumb16DataProcessing::thumb16DataProcessing(([], {}))
                  
                      {
                          const IntRegIndex rdn = (IntRegIndex)(uint32_t)bits(machInst, 2, 0);
                          const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 5, 3);
                          switch (bits(machInst, 9, 6)) {
                            case 0x0:
                              if (machInst.itstateMask) {
                                  return new AndReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new AndRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0x1:
                              if (machInst.itstateMask) {
                                  return new EorReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new EorRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0x2: //lsl
                              if (machInst.itstateMask) {
                                  return new MovRegReg(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, LSL);
                              } else {
                                  return new MovRegRegCc(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, LSL);
                              }
                            case 0x3: //lsr
                              if (machInst.itstateMask) {
                                  return new MovRegReg(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, LSR);
                              } else {
                                  return new MovRegRegCc(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, LSR);
                              }
                            case 0x4: //asr
                              if (machInst.itstateMask) {
                                  return new MovRegReg(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, ASR);
                              } else {
                                  return new MovRegRegCc(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, ASR);
                              }
                            case 0x5:
                              if (machInst.itstateMask) {
                                  return new AdcReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new AdcRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0x6:
                              if (machInst.itstateMask) {
                                  return new SbcReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new SbcRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0x7: // ror
                              if (machInst.itstateMask) {
                                  return new MovRegReg(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, ROR);
                              } else {
                                  return new MovRegRegCc(machInst, rdn,
                                          INTREG_ZERO, rdn, rm, ROR);
                              }
                            case 0x8:
                              return new TstRegCc(machInst, INTREG_ZERO, rdn, rm, 0, LSL);
                            case 0x9:
                              if (machInst.itstateMask) {
                                  return new RsbImm(machInst, rdn, rm, 0, true);
                              } else {
                                  return new RsbImmCc(machInst, rdn, rm, 0, true);
                              }
                            case 0xa:
                              return new CmpRegCc(machInst, INTREG_ZERO, rdn, rm, 0, LSL);
                            case 0xb:
                              return new CmnRegCc(machInst, INTREG_ZERO, rdn, rm, 0, LSL);
                            case 0xc:
                              if (machInst.itstateMask) {
                                  return new OrrReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new OrrRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0xd:
                              if (machInst.itstateMask) {
                                  return new Mul(machInst, rdn, rm, rdn);
                              } else {
                                  return new MulCc(machInst, rdn, rm, rdn);
                              }
                            case 0xe:
                              if (machInst.itstateMask) {
                                  return new BicReg(machInst, rdn, rdn, rm, 0, LSL);
                              } else {
                                  return new BicRegCc(machInst, rdn, rdn, rm, 0, LSL);
                              }
                            case 0xf:
                              if (machInst.itstateMask) {
                                  return new MvnReg(machInst, rdn, INTREG_ZERO, rm, 0, LSL);
                              } else {
                                  return new MvnRegCc(machInst, rdn, INTREG_ZERO, rm, 0, LSL);
                              }
                          }
                      }
                      break;
                
                case 0x1:  
                  // Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))
                  
                      {
                          const IntRegIndex rdn =
                              (IntRegIndex)(uint32_t)(bits(machInst, 2, 0) |
                                                      (bits(machInst, 7) << 3));
                          const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 6, 3);
                          switch (bits(machInst, 9, 8)) {
                            case 0x0:
                             return new AddReg(machInst, rdn, rdn, rm, 0, LSL);
                            case 0x1:
                              return new CmpRegCc(machInst, INTREG_ZERO, rdn, rm, 0, LSL);
                            case 0x2:
                              return new MovReg(machInst, rdn, INTREG_ZERO, rm, 0, LSL);
                            case 0x3:
                              if (bits(machInst, 7) == 0) {
                                  return new BxReg(machInst,
                                                   (IntRegIndex)(uint32_t)bits(machInst, 6, 3),
                                                   COND_UC);
                              } else {
                                  return new BlxReg(machInst,
                                                    (IntRegIndex)(uint32_t)bits(machInst, 6, 3),
                                                    COND_UC);
                              }
                          }
                      }
                      break;
                
                case 0x2: case 0x3:  
                  // Thumb16MemLit::thumb16MemLit(([], {}))
                  
                      {
                          const uint32_t rt = bits(machInst, 10, 8);
                          const uint32_t imm8 = bits(machInst, 7, 0);
                          return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, rt, INTREG_PC, true, imm8 << 2);
                      }
                      break;
                
                default:  
                  // Thumb16MemReg::thumb16MemReg(([], {}))
                  
                      {
                          const uint32_t opb = bits(machInst, 11, 9);
                          const uint32_t rt = bits(machInst, 2, 0);
                          const uint32_t rn = bits(machInst, 5, 3);
                          const uint32_t rm = bits(machInst, 8, 6);
                          switch (opb) {
                            case 0x0:
                              return new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x1:
                              return new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x2:
                              return new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x3:
                              return new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x4:
                              return new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x5:
                              return new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x6:
                              return new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true, 0, LSL, rm);
                            case 0x7:
                              return new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, rt, rn, true, 0, LSL, rm);
                          }
                      }
                      break;
                }
              
            case 0x3: case 0x4:  
              // Thumb16MemImm::thumb16MemImm(([], {}))
              
                  {
                      const uint32_t opa = bits(machInst, 15, 12);
                      const uint32_t opb = bits(machInst, 11, 9);
                      const uint32_t lrt = bits(machInst, 2, 0);
                      const uint32_t lrn = bits(machInst, 5, 3);
                      const uint32_t hrt = bits(machInst, 10, 8);
                      const uint32_t imm5 = bits(machInst, 10, 6);
                      const uint32_t imm8 = bits(machInst, 7, 0);
                      const bool load = bits(opb, 2);
                      switch (opa) {
                        case 0x6:
                          if (load) {
                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, lrt, lrn, true, imm5 << 2);
                          } else {
                              return new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, lrt, lrn, true, imm5 << 2);
                          }
                        case 0x7:
                          if (load) {
                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, lrt, lrn, true, imm5);
                          } else {
                              return new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, lrt, lrn, true, imm5);
                          }
                        case 0x8:
                          if (load) {
                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, lrt, lrn, true, imm5 << 1);
                          } else {
                              return new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, lrt, lrn, true, imm5 << 1);
                          }
                        case 0x9:
                          if (load) {
                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, hrt, INTREG_SP, true, imm8 << 2);
                          } else {
                              return new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, hrt, INTREG_SP, true, imm8 << 2);
                          }
                        default:
                          return new Unknown(machInst);
                      }
                  }
                  break;
            
            case 0x5:
              switch (TOPCODE_12_11) {
                
                case 0x0:  
                  // Thumb16Adr::thumb16Adr(([], {}))
                  
                      {
                          const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 10, 8);
                          const uint32_t imm8 = bits(machInst, 7, 0) << 2;
                          return new AdrImm(machInst, rd, (IntRegIndex)1, imm8, false);
                      }
                      break;
                
                case 0x1:  
                  // Thumb16AddSp::thumb16AddSp(([], {}))
                  
                      {
                          const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 10, 8);
                          const uint32_t imm8 = bits(machInst, 7, 0) << 2;
                          	return new AddImm(machInst, rd, INTREG_SP, imm8, true);
                      }
                      break;
                
                case 0x2: case 0x3:  
                  // Thumb16Misc::thumb16Misc(([], {}))
                  
                      {
                          switch (bits(machInst, 11, 8)) {
                            case 0x0:
                              if (bits(machInst, 7)) {
                                  return new SubImm(machInst, INTREG_SP, INTREG_SP,
                                                     bits(machInst, 6, 0) << 2, true);
                              } else {
                                  return new AddImm(machInst, INTREG_SP, INTREG_SP,
                                                     bits(machInst, 6, 0) << 2, true);
                              }
                            case 0x2:
                              {
                                  const IntRegIndex rd =
                                      (IntRegIndex)(uint32_t)bits(machInst, 2, 0);
                                  const IntRegIndex rm =
                                      (IntRegIndex)(uint32_t)bits(machInst, 5, 3);
                                  switch (bits(machInst, 7, 6)) {
                                    case 0x0:
                                      return new Sxth(machInst, rd, 0, rm);
                                    case 0x1:
                                      return new Sxtb(machInst, rd, 0, rm);
                                    case 0x2:
                                      return new Uxth(machInst, rd, 0, rm);
                                    case 0x3:
                                      return new Uxtb(machInst, rd, 0, rm);
                                  }
                              }
                            case 0x1:
                            case 0x3:
                              return new Cbz(machInst,
                                             (bits(machInst, 9) << 6) |
                                             (bits(machInst, 7, 3) << 1),
                                             (IntRegIndex)(uint32_t)bits(machInst, 2, 0));
                            case 0x4:
                            case 0x5:
                              {
                                  const uint32_t m = bits(machInst, 8);
                                  const uint32_t regList = bits(machInst, 7, 0) | (m << 14);
                                  return new LdmStm(machInst, INTREG_SP, false, false, false,
                                                    true, false, regList);
                              }
                            case 0x6:
                              {
                                  const uint32_t opBits = bits(machInst, 7, 5);
                                  if (opBits == 2) {
                                      return new Setend(machInst, bits(machInst, 3));
                                  } else if (opBits == 3) {
                                      const bool enable = (bits(machInst, 4) == 0);
                                      const uint32_t mods = (bits(machInst, 2, 0) << 5) |
                                                            ((enable ? 1 : 0) << 9);
                                      return new Cps(machInst, mods);
                                  }
                              }
                            case 0xa:
                              {
                                  IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 2, 0);
                                  IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 5, 3);
                                  switch (bits(machInst, 7, 6)) {
                                    case 0x0:
                                      return new Rev(machInst, rd, rm);
                                    case 0x1:
                                      return new Rev16(machInst, rd, rm);
                                    case 0x3:
                                      return new Revsh(machInst, rd, rm);
                                    default:
                                      break;
                                  }
                              }
                              break;
                            case 0x9:
                            case 0xb:
                              return new Cbnz(machInst,
                                              (bits(machInst, 9) << 6) |
                                              (bits(machInst, 7, 3) << 1),
                                              (IntRegIndex)(uint32_t)bits(machInst, 2, 0));
                            case 0xc:
                            case 0xd:
                              {
                                  const uint32_t p = bits(machInst, 8);
                                  const uint32_t regList = bits(machInst, 7, 0) | (p << 15);
                                  return new LdmStm(machInst, INTREG_SP, true, true, false,
                                                    true, true, regList);
                              }
                            case 0xe:
                              return new BkptInst(machInst);
                            case 0xf:
                              if (bits(machInst, 3, 0) != 0)
                                  return new ItInst(machInst);
                              switch (bits(machInst, 7, 4)) {
                                case 0x0:
                                  return new NopInst(machInst);
                                case 0x1:
                                  return new YieldInst(machInst);
                                case 0x2:
                                  return new WfeInst(machInst);
                                case 0x3:
                                  return new WfiInst(machInst);
                                case 0x4:
                                  return new SevInst(machInst);
                                default:
                                  return new WarnUnimplemented("unallocated_hint", machInst);
                              }
                            default:
                              break;
                          }
                          return new Unknown(machInst);
                      }
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x6:
              switch (TOPCODE_12_11) {
                
                case 0x0: case 0x1:  
                  // Thumb16MacroMem::thumb16MacroMem(([], {}))
                  
                      {
                          const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 10, 8);
                          const bool load = (bits(machInst, 11) == 1);
                          const uint32_t regList = bits(machInst, 7, 0);
                          const bool writeback = (!load || bits(regList, rn) == 0);
                          return new LdmStm(machInst, rn, true, true, false,
                                            writeback, load, regList);
                      }
                      break;
                
                case 0x2: case 0x3:  
                  // Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))
                  
                          if (bits(machInst, 11, 9) != 0x7) {
                              return new B(machInst, sext<9>(bits(machInst, 7, 0) << 1),
                                           (ConditionCode)(uint32_t)bits(machInst, 11, 8));
                          } else if (bits(machInst, 8)) {
                              return new Svc(machInst);
                          } else {
                              // This space will not be allocated in the future.
                              return new Unknown(machInst);
                          }
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x7:
              switch (TOPCODE_12_11) {
                
                case 0x0:  
                  // Thumb16UncondBranch::thumb16UncondBranch(([], {}))
                  
                          return new B(machInst, sext<12>(bits(machInst, 10, 0) << 1), COND_UC);
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        case 0x1:
          switch (HTOPCODE_12_11) {
            
            case 0x1:
              switch (HTOPCODE_10_9) {
                
                case 0x0:
                  switch (HTOPCODE_6) {
                    
                    case 0x0:
                      switch (HTOPCODE_8_7) {
                        
                        case 0x0: case 0x3:  
                          // Thumb32SrsRfe::thumb32SrsRfe(([], {}))
                          
                              {
                                  const bool wb = (bits(machInst, 21) == 1);
                                  const bool add = (bits(machInst, 24, 23) == 0x3);
                                  if (bits(machInst, 20) == 1) {
                                      // post == add
                                      const IntRegIndex rn =
                                          (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                      if (!add && !wb) {
                                          return new RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8(machInst, rn, RfeOp::DecrementBefore, wb);
                                      } else if (add && !wb) {
                                          return new RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8(machInst, rn, RfeOp::IncrementAfter, wb);
                                      } else if (!add && wb) {
                                          return new RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8(machInst, rn, RfeOp::DecrementBefore, wb);
                                      } else {
                                          return new RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8(machInst, rn, RfeOp::IncrementAfter, wb);
                                      }
                                  } else {
                                      const uint32_t mode = bits(machInst, 4, 0);
                                      if (badMode((OperatingMode)mode))
                                          return new Unknown(machInst);
                                      if (!add && !wb) {
                                          return new SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8(machInst, mode,
                                                  SrsOp::DecrementBefore, wb);
                                      } else if (add && !wb) {
                                          return new SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8(machInst, mode,
                                                  SrsOp::IncrementAfter, wb);
                                      } else if (!add && wb) {
                                          return new SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8(machInst, mode,
                                                  SrsOp::DecrementBefore, wb);
                                      } else {
                                          return new SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8(machInst, mode,
                                                  SrsOp::IncrementAfter, wb);
                                      }
                                  }
                              }
                              break;
                        
                        default:  
                          // ArmMacroMem::armMacroMem(([], {}))
                          
                              return new LdmStm(machInst, (IntRegIndex)(uint32_t)RN, !PREPOST, UP,
                                                PSRUSER, WRITEBACK, LOADOP, machInst.regList);
                              break;
                        }
                      
                    case 0x1:  
                      // Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 24, 23);
                              const uint32_t op2 = bits(machInst, 21, 20);
                              const uint32_t op3 = bits(machInst, 7, 4);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                              const IntRegIndex rt2 = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                              const uint32_t imm8 = bits(machInst, 7, 0);
                              if (bits(op1, 1) == 0 && bits(op2, 1) == 0) {
                                  if (op1 == 0) {
                                      const uint32_t imm = bits(machInst, 7, 0) << 2;
                                      if (op2 == 0) {
                                          return new STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, rt2, rt, rn, true, imm);
                                      } else {
                                          return new LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, rt, rn, true, imm);
                                      }
                                  } else {
                                      if (op2 == 0) {
                                          switch (op3) {
                                            case 0x4:
                                              return new STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rd, rt, rn, true, 0);
                                            case 0x5:
                                              return new STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rd, rt, rn, true, 0);
                                            case 0x7:
                                              return new STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rd, rt,
                                                                    rt2, rn, true, 0);
                                            default:
                                              return new Unknown(machInst);
                                          }
                                      } else {
                                          switch (op3) {
                                            case 0x0:
                                              return new Tbb(machInst, rn, rd);
                                            case 0x1:
                                              return new Tbh(machInst, rn, rd);
                                            case 0x4:
                                              return new LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true, 0);
                                            case 0x5:
                                              return new LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true, 0);
                                            case 0x7:
                                              return new LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, true, 0);
                                            default:
                                              return new Unknown(machInst);
                                          }
                                      }
                                  }
                              } else {
                                  const uint32_t puw = (bits(machInst, 24, 23) << 1) |
                                                        bits(machInst, 21);
                                  const uint32_t dimm = imm8 << 2;
                                  if (bits(op2, 0) == 0) {
                                      switch (puw) {
                                        case 0x1:
                                          return new STORE_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x3:
                                          return new STORE_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        case 0x4:
                                          return new STORE_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x5:
                                          return new STORE_IMMD_AN_PN_SN_UN_WY_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x6:
                                          return new STORE_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        case 0x7:
                                          return new STORE_IMMD_AY_PN_SN_UN_WY_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        default:
                                          return new Unknown(machInst);
                                      }
                                  } else {
                                      switch (puw) {
                                        case 0x1:
                                          return new LOAD_IMMD_AN_PY_SN_UN_WY_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x3:
                                          return new LOAD_IMMD_AY_PY_SN_UN_WY_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        case 0x4:
                                          return new LOAD_IMMD_AN_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x5:
                                          return new LOAD_IMMD_AN_PN_SN_UN_WY_SZ4(machInst, rt, rt2, rn, false, dimm);
                                        case 0x6:
                                          return new LOAD_IMMD_AY_PN_SN_UN_WN_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        case 0x7:
                                          return new LOAD_IMMD_AY_PN_SN_UN_WY_SZ4(machInst, rt, rt2, rn, true, dimm);
                                        default:
                                          return new Unknown(machInst);
                                      }
                                  }
                              }
                          }
                          break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x1:  
                  // Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))
                  
                      {
                          const uint32_t op = bits(machInst, 24, 21);
                          const bool s = (bits(machInst, 20) == 1);
                          const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                          const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                          const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                          const uint32_t amt = (bits(machInst, 14, 12) << 2) |
                                                bits(machInst, 7, 6);
                          const ArmShiftType type = (ArmShiftType)(uint32_t)bits(machInst, 5, 4);
                          switch (op) {
                            case 0x0:
                              if (rd == INTREG_PC) {
                                  
                              if (s) {
                                  return new TstRegCc(machInst, INTREG_ZERO,
                                                            rn, rm, amt, type);
                              } else {
                                  return new TstReg(machInst, INTREG_ZERO,
                                                          rn, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new AndRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new AndReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0x1:
                              
                              if (s) {
                                  return new BicRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new BicReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                            case 0x2:
                              if (rn == INTREG_PC) {
                                  
                              if (s) {
                                  return new MovRegCc(machInst, rd,
                                                            INTREG_ZERO, rm, amt, type);
                              } else {
                                  return new MovReg(machInst, rd,
                                                          INTREG_ZERO, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new OrrRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new OrrReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0x3:
                              if (rn == INTREG_PC) {
                                  
                              if (s) {
                                  return new MvnRegCc(machInst, rd,
                                                            INTREG_ZERO, rm, amt, type);
                              } else {
                                  return new MvnReg(machInst, rd,
                                                          INTREG_ZERO, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new OrnRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new OrnReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0x4:
                              if (rd == INTREG_PC) {
                                  
                              if (s) {
                                  return new TeqRegCc(machInst, INTREG_ZERO,
                                                            rn, rm, amt, type);
                              } else {
                                  return new TeqReg(machInst, INTREG_ZERO,
                                                          rn, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new EorRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new EorReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0x6:
                              if (type) {
                                  return new PkhtbReg(machInst, rd, rn, rm, amt, type);
                              } else {
                                  return new PkhbtReg(machInst, rd, rn, rm, amt, type);
                              }
                            case 0x8:
                              if (rd == INTREG_PC) {
                                  
                              if (s) {
                                  return new CmnRegCc(machInst, INTREG_ZERO,
                                                            rn, rm, amt, type);
                              } else {
                                  return new CmnReg(machInst, INTREG_ZERO,
                                                          rn, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new AddRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new AddReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0xa:
                              
                              if (s) {
                                  return new AdcRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new AdcReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                            case 0xb:
                              
                              if (s) {
                                  return new SbcRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new SbcReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                            case 0xd:
                              if (rd == INTREG_PC) {
                                  
                              if (s) {
                                  return new CmpRegCc(machInst, INTREG_ZERO,
                                                            rn, rm, amt, type);
                              } else {
                                  return new CmpReg(machInst, INTREG_ZERO,
                                                          rn, rm, amt, type);
                              }
                          
                              } else {
                                  
                              if (s) {
                                  return new SubRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new SubReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                              }
                            case 0xe:
                              
                              if (s) {
                                  return new RsbRegCc(machInst, rd,
                                                            rn, rm, amt, type);
                              } else {
                                  return new RsbReg(machInst, rd,
                                                          rn, rm, amt, type);
                              }
                          
                            default:
                              return new Unknown(machInst);
                          }
                      }
                      break;
                
                default:
                  switch (HTOPCODE_9_8) {
                    
                    case 0x2:
                      switch (LTOPCODE_4) {
                        
                        case 0x0:
                          switch (LTCOPROC) {
                            
                            case 0xa: case 0xb:  
                              // VfpData::vfpData(([], {}))
                              
                                  return decodeVfpData(machInst);
                                  break;
                            
                            default:  
                              // WarnUnimpl::cdp(([], {}))
                              
                                      return new WarnUnimplemented("cdp", machInst);
                              break;
                            }
                          
                        case 0x1:
                          switch (LTCOPROC) {
                            
                            case 0x1:  
                              // M5ops::m5ops(([], {}))
                              
                                  {
                                      const uint32_t m5func = bits(machInst, 23, 16);
                                      switch(m5func) {
                                          case 0x00: return new Arm(machInst);
                                          case 0x01: return new Quiesce(machInst);
                                          case 0x02: return new QuiesceNs(machInst);
                                          case 0x03: return new QuiesceCycles(machInst);
                                          case 0x04: return new QuiesceTime(machInst);
                                          case 0x07: return new Rpns(machInst);
                                          case 0x09: return new WakeCPU(machInst);
                                          case 0x10: return new Deprecated_ivlb(machInst);
                                          case 0x11: return new Deprecated_ivle(machInst);
                                          case 0x20: return new Deprecated_exit (machInst);
                                          case 0x21: return new M5exit(machInst);
                                          case 0x22: return new M5fail(machInst);
                                          case 0x31: return new Loadsymbol(machInst);
                                          case 0x30: return new Initparam(machInst);
                                          case 0x40: return new Resetstats(machInst);
                                          case 0x41: return new Dumpstats(machInst);
                                          case 0x42: return new Dumpresetstats(machInst);
                                          case 0x43: return new M5checkpoint(machInst);
                                          case 0x4F: return new M5writefile(machInst);
                                          case 0x50: return new M5readfile(machInst);
                                          case 0x51: return new M5break(machInst);
                                          case 0x52: return new M5switchcpu(machInst);
                                          case 0x53: return new M5addsymbol(machInst);
                                          case 0x54: return new M5panic(machInst);
                                          case 0x5a: return new M5workbegin(machInst);
                                          case 0x5b: return new M5workend(machInst);
                                      }
                                 }
                                 break;
                            
                            case 0xa: case 0xb:  
                              // ShortFpTransfer::shortFpTransfer(([], {}))
                              
                                  return decodeShortFpTransfer(machInst);
                                  break;
                            
                            case 0xe:  
                              // McrMrc14::mcrMrc14(([], {}))
                              
                                  return decodeMcrMrc14(machInst);
                                  break;
                            
                            case 0xf:  
                              // McrMrc15::mcrMrc15(([], {}))
                              
                                  return decodeMcrMrc15(machInst);
                                  break;
                            
                            default:
                              
                              // Unknown::unknown(([], {}))
                              return new Unknown(machInst);
                              break;
                            }
                          
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    case 0x3:  
                      // ThumbNeonData::ThumbNeonData(([], {}))
                      
                          return decodeNeonData(machInst);
                          break;
                    
                    default:
                      switch (LTCOPROC) {
                        
                        case 0xa: case 0xb:  
                          // ExtensionRegLoadStore::extensionRegLoadStre(([], {}))
                          
                              return decodeExtensionRegLoadStore(machInst);
                              break;
                        
                        case 0xf:
                          switch (HTOPCODE_9_4) {
                            
                            case 0x0:  
                              // Unknown::undefined(([], {}))
                              return new Unknown(machInst);
                              break;
                            
                            case 0x4:  
                              // WarnUnimpl::mcrr(([], {}))
                              
                                      return new WarnUnimplemented("mcrr", machInst);
                              break;
                            
                            case 0x5:  
                              // WarnUnimpl::mrrc(([], {}))
                              
                                      return new WarnUnimplemented("mrrc", machInst);
                              break;
                            
                            case 0x2: case 0x6: case 0x8: case 0xa: case 0xc: case 0xe: case 0x10: case 0x12: case 0x14: case 0x16: case 0x18: case 0x1a: case 0x1c: case 0x1e:  
                              // WarnUnimpl::stc(([], {}))
                              
                                      return new WarnUnimplemented("stc", machInst);
                              break;
                            
                            case 0x3: case 0x7: case 0x9: case 0xb: case 0xd: case 0xf: case 0x11: case 0x13: case 0x15: case 0x17: case 0x19: case 0x1b: case 0x1d: case 0x1f:
                              switch (HTRN) {
                                
                                case 0xf:  
                                  // WarnUnimpl::ldc(([], {}))
                                  
                                          return new WarnUnimplemented("ldc", machInst);
                                  break;
                                
                                default:  
                                  // WarnUnimpl::ldc(([], {}))
                                  
                                          return new WarnUnimplemented("ldc", machInst);
                                  break;
                                }
                              
                            default:
                              
                              // Unknown::unknown(([], {}))
                              return new Unknown(machInst);
                              break;
                            }
                          
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      }
                  }
              
            case 0x2:
              switch (LTOPCODE_15) {
                
                case 0x0:
                  switch (HTOPCODE_9) {
                    
                    case 0x0:  
                      // Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))
                      
                          {
                              const uint32_t op = bits(machInst, 24, 21);
                              const bool s = (bits(machInst, 20) == 1);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              const uint32_t ctrlImm = bits(machInst.instBits, 26) << 3 |
                                                       bits(machInst, 14, 12);
                              const bool rotC = ctrlImm > 3;
                              const uint32_t dataImm = bits(machInst, 7, 0);
                              const uint32_t imm = modified_imm(ctrlImm, dataImm);
                              switch (op) {
                                case 0x0:
                                  if (rd == INTREG_PC) {
                                      
                                  if (s) {
                                      return new TstImmCc(machInst, INTREG_ZERO,
                                                                rn, imm, rotC);
                                  } else {
                                      return new TstImm(machInst, INTREG_ZERO,
                                                              rn, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new AndImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new AndImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0x1:
                                  
                                  if (s) {
                                      return new BicImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new BicImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                case 0x2:
                                  if (rn == INTREG_PC) {
                                      
                                  if (s) {
                                      return new MovImmCc(machInst, rd,
                                                                INTREG_ZERO, imm, rotC);
                                  } else {
                                      return new MovImm(machInst, rd,
                                                              INTREG_ZERO, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new OrrImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new OrrImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0x3:
                                  if (rn == INTREG_PC) {
                                      
                                  if (s) {
                                      return new MvnImmCc(machInst, rd,
                                                                INTREG_ZERO, imm, rotC);
                                  } else {
                                      return new MvnImm(machInst, rd,
                                                              INTREG_ZERO, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new OrnImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new OrnImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0x4:
                                  if (rd == INTREG_PC) {
                                      
                                  if (s) {
                                      return new TeqImmCc(machInst, INTREG_ZERO,
                                                                rn, imm, rotC);
                                  } else {
                                      return new TeqImm(machInst, INTREG_ZERO,
                                                              rn, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new EorImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new EorImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0x8:
                                  if (rd == INTREG_PC) {
                                      
                                  if (s) {
                                      return new CmnImmCc(machInst, INTREG_ZERO,
                                                                rn, imm, rotC);
                                  } else {
                                      return new CmnImm(machInst, INTREG_ZERO,
                                                              rn, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new AddImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new AddImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0xa:
                                  
                                  if (s) {
                                      return new AdcImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new AdcImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                case 0xb:
                                  
                                  if (s) {
                                      return new SbcImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new SbcImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                case 0xd:
                                  if (rd == INTREG_PC) {
                                      
                                  if (s) {
                                      return new CmpImmCc(machInst, INTREG_ZERO,
                                                                rn, imm, rotC);
                                  } else {
                                      return new CmpImm(machInst, INTREG_ZERO,
                                                              rn, imm, rotC);
                                  }
                              
                                  } else {
                                      
                                  if (s) {
                                      return new SubImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new SubImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                  }
                                case 0xe:
                                  
                                  if (s) {
                                      return new RsbImmCc(machInst, rd,
                                                                rn, imm, rotC);
                                  } else {
                                      return new RsbImm(machInst, rd,
                                                              rn, imm, rotC);
                                  }
                              
                                default:
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                    
                    case 0x1:  
                      // Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))
                      
                          {
                              const uint32_t op = bits(machInst, 24, 20);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              switch (op) {
                                case 0x0:
                                  {
                                      const uint32_t imm = bits(machInst, 7, 0) |
                                                           (bits(machInst, 14, 12) << 8) |
                                                           (bits(machInst, 26) << 11);
                                      if (rn == 0xf) {
                                          return new AdrImm(machInst, rd, (IntRegIndex)1,
                                                            imm, false);
                                      } else {
                                              return new AddImm(machInst, rd, rn, imm, true);
                                      }
                                  }
                                case 0x4:
                                  {
                                      const uint32_t imm = bits(machInst, 7, 0) |
                                                           (bits(machInst, 14, 12) << 8) |
                                                           (bits(machInst, 26) << 11) |
                                                           (bits(machInst, 19, 16) << 12);
                                      return new MovImm(machInst, rd, INTREG_ZERO, imm, true);
                                  }
                                case 0xa:
                                  {
                                      const uint32_t imm = bits(machInst, 7, 0) |
                                                           (bits(machInst, 14, 12) << 8) |
                                                           (bits(machInst, 26) << 11);
                                      if (rn == 0xf) {
                                          return new AdrImm(machInst, rd, (IntRegIndex)0,
                                                            imm, false);
                                      } else {
                                          return new SubImm(machInst, rd, rn, imm, true);
                                      }
                                  }
                                case 0xc:
                                  {
                                      const uint32_t imm = bits(machInst, 7, 0) |
                                                           (bits(machInst, 14, 12) << 8) |
                                                           (bits(machInst, 26) << 11) |
                                                           (bits(machInst, 19, 16) << 12);
                                      return new MovtImm(machInst, rd, rd, imm, true);
                                  }
                                case 0x12:
                                  if (!(bits(machInst, 14, 12) || bits(machInst, 7, 6))) {
                                      const uint32_t satImm = bits(machInst, 4, 0);
                                      return new Ssat16(machInst, rd, satImm + 1, rn);
                                  }
                                  // Fall through on purpose...
                                case 0x10:
                                  {
                                      const uint32_t satImm = bits(machInst, 4, 0);
                                      const uint32_t imm = bits(machInst, 7, 6) |
                                                           (bits(machInst, 14, 12) << 2);
                                      const ArmShiftType type =
                                          (ArmShiftType)(uint32_t)bits(machInst, 21, 20);
                                      return new Ssat(machInst, rd, satImm + 1, rn, imm, type);
                                  }
                                case 0x14:
                                  {
                                      const uint32_t lsb = bits(machInst, 7, 6) |
                                                           (bits(machInst, 14, 12) << 2);
                                      const uint32_t msb = lsb + bits(machInst, 4, 0);
                                      return new Sbfx(machInst, rd, rn, lsb, msb);
                                  }
                                case 0x16:
                                  {
                                      const uint32_t lsb = bits(machInst, 7, 6) |
                                                           (bits(machInst, 14, 12) << 2);
                                      const uint32_t msb = bits(machInst, 4, 0);
                                      if (rn == 0xf) {
                                          return new Bfc(machInst, rd, rd, lsb, msb);
                                      } else {
                                          return new Bfi(machInst, rd, rn, lsb, msb);
                                      }
                                  }
                                case 0x1a:
                                  if (!(bits(machInst, 14, 12) || bits(machInst, 7, 6))) {
                                      const uint32_t satImm = bits(machInst, 4, 0);
                                      return new Usat16(machInst, rd, satImm, rn);
                                  }
                                  // Fall through on purpose...
                                case 0x18:
                                  {
                                      const uint32_t satImm = bits(machInst, 4, 0);
                                      const uint32_t imm = bits(machInst, 7, 6) |
                                                           (bits(machInst, 14, 12) << 2);
                                      const ArmShiftType type =
                                          (ArmShiftType)(uint32_t)bits(machInst, 21, 20);
                                      return new Usat(machInst, rd, satImm, rn, imm, type);
                                  }
                                case 0x1c:
                                  {
                                      const uint32_t lsb = bits(machInst, 7, 6) |
                                                           (bits(machInst, 14, 12) << 2);
                                      const uint32_t msb = lsb + bits(machInst, 4, 0);
                                      return new Ubfx(machInst, rd, rn, lsb, msb);
                                  }
                                default:
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                    
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x1:  
                  // Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))
                  
                      {
                          const uint32_t op = bits(machInst, 26, 20);
                          const uint32_t op1 = bits(machInst, 14, 12);
                          switch (op1 & 0x5) {
                            case 0x0:
                              if (op == 127) {
                                  if (op1 & 0x2) {
                                      // Permanently undefined.
                                      return new Unknown(machInst);
                                  } else {
                                      return new WarnUnimplemented("smc", machInst);
                                  }
                              } else if ((op & 0x38) != 0x38) {
                                  const uint32_t s = bits(machInst, 26);
                                  const uint32_t j1 = bits(machInst, 13);
                                  const uint32_t j2 = bits(machInst, 11);
                                  const uint32_t imm6 = bits(machInst, 21, 16);
                                  const uint32_t imm11 = bits(machInst, 10, 0);
                                  const int32_t imm = sext<21>((s << 20) |
                                                               (j2 << 19) | (j1 << 18) |
                                                               (imm6 << 12) | (imm11 << 1));
                                  return new B(machInst, imm,
                                               (ConditionCode)(uint32_t)bits(machInst, 25, 22));
                              } else {
                                  switch (op) {
                                    case 0x38:
                                      {
                                          const IntRegIndex rn =
                                              (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                          const uint8_t byteMask = bits(machInst, 11, 8);
                                          return new MsrCpsrReg(machInst, rn, byteMask);
                                      }
                                    case 0x39:
                                      {
                                          const IntRegIndex rn =
                                              (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                          const uint8_t byteMask = bits(machInst, 11, 8);
                                          return new MsrSpsrReg(machInst, rn, byteMask);
                                      }
                                    case 0x3a:
                                      {
                                          const uint32_t op1 = bits(machInst, 10, 8);
                                          const uint32_t op2 = bits(machInst, 7, 0);
                                          if (op1 != 0) {
                                              const bool enable = bits(machInst, 10, 9) == 0x2;
                                              const uint32_t mods = bits(machInst, 8, 0) |
                                                                    ((enable ? 1 : 0) << 9);
                                              return new Cps(machInst, mods);
                                          } else if ((op2 & 0xf0) == 0xf0) {
                                              return new Dbg(machInst);
                                          } else {
                                              switch (op2) {
                                                case 0x0:
                                                  return new NopInst(machInst);
                                                case 0x1:
                                                  return new YieldInst(machInst);
                                                case 0x2:
                                                  return new WfeInst(machInst);
                                                case 0x3:
                                                  return new WfiInst(machInst);
                                                case 0x4:
                                                  return new SevInst(machInst);
                                                default:
                                                  break;
                                              }
                                          }
                                          break;
                                      }
                                    case 0x3b:
                                      {
                                          const uint32_t op = bits(machInst, 7, 4);
                                          switch (op) {
                                            case 0x0:
                                              return new Leavex(machInst);
                                            case 0x1:
                                              return new Enterx(machInst);
                                            case 0x2:
                                              return new Clrex(machInst);
                                            case 0x4:
                                              return new Dsb(machInst);
                                            case 0x5:
                                              return new Dmb(machInst);
                                            case 0x6:
                                              return new Isb(machInst);
                                            default:
                                              break;
                                          }
                                          break;
                                      }
                                    case 0x3c:
                                      {
                                          // On systems that don't support bxj, bxj == bx
                                          return new BxReg(machInst,
                                                   (IntRegIndex)(uint32_t)bits(machInst, 19, 16),
                                                   COND_UC);
                                      }
                                    case 0x3d:
                                      {
                                          const uint32_t imm32 = bits(machInst, 7, 0);
                                          return new SubsImmPclr(machInst, INTREG_PC, INTREG_LR,
                                                                 imm32, false);
                                      }
                                    case 0x3e:
                                      {
                                          const IntRegIndex rd =
                                              (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                          return new MrsCpsr(machInst, rd);
                                      }
                                    case 0x3f:
                                      {
                                          const IntRegIndex rd =
                                              (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                          return new MrsSpsr(machInst, rd);
                                      }
                                  }
                                  break;
                              }
                            case 0x1:
                              {
                                  const uint32_t s = bits(machInst, 26);
                                  const uint32_t i1 = !(bits(machInst, 13) ^ s);
                                  const uint32_t i2 = !(bits(machInst, 11) ^ s);
                                  const uint32_t imm10 = bits(machInst, 25, 16);
                                  const uint32_t imm11 = bits(machInst, 10, 0);
                                  const int32_t imm = sext<25>((s << 24) |
                                                               (i1 << 23) | (i2 << 22) |
                                                               (imm10 << 12) | (imm11 << 1));
                                  return new B(machInst, imm, COND_UC);
                              }
                            case 0x4:
                              {
                                  if (bits(machInst, 0) == 1) {
                                      return new Unknown(machInst);
                                  }
                                  const uint32_t s = bits(machInst, 26);
                                  const uint32_t i1 = !(bits(machInst, 13) ^ s);
                                  const uint32_t i2 = !(bits(machInst, 11) ^ s);
                                  const uint32_t imm10h = bits(machInst, 25, 16);
                                  const uint32_t imm10l = bits(machInst, 10, 1);
                                  const int32_t imm = sext<25>((s << 24) |
                                                               (i1 << 23) | (i2 << 22) |
                                                               (imm10h << 12) | (imm10l << 2));
                                  return new BlxImm(machInst, imm, COND_UC);
                              }
                            case 0x5:
                              {
                                  const uint32_t s = bits(machInst, 26);
                                  const uint32_t i1 = !(bits(machInst, 13) ^ s);
                                  const uint32_t i2 = !(bits(machInst, 11) ^ s);
                                  const uint32_t imm10 = bits(machInst, 25, 16);
                                  const uint32_t imm11 = bits(machInst, 10, 0);
                                  const int32_t imm = sext<25>((s << 24) |
                                                               (i1 << 23) | (i2 << 22) |
                                                               (imm10 << 12) | (imm11 << 1));
                                  return new Bl(machInst, imm, COND_UC);
                              }
                            default:
                              break;
                          }
                          return new Unknown(machInst);
                      }
                      break;
                
                default:
                  
                  // Unknown::unknown(([], {}))
                  return new Unknown(machInst);
                  break;
                }
              
            case 0x3:
              switch (HTOPCODE_10_9) {
                
                case 0x0:
                  switch (HTOPCODE_4) {
                    
                    case 0x0:
                      switch (HTOPCODE_8) {
                        
                        case 0x0:  
                          // Thumb32StoreSingle::thumb32StoreSingle(([], {}))
                          
                              {
                                  uint32_t op1 = bits(machInst, 23, 21);
                                  uint32_t op2 = bits(machInst, 11, 6);
                                  bool op2Puw = ((op2 & 0x24) == 0x24 ||
                                                 (op2 & 0x3c) == 0x30);
                                  if (RN == 0xf) {
                                      return new Unknown(machInst);
                                  }
                                  if (op1 == 4) {
                                      return new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, RT, RN, true, IMMED_11_0);
                                  } else if (op1 == 0 && op2Puw) {
                                      
                                          {
                                              uint32_t puw = bits(machInst, 10, 8);
                                              uint32_t imm = IMMED_7_0;
                                              switch (puw) {
                                                case 0:
                                                case 2:
                                                  // If we're here, either P or W must have been set.
                                                  panic("Neither P or W set, but that "
                                                          "shouldn't be possible.\n");
                                                case 1:
                                                  return new STORE_IMM_AN_PY_SN_UN_WY_SZ1(machInst, RT, RN, false, imm);
                                                case 3:
                                                  return new STORE_IMM_AY_PY_SN_UN_WY_SZ1(machInst, RT, RN, true, imm);
                                                case 4:
                                                  return new STORE_IMM_AN_PN_SN_UN_WN_SZ1(machInst, RT, RN, false, imm);
                                                case 5:
                                                  return new STORE_IMM_AN_PN_SN_UN_WY_SZ1(machInst, RT, RN, false, imm);
                                                case 6:
                                                  return new STORE_IMM_AY_PN_SN_UN_WN_SZ1(machInst, RT, RN, true, imm);
                                                case 7:
                                                  return new STORE_IMM_AY_PN_SN_UN_WY_SZ1(machInst, RT, RN, true, imm);
                                              }
                                          }
                                  ;
                                  } else if (op1 == 0 && ((op2 & 0x3c) == 0x38)) {
                                      return new STORE_IMM_AY_PN_SN_UY_WN_SZ1(machInst, RT, RN, true, IMMED_7_0);
                                  } else if (op1 == 0 && op2 == 0) {
                                      return new STORE_REG_AY_PN_SN_UN_WN_SZ1(machInst, RT, RN, true,
                                                              bits(machInst, 5, 4), LSL, RM);
                                  } else if (op1 == 5) {
                                      return new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, IMMED_11_0);
                                  } else if (op1 == 1 && op2Puw) {
                                      
                                          {
                                              uint32_t puw = bits(machInst, 10, 8);
                                              uint32_t imm = IMMED_7_0;
                                              switch (puw) {
                                                case 0:
                                                case 2:
                                                  // If we're here, either P or W must have been set.
                                                  panic("Neither P or W set, but that "
                                                          "shouldn't be possible.\n");
                                                case 1:
                                                  return new STORE_IMM_AN_PY_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                                                case 3:
                                                  return new STORE_IMM_AY_PY_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                                                case 4:
                                                  return new STORE_IMM_AN_PN_SN_UN_WN_SZ2(machInst, RT, RN, false, imm);
                                                case 5:
                                                  return new STORE_IMM_AN_PN_SN_UN_WY_SZ2(machInst, RT, RN, false, imm);
                                                case 6:
                                                  return new STORE_IMM_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true, imm);
                                                case 7:
                                                  return new STORE_IMM_AY_PN_SN_UN_WY_SZ2(machInst, RT, RN, true, imm);
                                              }
                                          }
                                  ;
                                  } else if (op1 == 1 && ((op2 & 0x3c) == 0x38)) {
                                      return new STORE_IMM_AY_PN_SN_UY_WN_SZ2(machInst, RT, RN, true, IMMED_7_0);
                                  } else if (op1 == 1 && op2 == 0) {
                                      return new STORE_REG_AY_PN_SN_UN_WN_SZ2(machInst, RT, RN, true,
                                                              bits(machInst, 5, 4), LSL, RM);
                                  } else if (op1 == 6) {
                                      return new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, true, IMMED_11_0);
                                  } else if (op1 == 2 && op2Puw) {
                                      
                                          {
                                              uint32_t puw = bits(machInst, 10, 8);
                                              uint32_t imm = IMMED_7_0;
                                              switch (puw) {
                                                case 0:
                                                case 2:
                                                  // If we're here, either P or W must have been set.
                                                  panic("Neither P or W set, but that "
                                                          "shouldn't be possible.\n");
                                                case 1:
                                                  return new STORE_IMM_AN_PY_SN_UN_WY_SZ4(machInst, RT, RN, false, imm);
                                                case 3:
                                                  return new STORE_IMM_AY_PY_SN_UN_WY_SZ4(machInst, RT, RN, true, imm);
                                                case 4:
                                                  return new STORE_IMM_AN_PN_SN_UN_WN_SZ4(machInst, RT, RN, false, imm);
                                                case 5:
                                                  return new STORE_IMM_AN_PN_SN_UN_WY_SZ4(machInst, RT, RN, false, imm);
                                                case 6:
                                                  return new STORE_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, true, imm);
                                                case 7:
                                                  return new STORE_IMM_AY_PN_SN_UN_WY_SZ4(machInst, RT, RN, true, imm);
                                              }
                                          }
                                  ;
                                  } else if (op1 == 2 && ((op2 & 0x3c) == 0x38)) {
                                      return new STORE_IMM_AY_PN_SN_UY_WN_SZ4(machInst, RT, RN, true, IMMED_7_0);
                                  } else if (op1 == 2 && op2 == 0) {
                                      return new STORE_REG_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, true,
                                                             bits(machInst, 5, 4), LSL, RM);
                                  } else {
                                      return new Unknown(machInst);
                                  }
                              }
                              break;
                        
                        case 0x1:  
                          // ThumbNeonMem::thumbNeonMem(([], {}))
                          
                              return decodeNeonMem(machInst);
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    case 0x1:
                      switch (HTOPCODE_6_5) {
                        
                        case 0x0:  
                          // LoadByteMemoryHints::loadByteMemoryHints(([], {}))
                          
                              {
                                  const uint32_t op1 = bits(machInst, 24, 23);
                                  const uint32_t op2 = bits(machInst, 11, 6);
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                  const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  const uint32_t imm12 = bits(machInst, 11, 0);
                                  const uint32_t imm8 = bits(machInst, 7, 0);
                                  bool pldw = bits(machInst, 21);
                                  const uint32_t imm2 = bits(machInst, 5, 4);
                                  if (rn == 0xf) {
                                      if (rt == 0xf) {
                                          const bool add = bits(machInst, 23);
                                          if (bits(op1, 1) == 1) {
                                              if (add) {
                                                  return new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           INTREG_PC, true, imm12);
                                              } else {
                                                  return new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          INTREG_PC, false, imm12);
                                              }
                                          } else {
                                              if (add) {
                                                  return new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           INTREG_PC, true, imm12);
                                              } else {
                                                  return new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          INTREG_PC, false, imm12);
                                              }
                                          }
                                      } else {
                                          if (bits(op1, 1) == 1) {
                                              if (bits(machInst, 23)) {
                                                  return new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, rt, INTREG_PC,
                                                                             true, imm12);
                                              } else {
                                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, rt, INTREG_PC,
                                                                           false, imm12);
                                              }
                                          } else {
                                              if (bits(machInst, 23)) {
                                                  return new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rt, INTREG_PC,
                                                                            true, imm12);
                                              } else {
                                                  return new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, rt, INTREG_PC,
                                                                          false, imm12);
                                              }
                                          }
                                      }
                                  } else if (rt == 0xf) {
                                      switch (op1) {
                                        case 0x0:
                                          if (op2 == 0x0) {
                                              if (pldw) {
                                                  return new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           rn, true, imm2, LSL, rm);
                                              } else {
                                                  return new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          rn, true, imm2, LSL, rm);
                                              }
                                          } else if (bits(op2, 5, 2) == 0xc) {
                                              if (pldw) {
                                                  return new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           rn, false, imm8);
                                              } else {
                                                  return new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          rn, false, imm8);
                                              }
                                          }
                                          break;
                                        case 0x1:
                                          if (pldw) {
                                              return new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                       rn, true, imm12);
                                          } else {
                                              return new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                      rn, true, imm12);
                                          }
                                        case 0x2:
                                          if (op2 == 0x0) {
                                              return new PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO, rn,
                                                                      true, imm2, LSL, rm);
                                          } else if (bits(op2, 5, 2) == 0xc) {
                                              return new PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                      INTREG_PC, false, imm8);
                                          }
                                          break;
                                        case 0x3:
                                          return new PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                  INTREG_PC, true, imm12);
                                      }
                                      return new Unknown(machInst);
                                  } else {
                                      switch (op1) {
                                        case 0x0:
                                          if (op2 == 0) {
                                              return new LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true,
                                                                       imm2, LSL, rm);
                                          } else if (bits(op2, 5, 2) == 0xe) {
                                              return new LOAD_IMM_AY_PN_SN_UY_WN_SZ1(machInst, rt, rn, true, imm8);
                                          } else if ((op2 & 0x24) == 0x24 || bits(op2, 5, 2) == 0xc) {
                                              const uint32_t puw = bits(machInst, 10, 8);
                                              switch (puw) {
                                                case 0x1:
                                                  return new LOAD_IMM_AN_PY_SN_UN_WY_SZ1(machInst, rt,
                                                                         rn, false, imm8);
                                                case 0x3:
                                                  return new LOAD_IMM_AY_PY_SN_UN_WY_SZ1(machInst, rt,
                                                                          rn, true, imm8);
                                                case 0x4:
                                                  return new LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, rt,
                                                                         rn, false, imm8);
                                                case 0x5:
                                                  return new LOAD_IMM_AN_PN_SN_UN_WY_SZ1(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x7:
                                                  return new LOAD_IMM_AY_PN_SN_UN_WY_SZ1(machInst, rt,
                                                                           rn, true, imm8);
                                              }
                                          }
                                          break;
                                        case 0x1:
                                          return new LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, rt, rn, true, imm12);
                                        case 0x2:
                                          if (op2 == 0) {
                                              return new LOAD_REG_AY_PN_SY_UN_WN_SZ1(machInst, rt, rn, true,
                                                                        imm2, LSL, rm);
                                          } else if (bits(op2, 5, 2) == 0xe) {
                                              return new LOAD_IMM_AY_PN_SY_UY_WN_SZ1(machInst, rt, rn, true, imm8);
                                          } else if ((op2 & 0x24) == 0x24 || bits(op2, 5, 2) == 0xc) {
                                              const uint32_t puw = bits(machInst, 10, 8);
                                              switch (puw) {
                                                case 0x1:
                                                  return new LOAD_IMM_AN_PY_SY_UN_WY_SZ1(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x3:
                                                  return new LOAD_IMM_AY_PY_SY_UN_WY_SZ1(machInst, rt,
                                                                           rn, true, imm8);
                                                case 0x4:
                                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ1(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x5:
                                                  return new LOAD_IMM_AN_PN_SY_UN_WY_SZ1(machInst, rt,
                                                                           rn, false, imm8);
                                                case 0x7:
                                                  return new LOAD_IMM_AY_PN_SY_UN_WY_SZ1(machInst, rt,
                                                                            rn, true, imm8);
                                              }
                                          }
                                          break;
                                        case 0x3:
                                          return new LOAD_IMM_AY_PN_SY_UN_WN_SZ1(machInst, rt, rn, true, imm12);
                                      }
                                      return new Unknown(machInst);
                                  }
                              }
                              break;
                        
                        case 0x1:  
                          // LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))
                          
                              {
                                  const uint32_t op1 = bits(machInst, 24, 23);
                                  const uint32_t op2 = bits(machInst, 11, 6);
                                  const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                                  const IntRegIndex rt = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                                  const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                  const uint32_t imm12 = bits(machInst, 11, 0);
                                  const uint32_t imm8 = bits(machInst, 7, 0);
                                  bool pldw = bits(machInst, 21);
                                  const uint32_t imm2 = bits(machInst, 5, 4);
                                  if (rn == 0xf) {
                                      if (rt == 0xf) {
                                          if (bits(op1, 1) == 1) {
                                              // Unallocated memory hint
                                              return new NopInst(machInst);
                                          } else {
                                              return new Unknown(machInst);
                                          }
                                      } else {
                                          if (bits(op1, 1) == 1) {
                                              if (bits(machInst, 23)) {
                                                  return new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, rt, INTREG_PC,
                                                                             true, imm12);
                                              } else {
                                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, rt, INTREG_PC,
                                                                           false, imm12);
                                              }
                                          } else {
                                              if (bits(machInst, 23)) {
                                                  return new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rt, INTREG_PC,
                                                                            true, imm12);
                                              } else {
                                                  return new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, rt, INTREG_PC,
                                                                          false, imm12);
                                              }
                                          }
                                      }
                                  } else if (rt == 0xf) {
                                      switch (op1) {
                                        case 0x0:
                                          if (op2 == 0x0) {
                                              if (pldw) {
                                                  return new PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           rn, true, imm2, LSL, rm);
                                              } else {
                                                  return new PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          rn, true, imm2, LSL, rm);
                                              }
                                          } else if (bits(op2, 5, 2) == 0xc) {
                                              if (pldw) {
                                                  return new PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                           rn, false, imm8);
                                              } else {
                                                  return new PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                          rn, false, imm8);
                                              }
                                          }
                                          break;
                                        case 0x1:
                                          if (pldw) {
                                              return new PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                       rn, true, imm12);
                                          } else {
                                              return new PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1(machInst, INTREG_ZERO,
                                                                      rn, true, imm12);
                                          }
                                        case 0x2:
                                          if (op2 == 0x0 || bits(op2, 5, 2) == 0xc) {
                                              // Unallocated memory hint
                                              return new NopInst(machInst);
                                          }
                                          break;
                                        case 0x3:
                                          return new NopInst(machInst);
                                      }
                                      return new Unknown(machInst);
                                  } else {
                                      switch (op1) {
                                        case 0x0:
                                          if (op2 == 0) {
                                              return new LOAD_REG_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true,
                                                                       imm2, LSL, rm);
                                          } else if (bits(op2, 5, 2) == 0xe) {
                                              return new LOAD_IMM_AY_PN_SN_UY_WN_SZ2(machInst, rt, rn, true, imm8);
                                          } else if ((op2 & 0x24) == 0x24 || bits(op2, 5, 2) == 0xc) {
                                              const uint32_t puw = bits(machInst, 10, 8);
                                              switch (puw) {
                                                case 0x1:
                                                  return new LOAD_IMM_AN_PY_SN_UN_WY_SZ2(machInst, rt,
                                                                         rn, false, imm8);
                                                case 0x3:
                                                  return new LOAD_IMM_AY_PY_SN_UN_WY_SZ2(machInst, rt,
                                                                          rn, true, imm8);
                                                case 0x4:
                                                  return new LOAD_IMM_AN_PN_SN_UN_WN_SZ2(machInst, rt,
                                                                         rn, false, imm8);
                                                case 0x5:
                                                  return new LOAD_IMM_AN_PN_SN_UN_WY_SZ2(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x7:
                                                  return new LOAD_IMM_AY_PN_SN_UN_WY_SZ2(machInst, rt,
                                                                           rn, true, imm8);
                                              }
                                          }
                                          break;
                                        case 0x1:
                                          return new LOAD_IMM_AY_PN_SN_UN_WN_SZ2(machInst, rt, rn, true, imm12);
                                        case 0x2:
                                          if (op2 == 0) {
                                              return new LOAD_REG_AY_PN_SY_UN_WN_SZ2(machInst, rt, rn, true,
                                                                        imm2, LSL, rm);
                                          } else if (bits(op2, 5, 2) == 0xe) {
                                              return new LOAD_IMM_AY_PN_SY_UY_WN_SZ2(machInst, rt, rn, true, imm8);
                                          } else if ((op2 & 0x24) == 0x24 || bits(op2, 5, 2) == 0xc) {
                                              const uint32_t puw = bits(machInst, 10, 8);
                                              switch (puw) {
                                                case 0x1:
                                                  return new LOAD_IMM_AN_PY_SY_UN_WY_SZ2(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x3:
                                                  return new LOAD_IMM_AY_PY_SY_UN_WY_SZ2(machInst, rt,
                                                                           rn, true, imm8);
                                                case 0x4:
                                                  return new LOAD_IMM_AN_PN_SY_UN_WN_SZ2(machInst, rt,
                                                                          rn, false, imm8);
                                                case 0x5:
                                                  return new LOAD_IMM_AN_PN_SY_UN_WY_SZ2(machInst, rt,
                                                                           rn, false, imm8);
                                                case 0x7:
                                                  return new LOAD_IMM_AY_PN_SY_UN_WY_SZ2(machInst, rt,
                                                                            rn, true, imm8);
                                              }
                                          }
                                          break;
                                        case 0x3:
                                          return new LOAD_IMM_AY_PN_SY_UN_WN_SZ2(machInst, rt, rn, true, imm12);
                                      }
                                      return new Unknown(machInst);
                                  }
                              }
                              break;
                        
                        case 0x2:  
                          // Thumb32LoadWord::thumb32LoadWord(([], {}))
                          
                              {
                                  uint32_t op1 = bits(machInst, 24, 23);
                                  if (bits(op1, 1) == 0) {
                                      uint32_t op2 = bits(machInst, 11, 6);
                                      if (HTRN == 0xF) {
                                          if (UP) {
                                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RT, INTREG_PC,
                                                                       true, IMMED_11_0);
                                          } else {
                                              return new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, RT, INTREG_PC,
                                                                     false, IMMED_11_0);
                                          }
                                      } else if (op1 == 0x1) {
                                          return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, true, IMMED_11_0);
                                      } else if (op2 == 0) {
                                          return new LOAD_REG_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, UP,
                                                                  bits(machInst, 5, 4), LSL, RM);
                                      } else if ((op2 & 0x3c) == 0x38) {
                                          return new LOAD_IMM_AY_PN_SN_UY_WN_SZ4(machInst, RT, RN, true, IMMED_7_0);
                                      } else if ((op2 & 0x3c) == 0x30 || //P
                                                 (op2 & 0x24) == 0x24) { //W
                                          uint32_t puw = bits(machInst, 10, 8);
                                          uint32_t imm = IMMED_7_0;
                                          switch (puw) {
                                            case 0:
                                            case 2:
                                              // If we're here, either P or W must have been set.
                                              panic("Neither P or W set, but that "
                                                      "shouldn't be possible.\n");
                                            case 1:
                                              return new LOAD_IMM_AN_PY_SN_UN_WY_SZ4(machInst, RT, RN, false, imm);
                                            case 3:
                                              return new LOAD_IMM_AY_PY_SN_UN_WY_SZ4(machInst, RT, RN, true, imm);
                                            case 4:
                                              return new LOAD_IMM_AN_PN_SN_UN_WN_SZ4(machInst, RT, RN, false, imm);
                                            case 5:
                                              return new LOAD_IMM_AN_PN_SN_UN_WY_SZ4(machInst, RT, RN, false, imm);
                                            case 6:
                                              return new LOAD_IMM_AY_PN_SN_UN_WN_SZ4(machInst, RT, RN, true, imm);
                                            case 7:
                                              return new LOAD_IMM_AY_PN_SN_UN_WY_SZ4(machInst, RT, RN, true, imm);
                                          }
                                      }
                                  } else {
                                      return new Unknown(machInst);
                                  }
                              }
                              break;
                        
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    default:
                      
                      // Unknown::unknown(([], {}))
                      return new Unknown(machInst);
                      break;
                    }
                  
                case 0x1:
                  switch (HTOPCODE_8_7) {
                    
                    case 0x2:  
                      // Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 22, 20);
                              const uint32_t op2 = bits(machInst, 5, 4);
                              const IntRegIndex ra = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                      	//const uint32_t imm5 = bits(machInst, 11, 7);
                              const ArmShiftType type = (ArmShiftType)(uint32_t)bits(machInst, 6, 5);
                              if (op1 != 0x1 && bits(op2, 1) != 0) {
                                  return new Unknown(machInst);
                              }
                              switch (op1) {
                                case 0x0:
                                  if (op2 == 0) {
                                      if (ra == 0xf) {
                      			char faults;
                      		        faults=checkFaults();
                      		  	if (faults=='a'){
                                        		return new Sdiv(machInst, rd, rm, rn);
                      		  	}else if (faults == 'f'){
                      				return new AddReg(machInst, rd, rn, rm, 0, type);
                      			}else if (faults == 'j'){
                      				return new RsbReg(machInst, rd, rn, rm, 0, type);
                      			}else{
                      				return new Mul(machInst, rd, rn, rm);
                      			}
                                      } else {
                                          return new Mla(machInst, rd, rn, rm, ra);
                                      }
                                  } else {
                                      return new Mls(machInst, rd, rn, rm, ra);
                                  }
                                case 0x1:
                                  if (ra == 0xf) {
                                      switch (bits(machInst, 5, 4)) {
                                        case 0x0:
                                          return new Smulbb(machInst, rd, rn, rm);
                                        case 0x1:
                                          return new Smulbt(machInst, rd, rn, rm);
                                        case 0x2:
                                          return new Smultb(machInst, rd, rn, rm);
                                        case 0x3:
                                          return new Smultt(machInst, rd, rn, rm);
                                      }
                                  } else {
                                      switch (bits(machInst, 5, 4)) {
                                        case 0x0:
                                          return new SmlabbCc(machInst, rd, rn, rm, ra);
                                        case 0x1:
                                          return new SmlabtCc(machInst, rd, rn, rm, ra);
                                        case 0x2:
                                          return new SmlatbCc(machInst, rd, rn, rm, ra);
                                        case 0x3:
                                          return new SmlattCc(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                case 0x2:
                                  if (ra == 0xf) {
                                      if (bits(machInst, 4)) {
                                          return new SmuadxCc(machInst, rd, rn, rm);
                                      } else {
                                          return new SmuadCc(machInst, rd, rn, rm);
                                      }
                                  } else {
                                      if (bits(machInst, 4)) {
                                          return new SmladxCc(machInst, rd, rn, rm, ra);
                                      } else {
                                          return new SmladCc(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                case 0x3:
                                  if (ra == 0xf) {
                                      if (bits(machInst, 4)) {
                                          return new Smulwt(machInst, rd, rn, rm);
                                      } else {
                                          return new Smulwb(machInst, rd, rn, rm);
                                      }
                                  } else {
                                      if (bits(machInst, 4)) {
                                          return new SmlawtCc(machInst, rd, rn, rm, ra);
                                      } else {
                                          return new SmlawbCc(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                case 0x4:
                                  if (ra == 0xf) {
                                      if (bits(machInst, 4)) {
                                          return new Smusdx(machInst, rd, rn, rm);
                                      } else {
                                          return new Smusd(machInst, rd, rn, rm);
                                      }
                                  } else {
                                      if (bits(machInst, 4)) {
                                          return new SmlsdxCc(machInst, rd, rn, rm, ra);
                                      } else {
                                          return new SmlsdCc(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                case 0x5:
                                  if (ra == 0xf) {
                                      if (bits(machInst, 4)) {
                                          return new Smmulr(machInst, rd, rn, rm);
                                      } else {
                                          return new Smmul(machInst, rd, rn, rm);
                                      }
                                  } else {
                                      if (bits(machInst, 4)) {
                                          return new Smmlar(machInst, rd, rn, rm, ra);
                                      } else {
                                          return new Smmla(machInst, rd, rn, rm, ra);
                                      }
                                  }
                                case 0x6:
                                  if (bits(machInst, 4)) {
                                      return new Smmlsr(machInst, rd, rn, rm, ra);
                                  } else {
                                      return new Smmls(machInst, rd, rn, rm, ra);
                                  }
                                case 0x7:
                                  if (op2 != 0x0) {
                                      return new Unknown(machInst);
                                  } else if (ra == 0xf) {
                                      return new Usad8(machInst, rd, rn, rm);
                                  } else {
                                      return new Usada8(machInst, rd, rn, rm, ra);
                                  }
                              }
                          }
                          break;
                    
                    case 0x3:  
                      // Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 22, 20);
                              const uint32_t op2 = bits(machInst, 7, 4);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const IntRegIndex rdlo = (IntRegIndex)(uint32_t)bits(machInst, 15, 12);
                              const IntRegIndex rdhi = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                              const IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                              switch (op1) {
                                case 0x0:
                                  if (op2 == 0x0) {
                                      return new Smull(machInst, rdlo, rdhi, rn, rm);
                                  }
                                  break;
                                case 0x1:
                                  if (op2 == 0xf) {
                      		char faults;
                      		faults=checkFaults();
                      		if (faults=='b'){
                      			return new Mul(machInst, rdhi, rn, rm);
                      		}else{
                                      	return new Sdiv(machInst, rdhi, rn, rm);
                      		}
                                  }
                                  break;
                                case 0x2:
                                  if (op2 == 0x0) {
                                      return new Umull(machInst, rdlo, rdhi, rn, rm);
                                  }
                                  break;
                                case 0x3:
                                  if (op2 == 0xf) {
                                      return new Udiv(machInst, rdhi, rn, rm);
                                  }
                                  break;
                                case 0x4:
                                  if (op2 == 0) {
                                      return new Smlal(machInst, rdlo, rdhi, rn, rm);
                                  } else if (bits(op2, 3, 2) == 0x2) {
                                      switch (bits(machInst, 5, 4)) {
                                        case 0x0:
                                          return new Smlalbb(machInst, rdlo, rdhi, rn, rm);
                                        case 0x1:
                                          return new Smlalbt(machInst, rdlo, rdhi, rn, rm);
                                        case 0x2:
                                          return new Smlaltb(machInst, rdlo, rdhi, rn, rm);
                                        case 0x3:
                                          return new Smlaltt(machInst, rdlo, rdhi, rn, rm);
                                      }
                                  } else if (bits(op2, 3, 1) == 0x6) {
                                      if (bits(machInst, 4)) {
                                          return new Smlaldx(machInst, rdlo, rdhi, rn, rm);
                                      } else {
                                          return new Smlald(machInst, rdlo, rdhi, rn, rm);
                                      }
                                  }
                                  break;
                                case 0x5:
                                  if (bits(op2, 3, 1) == 0x6) {
                                      if (bits(machInst, 4)) {
                                          return new Smlsldx(machInst, rdlo, rdhi, rn, rm);
                                      } else {
                                          return new Smlsld(machInst, rdlo, rdhi, rn, rm);
                                      }
                                  }
                                  break;
                                case 0x6:
                                  if (op2 == 0) {
                                      return new Umlal(machInst, rdlo, rdhi, rn, rm);
                                  } else if (op2 == 0x6) {
                                      return new Umaal(machInst, rdlo, rdhi, rn, rm);
                                  }
                                  break;
                              }
                              return new Unknown(machInst);
                          }
                          break;
                    
                    default:  
                      // Thumb32DataProcReg::thumb32DataProcReg(([], {}))
                      
                          {
                              const uint32_t op1 = bits(machInst, 23, 20);
                              const IntRegIndex rn = (IntRegIndex)(uint32_t)bits(machInst, 19, 16);
                              const uint32_t op2 = bits(machInst, 7, 4);
                              if (bits(machInst, 15, 12) != 0xf) {
                                  return new Unknown(machInst);
                              }
                              if (bits(op1, 3) != 1) {
                                  if (op2 == 0) {
                                      IntRegIndex rd = (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                      IntRegIndex rm = (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      switch (bits(op1, 2, 0)) {
                                        case 0x0:
                                          return new MovRegReg(machInst, rd,
                                                  INTREG_ZERO, rn, rm, LSL);
                                        case 0x1:
                                          return new MovRegRegCc(machInst, rd,
                                                  INTREG_ZERO, rn, rm, LSL);
                                        case 0x2:
                                          return new MovRegReg(machInst, rd,
                                                  INTREG_ZERO, rn, rm, LSR);
                                        case 0x3:
                                          return new MovRegRegCc(machInst, rd,
                                                  INTREG_ZERO, rn, rm, LSR);
                                        case 0x4:
                                          return new MovRegReg(machInst, rd,
                                                  INTREG_ZERO, rn, rm, ASR);
                                        case 0x5:
                                          return new MovRegRegCc(machInst, rd,
                                                  INTREG_ZERO, rn, rm, ASR);
                                        case 0x6:
                                          return new MovRegReg(machInst, rd,
                                                  INTREG_ZERO, rn, rm, ROR);
                                        case 0x7:
                                          return new MovRegRegCc(machInst, rd,
                                                  INTREG_ZERO, rn, rm, ROR);
                                      }
                                  } else if (bits(op2, 3) == 0) {
                                      return new Unknown(machInst);
                                  } else {
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      const uint32_t rotation =
                                          (uint32_t)bits(machInst, 5, 4) << 3;
                                      switch (bits(op1, 2, 0)) {
                                        case 0x0:
                                          if (rn == 0xf) {
                                              return new Sxth(machInst, rd, rotation, rm);
                                          } else {
                                              return new Sxtah(machInst, rd, rn, rm, rotation);
                                          }
                                        case 0x1:
                                          if (rn == 0xf) {
                                              return new Uxth(machInst, rd, rotation, rm);
                                          } else {
                                              return new Uxtah(machInst, rd, rn, rm, rotation);
                                          }
                                        case 0x2:
                                          if (rn == 0xf) {
                                              return new Sxtb16(machInst, rd, rotation, rm);
                                          } else {
                                              return new Sxtab16(machInst, rd, rn, rm, rotation);
                                          }
                                        case 0x3:
                                          if (rn == 0xf) {
                                              return new Uxtb16(machInst, rd, rotation, rm);
                                          } else {
                                              return new Uxtab16(machInst, rd, rn, rm, rotation);
                                          }
                                        case 0x4:
                                          if (rn == 0xf) {
                                              return new Sxtb(machInst, rd, rotation, rm);
                                          } else {
                                              return new Sxtab(machInst, rd, rn, rm, rotation);
                                          }
                                        case 0x5:
                                          if (rn == 0xf) {
                                              return new Uxtb(machInst, rd, rotation, rm);
                                          } else {
                                              return new Uxtab(machInst, rd, rn, rm, rotation);
                                          }
                                        default:
                                          return new Unknown(machInst);
                                      }
                                  }
                              } else {
                                  if (bits(op2, 3) == 0) {
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      if (bits(op2, 2) == 0x0) {
                                          const uint32_t op1 = bits(machInst, 22, 20);
                                          const uint32_t op2 = bits(machInst, 5, 4);
                                          switch (op2) {
                                            case 0x0:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Sadd16RegCc(machInst, rd,
                                                                         rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new SasxRegCc(machInst, rd,
                                                                       rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new SsaxRegCc(machInst, rd,
                                                                       rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Ssub16RegCc(machInst, rd,
                                                                         rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Sadd8RegCc(machInst, rd,
                                                                        rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Ssub8RegCc(machInst, rd,
                                                                        rn, rm, 0, LSL);
                                              }
                                              break;
                                            case 0x1:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Qadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new QasxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new QsaxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Qsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Qadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Qsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                              }
                                              break;
                                            case 0x2:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Shadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new ShasxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new ShsaxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Shsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Shadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Shsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                              }
                                              break;
                                          }
                                      } else {
                                          const uint32_t op1 = bits(machInst, 22, 20);
                                          const uint32_t op2 = bits(machInst, 5, 4);
                                          switch (op2) {
                                            case 0x0:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Uadd16RegCc(machInst, rd,
                                                                         rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new UasxRegCc(machInst, rd,
                                                                       rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new UsaxRegCc(machInst, rd,
                                                                       rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Usub16RegCc(machInst, rd,
                                                                         rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Uadd8RegCc(machInst, rd,
                                                                        rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Usub8RegCc(machInst, rd,
                                                                        rn, rm, 0, LSL);
                                              }
                                              break;
                                            case 0x1:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Uqadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new UqasxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new UqsaxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Uqsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Uqadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Uqsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                              }
                                              break;
                                            case 0x2:
                                              switch (op1) {
                                                case 0x1:
                                                  return new Uhadd16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x2:
                                                  return new UhasxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x6:
                                                  return new UhsaxReg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x5:
                                                  return new Uhsub16Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x0:
                                                  return new Uhadd8Reg(machInst, rd, rn, rm, 0, LSL);
                                                case 0x4:
                                                  return new Uhsub8Reg(machInst, rd, rn, rm, 0, LSL);
                                              }
                                              break;
                                          }
                                      }
                                  } else if (bits(op1, 3, 2) == 0x2 && bits(op2, 3, 2) == 0x2) {
                                      const uint32_t op1 = bits(machInst, 21, 20);
                                      const uint32_t op2 = bits(machInst, 5, 4);
                                      const IntRegIndex rd =
                                          (IntRegIndex)(uint32_t)bits(machInst, 11, 8);
                                      const IntRegIndex rm =
                                          (IntRegIndex)(uint32_t)bits(machInst, 3, 0);
                                      switch (op1) {
                                        case 0x0:
                                          switch (op2) {
                                            case 0x0:
                                            	return new QaddRegCc(machInst, rd,
                                                                   rm, rn, 0, LSL);
                                            case 0x1:
                                              	return new QdaddRegCc(machInst, rd,
                                                                    rm, rn, 0, LSL);
                                            case 0x2:
                                              return new QsubRegCc(machInst, rd,
                                                                   rm, rn, 0, LSL);
                                            case 0x3:
                                              return new QdsubRegCc(machInst, rd,
                                                                    rm, rn, 0, LSL);
                                          }
                                          break;
                                        case 0x1:
                                          switch (op2) {
                                            case 0x0:
                                              return new Rev(machInst, rd, rn);
                                            case 0x1:
                                              return new Rev16(machInst, rd, rn);
                                            case 0x2:
                                              return new Rbit(machInst, rd, rm);
                                            case 0x3:
                                              return new Revsh(machInst, rd, rn);
                                          }
                                          break;
                                        case 0x2:
                                          if (op2 == 0) {
                                              return new Sel(machInst, rd, rn, rm);
                                          }
                                          break;
                                        case 0x3:
                                          if (op2 == 0) {
                                              return new Clz(machInst, rd, rm);
                                          }
                                      }
                                  }
                                  return new Unknown(machInst);
                              }
                          }
                          break;
                    }
                  
                default:
                  switch (HTOPCODE_9_8) {
                    
                    case 0x2:
                      switch (LTOPCODE_4) {
                        
                        case 0x0:
                          switch (LTCOPROC) {
                            
                            case 0xa: case 0xb:  
                              // VfpData::vfpData(([], {}))
                              
                                  return decodeVfpData(machInst);
                                  break;
                            
                            default:  
                              // WarnUnimpl::cdp(([], {}))
                              
                                      return new WarnUnimplemented("cdp", machInst);
                              break;
                            }
                          
                        case 0x1:
                          switch (LTCOPROC) {
                            
                            case 0x1:  
                              // M5ops::m5ops(([], {}))
                              
                                  {
                                      const uint32_t m5func = bits(machInst, 23, 16);
                                      switch(m5func) {
                                          case 0x00: return new Arm(machInst);
                                          case 0x01: return new Quiesce(machInst);
                                          case 0x02: return new QuiesceNs(machInst);
                                          case 0x03: return new QuiesceCycles(machInst);
                                          case 0x04: return new QuiesceTime(machInst);
                                          case 0x07: return new Rpns(machInst);
                                          case 0x09: return new WakeCPU(machInst);
                                          case 0x10: return new Deprecated_ivlb(machInst);
                                          case 0x11: return new Deprecated_ivle(machInst);
                                          case 0x20: return new Deprecated_exit (machInst);
                                          case 0x21: return new M5exit(machInst);
                                          case 0x22: return new M5fail(machInst);
                                          case 0x31: return new Loadsymbol(machInst);
                                          case 0x30: return new Initparam(machInst);
                                          case 0x40: return new Resetstats(machInst);
                                          case 0x41: return new Dumpstats(machInst);
                                          case 0x42: return new Dumpresetstats(machInst);
                                          case 0x43: return new M5checkpoint(machInst);
                                          case 0x4F: return new M5writefile(machInst);
                                          case 0x50: return new M5readfile(machInst);
                                          case 0x51: return new M5break(machInst);
                                          case 0x52: return new M5switchcpu(machInst);
                                          case 0x53: return new M5addsymbol(machInst);
                                          case 0x54: return new M5panic(machInst);
                                          case 0x5a: return new M5workbegin(machInst);
                                          case 0x5b: return new M5workend(machInst);
                                      }
                                 }
                                 break;
                            
                            case 0xa: case 0xb:  
                              // ShortFpTransfer::shortFpTransfer(([], {}))
                              
                                  return decodeShortFpTransfer(machInst);
                                  break;
                            
                            case 0xe:  
                              // McrMrc14::mcrMrc14(([], {}))
                              
                                  return decodeMcrMrc14(machInst);
                                  break;
                            
                            case 0xf:  
                              // McrMrc15::mcrMrc15(([], {}))
                              
                                  return decodeMcrMrc15(machInst);
                                  break;
                            
                            default:
                              
                              // Unknown::unknown(([], {}))
                              return new Unknown(machInst);
                              break;
                            }
                          
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      
                    case 0x3:  
                      // ThumbNeonData::thumbNeonData(([], {}))
                      
                          return decodeNeonData(machInst);
                          break;
                    
                    default:
                      switch (LTCOPROC) {
                        
                        case 0xa: case 0xb:  
                          // ExtensionRegLoadStore::extensionRegLoadStre(([], {}))
                          
                              return decodeExtensionRegLoadStore(machInst);
                              break;
                        
                        case 0xf:
                          switch (HTOPCODE_9_4) {
                            
                            case 0x0:  
                              // Unknown::undefined(([], {}))
                              return new Unknown(machInst);
                              break;
                            
                            case 0x4:  
                              // WarnUnimpl::mcrr(([], {}))
                              
                                      return new WarnUnimplemented("mcrr", machInst);
                              break;
                            
                            case 0x5:  
                              // WarnUnimpl::mrrc(([], {}))
                              
                                      return new WarnUnimplemented("mrrc", machInst);
                              break;
                            
                            case 0x2: case 0x6: case 0x8: case 0xa: case 0xc: case 0xe: case 0x10: case 0x12: case 0x14: case 0x16: case 0x18: case 0x1a: case 0x1c: case 0x1e:  
                              // WarnUnimpl::stc(([], {}))
                              
                                      return new WarnUnimplemented("stc", machInst);
                              break;
                            
                            case 0x3: case 0x7: case 0x9: case 0xb: case 0xd: case 0xf: case 0x11: case 0x13: case 0x15: case 0x17: case 0x19: case 0x1b: case 0x1d: case 0x1f:
                              switch (HTRN) {
                                
                                case 0xf:  
                                  // WarnUnimpl::ldc(([], {}))
                                  
                                          return new WarnUnimplemented("ldc", machInst);
                                  break;
                                
                                default:  
                                  // WarnUnimpl::ldc(([], {}))
                                  
                                          return new WarnUnimplemented("ldc", machInst);
                                  break;
                                }
                              
                            default:
                              
                              // Unknown::unknown(([], {}))
                              return new Unknown(machInst);
                              break;
                            }
                          
                        default:
                          
                          // Unknown::unknown(([], {}))
                          return new Unknown(machInst);
                          break;
                        }
                      }
                  }
              
            default:
              
              // Unknown::unknown(([], {}))
              return new Unknown(machInst);
              break;
            }
          
        default:
          
          // Unknown::unknown(([], {}))
          return new Unknown(machInst);
          break;
        }
      
    default:
      
      // Unknown::unknown(([], {}))
      return new Unknown(machInst);
      break;
    }
  }
