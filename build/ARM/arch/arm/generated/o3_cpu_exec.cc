
/*
 * DO NOT EDIT THIS FILE!!!
 *
 * It was automatically generated from the ISA description in arm/isa/main.isa
 */

#include "decoder.hh"
#include "cpu/o3/isa_specific.hh"


#include <cmath>
#include "cpu/simple/atomic.hh"
#include "arch/arm/faults.hh"
#include "arch/arm/isa_traits.hh"
#include "arch/arm/utility.hh"
#include "arch/generic/memhelpers.hh"
#include "base/condcodes.hh"
#include "sim/pseudo_inst.hh"
#if defined(linux)
#include <fenv.h>
#endif

#include "base/cp_annotate.hh"
#include "debug/Arm.hh"
#include "mem/packet.hh"
#include "mem/packet_access.hh"
#include "sim/sim_exit.hh"

using namespace ArmISA;



namespace ArmISAInst {


    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PY_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PY_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PY_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PY_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AY_PN_SY_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AY_PN_SY_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMM_AN_PN_SY_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
int16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REG_AN_PN_SY_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
int16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LOAD_REGD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + 0;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + 0;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + 0;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + 0;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PY_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + -4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + -4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + -4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + -4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PY_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + 4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + 4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + 4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + 4;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AY_PN_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + -8;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + -8;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;
        EA = Base + -8;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + -8;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URc = 0;
uint32_t URa = 0;
uint64_t Mem = 0;
uint32_t URb = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
CondCodesNZ = xc->readIntRegOperand(this, 2);
CondCodesC = xc->readIntRegOperand(this, 3);
CondCodesV = xc->readIntRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            cpsr.nz = CondCodesNZ;
            cpsr.c = CondCodesC;
            cpsr.v = CondCodesV;
            cpsr.ge = CondCodesGE;
            URc = cpsr;
            URa = cSwap<uint32_t>(Mem, cpsr.e);
            URb = cSwap<uint32_t>(Mem >> 32, cpsr.e);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = URc;
            
        ((urc == PCReg) ? setNextPC(xc, URc) :
         xc->setIntRegOperand(this, 0, URc))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 1, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = URb;
            
        ((urb == PCReg) ? setNextPC(xc, URb) :
         xc->setIntRegOperand(this, 2, URb))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault RFE_LOAD_IMM_AN_PN_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_REG_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_REG_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLD_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_REG_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLDW_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_REG_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::PREFETCH;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PLI_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                uint64_t temp = Mem; temp = temp;;
            }

            if (fault == NoFault) {
                ;
            }
        }

        return fault;
    }

    Fault LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREX_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXH_LOAD_IMM_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint16_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXB_LOAD_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWDest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWDest = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWDest;
            
        ((dest == PCReg) ? setIWNextPC(xc, IWDest) :
         xc->setIntRegOperand(this, 0, IWDest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|Request::LLSC|ArmISA::TLB::AlignDoubleWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|Request::LLSC|ArmISA::TLB::AlignDoubleWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault LDREXD_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Mem = 0;
uint32_t Dest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Dest = cSwap<uint32_t>(Mem, cpsr.e);
                Dest2 = cSwap<uint32_t>(Mem >> 32, cpsr.e);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest2;
            
        ((dest2 == PCReg) ? setNextPC(xc, Dest2) :
         xc->setIntRegOperand(this, 1, Dest2))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                FpDest = cSwap(Mem, ((CPSR)Cpsr).e);
;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                FpDest = cSwap(Mem, ((CPSR)Cpsr).e);
;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                FpDest = cSwap(Mem, ((CPSR)Cpsr).e);
;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMM_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                FpDest = cSwap(Mem, ((CPSR)Cpsr).e);
;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint64_t Mem = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                uint64_t swappedMem = cSwap(Mem, ((CPSR)Cpsr).e);
                FpDest = (uint32_t)swappedMem;
                FpDest2 = (uint32_t)(swappedMem >> 32);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDest2;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                uint64_t swappedMem = cSwap(Mem, ((CPSR)Cpsr).e);
                FpDest = (uint32_t)swappedMem;
                FpDest2 = (uint32_t)(swappedMem >> 32);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDest2;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint64_t Mem = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
                uint64_t swappedMem = cSwap(Mem, ((CPSR)Cpsr).e);
                FpDest = (uint32_t)swappedMem;
                FpDest2 = (uint32_t)(swappedMem >> 32);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDest2;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VLDR_LOAD_IMMD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
                uint64_t swappedMem = cSwap(Mem, ((CPSR)Cpsr).e);
                FpDest = (uint32_t)swappedMem;
                FpDest2 = (uint32_t)(swappedMem >> 32);
                ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDest2;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault Svc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    if (FullSystem) {
        fault = new SupervisorCall;
    } else {
        fault = new SupervisorCall(machInst);
    }
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MrsCpsr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t Dest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
CondCodesGE = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            
        CPSR cpsr = Cpsr;
        cpsr.nz = CondCodesNZ;
        cpsr.c = CondCodesC;
        cpsr.v = CondCodesV;
        cpsr.ge = CondCodesGE;
        Dest = cpsr & 0xF8FF03DF
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MrsSpsr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Spsr = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Spsr = xc->readMiscRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = Spsr;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MsrCpsrReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t Sctlr = 0;
uint32_t CondCodesGE = 0;
uint32_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            
        SCTLR sctlr = Sctlr;
        CPSR old_cpsr = Cpsr;
        old_cpsr.nz = CondCodesNZ;
        old_cpsr.c = CondCodesC;
        old_cpsr.v = CondCodesV;
        old_cpsr.ge = CondCodesGE;
        CPSR new_cpsr =
            cpsrWriteByInstr(old_cpsr, Op1, byteMask, false, sctlr.nmfi);
        Cpsr = ~CondCodesMask & new_cpsr;
        CondCodesNZ = new_cpsr.nz;
        CondCodesC = new_cpsr.c;
        CondCodesV = new_cpsr.v;
        CondCodesGE = new_cpsr.ge;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MsrSpsrReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Spsr = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Spsr = xc->readMiscRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Spsr = spsrWriteByInstr(Spsr, Op1, byteMask, false);;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Spsr);
if (traceData) { traceData->setData(Spsr); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MsrCpsrImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t Sctlr = 0;
uint32_t CondCodesGE = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
CondCodesGE = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            
        SCTLR sctlr = Sctlr;
        CPSR old_cpsr = Cpsr;
        old_cpsr.nz = CondCodesNZ;
        old_cpsr.c = CondCodesC;
        old_cpsr.v = CondCodesV;
        old_cpsr.ge = CondCodesGE;
        CPSR new_cpsr =
            cpsrWriteByInstr(old_cpsr, imm, byteMask, false, sctlr.nmfi);
        Cpsr = ~CondCodesMask & new_cpsr;
        CondCodesNZ = new_cpsr.nz;
        CondCodesC = new_cpsr.c;
        CondCodesV = new_cpsr.v;
        CondCodesGE = new_cpsr.ge;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MsrSpsrImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Spsr = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Spsr = xc->readMiscRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Spsr = spsrWriteByInstr(Spsr, imm, byteMask, false);;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Spsr);
if (traceData) { traceData->setData(Spsr); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Rev::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t val = Op1;
    Dest = swap_byte(val);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Rev16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t val = Op1;
    Dest = (bits(val, 15, 8) << 0) |
           (bits(val, 7, 0) << 8) |
           (bits(val, 31, 24) << 16) |
           (bits(val, 23, 16) << 24);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Revsh::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint16_t val = Op1;
    Dest = sext<16>(swap_byte(val));
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Rbit::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint8_t *opBytes = (uint8_t *)&Op1;
    uint32_t resTemp;
    uint8_t *destBytes = (uint8_t *)&resTemp;
    // This reverses the bytes and bits of the input, or so says the
    // internet.
    for (int i = 0; i < 4; i++) {
        uint32_t temp = opBytes[i];
        temp = (temp * 0x0802 & 0x22110) | (temp * 0x8020 & 0x88440);
        destBytes[3 - i] = (temp * 0x10101) >> 16;
    }
    Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Clz::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        Dest = (Op1 == 0) ? 32 : (31 - findMsbSet(Op1));
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Ssat::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        int32_t operand = shift_rm_imm(Op1, shiftAmt, shiftType, 0);
        int32_t res;
        if (satInt(res, operand, imm))
            CpsrQ = 1 << 27;
        Dest = res;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usat::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        int32_t operand = shift_rm_imm(Op1, shiftAmt, shiftType, 0);
        int32_t res;
        if (uSatInt(res, operand, imm))
            CpsrQ = 1 << 27;
        Dest = res;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Ssat16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        int32_t res;
        uint32_t resTemp = 0;
        int32_t argLow = sext<16>(bits(Op1, 15, 0));
        int32_t argHigh = sext<16>(bits(Op1, 31, 16));
        if (satInt(res, argLow, imm))
            CpsrQ = 1 << 27;
        replaceBits(resTemp, 15, 0, res);
        if (satInt(res, argHigh, imm))
            CpsrQ = 1 << 27;
        replaceBits(resTemp, 31, 16, res);
        Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usat16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        int32_t res;
        uint32_t resTemp = 0;
        int32_t argLow = sext<16>(bits(Op1, 15, 0));
        int32_t argHigh = sext<16>(bits(Op1, 31, 16));
        if (uSatInt(res, argLow, imm))
            CpsrQ = 1 << 27;
        replaceBits(resTemp, 15, 0, res);
        if (uSatInt(res, argHigh, imm))
            CpsrQ = 1 << 27;
        replaceBits(resTemp, 31, 16, res);
        Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxtb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = sext<8>((uint8_t)(Op1 >> imm));;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxtab::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Op2 = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
                                   Dest = sext<8>((uint8_t)(Op2 >> imm)) +
                                          Op1;
                               ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxtb16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t resTemp = 0;
    replaceBits(resTemp, 15, 0, sext<8>(bits(Op1, imm + 7, imm)));
    replaceBits(resTemp, 31, 16,
                sext<8>(bits(Op1, (imm + 23) % 32, (imm + 16) % 32)));
    Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxtab16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t resTemp = 0;
    replaceBits(resTemp, 15, 0, sext<8>(bits(Op2, imm + 7, imm)) +
                                        bits(Op1, 15, 0));
    replaceBits(resTemp, 31, 16,
                sext<8>(bits(Op2, (imm + 23) % 32, (imm + 16) % 32)) +
                bits(Op1, 31, 16));
    Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxth::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t rotated = (uint32_t)Op1;
    rotated = (rotated | (rotated << 32)) >> imm;
    Dest = sext<16>((uint16_t)rotated);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sxtah::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t rotated = (uint32_t)Op2;
    rotated = (rotated | (rotated << 32)) >> imm;
    Dest = sext<16>((uint16_t)rotated) + Op1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxtb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = (uint8_t)(Op1 >> imm);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxtab::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint64_t Op2 = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = (uint8_t)(Op2 >> imm) + Op1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxtb16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t resTemp = 0;
    replaceBits(resTemp, 15, 0, (uint8_t)(bits(Op1, imm + 7, imm)));
    replaceBits(resTemp, 31, 16,
                (uint8_t)(bits(Op1, (imm + 23) % 32, (imm + 16) % 32)));
    Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxtab16::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t resTemp = 0;
    replaceBits(resTemp, 15, 0, (uint8_t)(bits(Op2, imm + 7, imm)) +
                                        bits(Op1, 15, 0));
    replaceBits(resTemp, 31, 16,
                (uint8_t)(bits(Op2, (imm + 23) % 32, (imm + 16) % 32)) +
                bits(Op1, 31, 16));
    Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxth::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t rotated = (uint32_t)Op1;
    rotated = (rotated | (rotated << 32)) >> imm;
    Dest = (uint16_t)rotated;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uxtah::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t rotated = (uint32_t)Op2;
    rotated = (rotated | (rotated << 32)) >> imm;
    Dest = (uint16_t)rotated + Op1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sel::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
CondCodesGE = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        uint32_t resTemp = 0;
        for (unsigned i = 0; i < 4; i++) {
            int low = i * 8;
            int high = low + 7;
            replaceBits(resTemp, high, low,
                        bits(CondCodesGE, i) ?
                            bits(Op1, high, low) : bits(Op2, high, low));
        }
        Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usad8::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        uint32_t resTemp = 0;
        for (unsigned i = 0; i < 4; i++) {
            int low = i * 8;
            int high = low + 7;
            int32_t diff = bits(Op1, high, low) -
                           bits(Op2, high, low);
            resTemp += ((diff < 0) ? -diff : diff);
        }
        Dest = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usada8::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t Op3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op3 = 
        ((op3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        uint32_t resTemp = 0;
        for (unsigned i = 0; i < 4; i++) {
            int low = i * 8;
            int high = low + 7;
            int32_t diff = bits(Op1, high, low) -
                           bits(Op2, high, low);
            resTemp += ((diff < 0) ? -diff : diff);
        }
        Dest = Op3 + resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

        Fault BkptInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
        {
                Fault fault = NoFault;

                uint32_t PC;
TheISA::PCState __parserAutoPCState;
;
                __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
;
                return new PrefetchAbort(PC, ArmFault::DebugEvent);
;

                if (fault == NoFault)
                {
                    ;
                }
                return fault;
        }

    Fault NopInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault YieldInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault WfeInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SevMailbox = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SevMailbox = xc->readMiscRegOperand(this, 0);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    // WFE Sleeps if SevMailbox==0 and no unmasked interrupts are pending
    if (SevMailbox == 1) {
        SevMailbox = 0;
        PseudoInst::quiesceSkip(xc->tcBase());
    } else if (xc->tcBase()->getCpuPtr()->getInterruptController()->checkInterrupts(xc->tcBase())) {
        PseudoInst::quiesceSkip(xc->tcBase());
    } else {
        PseudoInst::quiesce(xc->tcBase());
    }
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
            
    // WFE is predicated false, reset SevMailbox to reduce spurious sleeps
    // and SEV interrupts
    SevMailbox = 1;
    ;
            PseudoInst::quiesceSkip(xc->tcBase());
        }

        return fault;
    }

    Fault WfiInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    // WFI doesn't sleep if interrupts are pending (masked or not)
    if (xc->tcBase()->getCpuPtr()->getInterruptController()->checkRaw()) {
        PseudoInst::quiesceSkip(xc->tcBase());
    } else {
        PseudoInst::quiesce(xc->tcBase());
    }
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
            PseudoInst::quiesceSkip(xc->tcBase());
        }

        return fault;
    }

    Fault SevInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SevMailbox = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    SevMailbox = 1;
    System *sys = xc->tcBase()->getSystemPtr();
    for (int x = 0; x < sys->numContexts(); x++) {
        ThreadContext *oc = sys->getThreadContext(x);
        if (oc == xc->tcBase())
            continue;
        // Wake CPU with interrupt if they were sleeping
        if (oc->readMiscReg(MISCREG_SEV_MAILBOX) == 0) {
            // Post Interrupt and wake cpu if needed
            oc->getCpuPtr()->postInterrupt(INT_SEV, 0);
        }
    }
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault ItInst::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            ;;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Unknown::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    if (FullSystem)
        return new UndefinedInstruction;
    else
        return new UndefinedInstruction(machInst, true);
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Ubfx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        Dest = bits(Op1, imm2, imm1);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sbfx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        int32_t resTemp = bits(Op1, imm2, imm1);
        Dest = resTemp | -(resTemp & (1 << (imm2 - imm1)));
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Bfc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        Dest = Op1 & ~(mask(imm2 - imm1 + 1) << imm1);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Bfi::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        uint32_t bitMask = (mask(imm2 - imm1 + 1) << imm1);
        Dest = ((Op1 << imm1) & bitMask) | (Dest & ~bitMask);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mrc14::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t MiscOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
MiscOp1 = xc->readMiscRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    CPSR cpsr = Cpsr;
    if (cpsr.mode == MODE_USER) {
        if (FullSystem)
            return new UndefinedInstruction;
        else
            return new UndefinedInstruction(false, mnemonic);
    }
    Dest = MiscOp1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mcr14::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t MiscDest = 0;
uint32_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    CPSR cpsr = Cpsr;
    if (cpsr.mode == MODE_USER) {
        if (FullSystem)
            return new UndefinedInstruction;
        else
            return new UndefinedInstruction(false, mnemonic);
    }
    MiscDest = Op1;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, MiscDest);
if (traceData) { traceData->setData(MiscDest); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mrc14User::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t MiscOp1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
MiscOp1 = xc->readMiscRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = MiscOp1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mcr14User::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t MiscDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MiscDest = Op1;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, MiscDest);
if (traceData) { traceData->setData(MiscDest); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mrc15::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t MiscOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
MiscOp1 = xc->readMiscRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    CPSR cpsr = Cpsr;
    if (cpsr.mode == MODE_USER) {
        if (FullSystem)
            return new UndefinedInstruction;
        else
            return new UndefinedInstruction(false, mnemonic);
    }
    Dest = MiscOp1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mcr15::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t MiscDest = 0;
uint32_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    CPSR cpsr = Cpsr;
    if (cpsr.mode == MODE_USER) {
        if (FullSystem)
            return new UndefinedInstruction;
        else
            return new UndefinedInstruction(false, mnemonic);
    }
    MiscDest = Op1;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, MiscDest);
if (traceData) { traceData->setData(MiscDest); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mrc15User::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t MiscOp1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
MiscOp1 = xc->readMiscRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            Dest = MiscOp1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mcr15User::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t MiscDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MiscDest = Op1;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, MiscDest);
if (traceData) { traceData->setData(MiscDest); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Enterx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        NextThumb = true;
        NextJazelle = true;
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Leavex::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        NextThumb = true;
        NextJazelle = false;
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Setend::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        CPSR cpsr = Cpsr;
        cpsr.e = imm;
        Cpsr = cpsr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Clrex::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t LLSCLock = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        LLSCLock = 0;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, LLSCLock);
if (traceData) { traceData->setData(LLSCLock); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Isb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        fault = new FlushPipe;
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Dsb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        fault = new FlushPipe;
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Dmb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Dbg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Cps::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Sctlr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint32_t mode = bits(imm, 4, 0);
    uint32_t f = bits(imm, 5);
    uint32_t i = bits(imm, 6);
    uint32_t a = bits(imm, 7);
    bool setMode = bits(imm, 8);
    bool enable = bits(imm, 9);
    CPSR cpsr = Cpsr;
    SCTLR sctlr = Sctlr;
    if (cpsr.mode != MODE_USER) {
        if (enable) {
            if (f) cpsr.f = 0;
            if (i) cpsr.i = 0;
            if (a) cpsr.a = 0;
        } else {
            if (f && !sctlr.nmfi) cpsr.f = 1;
            if (i) cpsr.i = 1;
            if (a) cpsr.a = 1;
        }
        if (setMode) {
            cpsr.mode = mode;
        }
    }
    Cpsr = cpsr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PY_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WY_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AY_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AY_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMM_AN_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|ArmISA::TLB::UserMode|ArmISA::TLB::AllowUnaligned;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REG_AN_PN_SN_UY_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 0;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 0;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 0;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 0;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PY_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PY_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + 4;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AY_PN_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -8;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -8;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WY_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -8;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t SpMode = 0;
uint64_t Mem = 0;
uint32_t LR = 0;
uint32_t Spsr = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
SpMode = xc->readIntRegOperand(this, 6);
LR = xc->readIntRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = SpMode + -8;
    unsigned memAccessFlags = ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
            CPSR cpsr = Cpsr;
            Mem = (uint64_t)cSwap(LR, cpsr.e) |
                     ((uint64_t)cSwap(Spsr, cpsr.e) << 32);
            ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SRS_STORE_IMM_AN_PN_SN_UN_WN_SZ8::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PY_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4Acc::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        panic("Execute function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("InitiateAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WY_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        panic("CompleteAcc function executed when it shouldn't be!\n");
        return NoFault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_IMMD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Index = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Index = 
        ((index == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base - shift_rm_imm(Index, shiftAmt, shiftType, OptShiftRmCondCodesC);
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STORE_REGD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            uint64_t writeResult;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &writeResult);
            }

            if (fault == NoFault) {
                Result = !writeResult;;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Mem = 0;
uint32_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREX_STORE_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            uint64_t writeResult = pkt->req->getExtraData();
            Result = !writeResult;;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            uint64_t writeResult;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &writeResult);
            }

            if (fault == NoFault) {
                Result = !writeResult;;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
uint16_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|1|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXH_STORE_IMM_AY_PN_SN_UN_WN_SZ2::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            uint64_t writeResult = pkt->req->getExtraData();
            Result = !writeResult;;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            uint64_t writeResult;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &writeResult);
            }

            if (fault == NoFault) {
                Result = !writeResult;;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
uint8_t Dest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|0|Request::LLSC;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(Dest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXB_STORE_IMM_AY_PN_SN_UN_WN_SZ1::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            uint64_t writeResult = pkt->req->getExtraData();
            Result = !writeResult;;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|Request::LLSC|ArmISA::TLB::AlignDoubleWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            uint64_t writeResult;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &writeResult);
            }

            if (fault == NoFault) {
                Result = !writeResult;;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Mem = 0;
uint32_t Dest = 0;
uint32_t Dest2 = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Dest = 
        ((dest == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Dest2 = 
        ((dest2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base + imm;
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|Request::LLSC|ArmISA::TLB::AlignDoubleWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                CPSR cpsr = Cpsr;
                Mem = (uint64_t)cSwap(Dest, cpsr.e) |
                         ((uint64_t)cSwap(Dest2, cpsr.e) << 32);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault STREXD_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Result = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            uint64_t writeResult = pkt->req->getExtraData();
            Result = !writeResult;;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Result;
            
        ((result == PCReg) ? setNextPC(xc, Result) :
         xc->setIntRegOperand(this, 0, Result))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
uint32_t FpDest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 6);
Fpexc = xc->readMiscRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 5);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(FpDest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
uint32_t FpDest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 6);
Fpexc = xc->readMiscRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 5);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(FpDest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMM_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
uint32_t FpDest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 6);
Fpexc = xc->readMiscRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 5);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(FpDest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Mem = 0;
uint32_t FpDest = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 6);
Fpexc = xc->readMiscRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 5);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|3;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                Mem = cSwap(FpDest, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMM_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 7);
Fpexc = xc->readMiscRegOperand(this, 8);
FpDest = xc->readFloatRegOperandBits(this, 5);
FpDest2 = xc->readFloatRegOperandBits(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                uint64_t swappedMem  = (uint64_t)FpDest |
                                       ((uint64_t)FpDest2 << 32);
                Mem = cSwap(swappedMem, ((CPSR)Cpsr).e);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 7);
Fpexc = xc->readMiscRegOperand(this, 8);
FpDest = xc->readFloatRegOperandBits(this, 5);
FpDest2 = xc->readFloatRegOperandBits(this, 6);
;
        EA = Base + imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                uint64_t swappedMem  = (uint64_t)FpDest |
                                       ((uint64_t)FpDest2 << 32);
                Mem = cSwap(swappedMem, ((CPSR)Cpsr).e);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMMD_AY_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 7);
Fpexc = xc->readMiscRegOperand(this, 8);
FpDest = xc->readFloatRegOperandBits(this, 5);
FpDest2 = xc->readFloatRegOperandBits(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                uint64_t swappedMem  = (uint64_t)FpDest |
                                       ((uint64_t)FpDest2 << 32);
                Mem = cSwap(swappedMem, ((CPSR)Cpsr).e);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t FpDest2 = 0;
uint64_t Mem = 0;
;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Cpacr = xc->readMiscRegOperand(this, 7);
Fpexc = xc->readMiscRegOperand(this, 8);
FpDest = xc->readFloatRegOperandBits(this, 5);
FpDest2 = xc->readFloatRegOperandBits(this, 6);
;
        EA = Base - imm;
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
    unsigned memAccessFlags = ArmISA::TLB::MustBeOne|ArmISA::TLB::AlignWord;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            if (fault == NoFault) {
                
                uint64_t swappedMem  = (uint64_t)FpDest |
                                       ((uint64_t)FpDest2 << 32);
                Mem = cSwap(swappedMem, ((CPSR)Cpsr).e);
                ;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VSTR_STORE_IMMD_AN_PN_SN_UN_WN_SZ4::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault Swp::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Sctlr = 0;
uint32_t Mem = 0;
uint32_t Op1 = 0;
;
        uint64_t memData = 0;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Sctlr = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = Request::MEM_SWAP|ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        if (!((SCTLR)Sctlr).sw) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
    Mem = cSwap(Op1, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &memData);
            }

            if (fault == NoFault) {
                Dest = cSwap((uint32_t)memData, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Swp::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Sctlr = 0;
uint32_t Mem = 0;
uint32_t Op1 = 0;
;
        uint64_t memData = 0;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Sctlr = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = Request::MEM_SWAP|ArmISA::TLB::AlignWord|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        if (!((SCTLR)Sctlr).sw) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
    Mem = cSwap(Op1, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        &memData);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Swp::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);
            uint64_t memData = Mem;

            Dest = cSwap((uint32_t)memData, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault Swpb::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Dest = 0;
uint32_t Sctlr = 0;
uint8_t Mem = 0;
uint8_t Op1 = 0;
;
        uint64_t memData = 0;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Sctlr = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = Request::MEM_SWAP|ArmISA::TLB::AlignByte|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        if (!((SCTLR)Sctlr).sw) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
    Mem = cSwap(Op1, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA, memAccessFlags,
                        &memData);
            }

            if (fault == NoFault) {
                Dest = cSwap((uint8_t)memData, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Swpb::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Base = 0;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Sctlr = 0;
uint8_t Mem = 0;
uint8_t Op1 = 0;
;
        uint64_t memData = 0;
        Base = 
        ((base == PCReg) ? (roundDown(readPC(xc), 4)) :
         xc->readIntRegOperand(this, 0))
    ;
Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
Sctlr = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = Base;
    unsigned memAccessFlags = Request::MEM_SWAP|ArmISA::TLB::AlignByte|ArmISA::TLB::MustBeOne;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        if (!((SCTLR)Sctlr).sw) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
    Mem = cSwap(Op1, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        &memData);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Swpb::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Dest = 0;
uint8_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 1);
OptCondCodesNZ = xc->readIntRegOperand(this, 2);
OptCondCodesC = xc->readIntRegOperand(this, 3);
OptCondCodesV = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);
            uint64_t memData = Mem;

            Dest = cSwap((uint8_t)memData, ((CPSR)Cpsr).e);;

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault MicroLdrUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URb = 0;
uint32_t IWRa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                IWRa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWRa;
            
        ((ura == PCReg) ? setIWNextPC(xc, IWRa) :
         xc->setIntRegOperand(this, 0, IWRa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWRa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                IWRa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = IWRa;
            
        ((ura == PCReg) ? setIWNextPC(xc, IWRa) :
         xc->setIntRegOperand(this, 0, IWRa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault MicroLdrRetUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t NextItState;
uint32_t IWNPC;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t URb = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesGE = 0;
uint32_t Mem = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Sctlr = xc->readMiscRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                
        CPSR old_cpsr = Cpsr;
        SCTLR sctlr = Sctlr;
        CPSR new_cpsr =
            cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
        Cpsr = ~CondCodesMask & new_cpsr;
        CondCodesNZ = new_cpsr.nz;
        CondCodesC = new_cpsr.c;
        CondCodesV = new_cpsr.v;
        CondCodesGE = new_cpsr.ge;
        IWNPC = cSwap(Mem, old_cpsr.e) | ((Spsr & 0x20) ? 1 : 0);
        NextItState = ((((CPSR)Spsr).it2 << 2) & 0xFC)
                | (((CPSR)Spsr).it1 & 0x3);
        SevMailbox = 1;
    ;
            }

            if (fault == NoFault) {
                __parserAutoPCState.nextItstate(NextItState);
__parserAutoPCState.instIWNPC(IWNPC);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrRetUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
;
        CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrRetUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t NextItState;
uint32_t IWNPC;
uint32_t Cpsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesGE = 0;
uint32_t Mem = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
CondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
CondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(CondCodesNZ, CondCodesC, CondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                
        CPSR old_cpsr = Cpsr;
        SCTLR sctlr = Sctlr;
        CPSR new_cpsr =
            cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
        Cpsr = ~CondCodesMask & new_cpsr;
        CondCodesNZ = new_cpsr.nz;
        CondCodesC = new_cpsr.c;
        CondCodesV = new_cpsr.v;
        CondCodesGE = new_cpsr.ge;
        IWNPC = cSwap(Mem, old_cpsr.e) | ((Spsr & 0x20) ? 1 : 0);
        NextItState = ((((CPSR)Spsr).it2 << 2) & 0xFC)
                | (((CPSR)Spsr).it1 & 0x3);
        SevMailbox = 1;
    ;
            }

            if (fault == NoFault) {
                __parserAutoPCState.nextItstate(NextItState);
__parserAutoPCState.instIWNPC(IWNPC);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        }

        return fault;
    }

    Fault MicroLdrFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault MicroLdrDBFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                        EA = URb + (up ? imm : -imm) +
                                             (((CPSR)Cpsr).e ? 4 : 0);
                                        ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrDBFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                        EA = URb + (up ? imm : -imm) +
                                             (((CPSR)Cpsr).e ? 4 : 0);
                                        ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrDBFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault MicroLdrDTFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                        EA = URb + (up ? imm : -imm) -
                                             (((CPSR)Cpsr).e ? 4 : 0);
                                        ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrDTFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                        EA = URb + (up ? imm : -imm) -
                                             (((CPSR)Cpsr).e ? 4 : 0);
                                        ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroLdrDTFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Fa = 0;
uint32_t Mem = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                Fa = cSwap(Mem, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = Fa;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    Fault MicroStrUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t URa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(URa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t URa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(URa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault MicroStrFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URb + (up ? imm : -imm);;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault MicroStrDBFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                         EA = URb + (up ? imm : -imm) +
                                              (((CPSR)Cpsr).e ? 4 : 0);
                                         ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrDBFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                         EA = URb + (up ? imm : -imm) +
                                              (((CPSR)Cpsr).e ? 4 : 0);
                                         ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrDBFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    Fault MicroStrDTFpUop::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                         EA = URb + (up ? imm : -imm) -
                                              (((CPSR)Cpsr).e ? 4 : 0);
                                         ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemAtomic(xc, traceData, Mem, EA,
                        memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrDTFpUop::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URb = 0;
uint32_t Mem = 0;
uint32_t Fa = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 5);
Fpexc = xc->readMiscRegOperand(this, 6);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
Fa = xc->readFloatRegOperandBits(this, 4);
;
        
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                                         EA = URb + (up ? imm : -imm) -
                                              (((CPSR)Cpsr).e ? 4 : 0);
                                         ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                Mem = cSwap(Fa, ((CPSR)Cpsr).e);;
            }

            if (fault == NoFault) {
                fault = writeMemTiming(xc, traceData, Mem, EA, memAccessFlags,
                        NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroStrDTFpUop::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon1Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[1];
            Element elements[1 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 1, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(8);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon1Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[1];
            Element elements[1 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 1, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon1Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[1];
            Element elements[1 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(8);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon1Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[1];
            Element elements[1 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 1, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon1Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[1];
            Element elements[1 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 1, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon1Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon2Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[2];
            Element elements[2 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 2, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(16);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon2Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[2];
            Element elements[2 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 2, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon2Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[2];
            Element elements[2 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(16);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon2Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[2];
            Element elements[2 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 2, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon2Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[2];
            Element elements[2 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 2, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon2Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon3Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[3];
            Element elements[3 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 3, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(24);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon3Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[3];
            Element elements[3 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 3, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon3Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[3];
            Element elements[3 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(24);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon3Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[3];
            Element elements[3 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 3, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon3Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[3];
            Element elements[3 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 3, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon3Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon4Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[4];
            Element elements[4 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 4, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon4Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[4];
            Element elements[4 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 4, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon4Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[4];
            Element elements[4 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon4Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[4];
            Element elements[4 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 4, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon4Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
;
        
        union MemUnion {
            uint8_t bytes[4];
            Element elements[4 / sizeof(Element)];
            uint32_t floatRegBits[1];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 4, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon4Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon6Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[6];
            Element elements[6 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 6, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]) & mask(16);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon6Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[6];
            Element elements[6 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 6, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon6Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[6];
            Element elements[6 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]) & mask(16);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon6Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        
        union MemUnion {
            uint8_t bytes[6];
            Element elements[6 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 6, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon6Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        
        union MemUnion {
            uint8_t bytes[6];
            Element elements[6 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 6, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon6Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon8Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[8];
            Element elements[8 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 8, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon8Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[8];
            Element elements[8 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 8, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon8Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[8];
            Element elements[8 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon8Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        
        union MemUnion {
            uint8_t bytes[8];
            Element elements[8 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 8, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon8Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        
        union MemUnion {
            uint8_t bytes[8];
            Element elements[8 / sizeof(Element)];
            uint32_t floatRegBits[2];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 8, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon8Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon12Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[12];
            Element elements[12 / sizeof(Element)];
            uint32_t floatRegBits[3];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 12, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]);
            
            FpDestP2 = gtoh(memUnion.floatRegBits[2]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon12Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[12];
            Element elements[12 / sizeof(Element)];
            uint32_t floatRegBits[3];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 12, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon12Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[12];
            Element elements[12 / sizeof(Element)];
            uint32_t floatRegBits[3];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]);
            
            FpDestP2 = gtoh(memUnion.floatRegBits[2]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon12Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
;
        
        union MemUnion {
            uint8_t bytes[12];
            Element elements[12 / sizeof(Element)];
            uint32_t floatRegBits[3];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
FpDestP2 = xc->readFloatRegOperandBits(this, 9);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            memUnion.floatRegBits[2] = htog(FpDestP2);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 12, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon12Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
;
        
        union MemUnion {
            uint8_t bytes[12];
            Element elements[12 / sizeof(Element)];
            uint32_t floatRegBits[3];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
FpDestP2 = xc->readFloatRegOperandBits(this, 9);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            memUnion.floatRegBits[2] = htog(FpDestP2);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 12, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon12Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template <class Element>
    Fault MicroLdrNeon16Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[16];
            Element elements[16 / sizeof(Element)];
            uint32_t floatRegBits[4];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 16, memAccessFlags);
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]);
            
            FpDestP2 = gtoh(memUnion.floatRegBits[2]);
            
            FpDestP3 = gtoh(memUnion.floatRegBits[3]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon16Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
;
        
        union MemUnion {
            uint8_t bytes[16];
            Element elements[16 / sizeof(Element)];
            uint32_t floatRegBits[4];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = xc->readMem(EA, dataPtr, 16, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroLdrNeon16Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        
        union MemUnion {
            uint8_t bytes[16];
            Element elements[16 / sizeof(Element)];
            uint32_t floatRegBits[4];
        };
        ;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            MemUnion &memUnion = *(MemUnion *)pkt->getPtr<uint8_t>();

            if (fault == NoFault) {
                
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        
            FpDestP0 = gtoh(memUnion.floatRegBits[0]);
            
            FpDestP1 = gtoh(memUnion.floatRegBits[1]);
            
            FpDestP2 = gtoh(memUnion.floatRegBits[2]);
            
            FpDestP3 = gtoh(memUnion.floatRegBits[3]) & mask(32);
            ;
            }

            if (fault == NoFault) {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon16Uop<Element>::execute(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        
        union MemUnion {
            uint8_t bytes[16];
            Element elements[16 / sizeof(Element)];
            uint32_t floatRegBits[4];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
FpDestP2 = xc->readFloatRegOperandBits(this, 9);
FpDestP3 = xc->readFloatRegOperandBits(this, 10);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        MemUnion memUnion;
        uint8_t *dataPtr = memUnion.bytes;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            memUnion.floatRegBits[2] = htog(FpDestP2);
            
            memUnion.floatRegBits[3] = htog(FpDestP3);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(dataPtr, 16, EA,
                                     memAccessFlags, NULL);
            }

            if (fault == NoFault) {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon16Uop<Element>::initiateAcc(
            O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t URa = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        
        union MemUnion {
            uint8_t bytes[16];
            Element elements[16 / sizeof(Element)];
            uint32_t floatRegBits[4];
        };
        ;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 4);
OptCondCodesC = xc->readIntRegOperand(this, 5);
OptCondCodesV = xc->readIntRegOperand(this, 6);
Cpacr = xc->readMiscRegOperand(this, 1);
Fpexc = xc->readMiscRegOperand(this, 2);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpDestP1 = xc->readFloatRegOperandBits(this, 8);
FpDestP2 = xc->readFloatRegOperandBits(this, 9);
FpDestP3 = xc->readFloatRegOperandBits(this, 10);
;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    EA = URa + imm;;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            MemUnion memUnion;
            if (fault == NoFault) {
                
            memUnion.floatRegBits[0] = htog(FpDestP0);
            
            memUnion.floatRegBits[1] = htog(FpDestP1);
            
            memUnion.floatRegBits[2] = htog(FpDestP2);
            
            memUnion.floatRegBits[3] = htog(FpDestP3);
            
            const unsigned eCount = sizeof(memUnion.elements) /
                                    sizeof(memUnion.elements[0]);
            if (((CPSR)Cpsr).e) {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtobe(memUnion.elements[i]);
                }
            } else {
                for (unsigned i = 0; i < eCount; i++) {
                    memUnion.elements[i] = gtole(memUnion.elements[i]);
                }
            }
        ;
            }

            if (fault == NoFault) {
                fault = xc->writeMem(memUnion.bytes, 16, EA,
                                     memAccessFlags, NULL);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroStrNeon16Uop<Element>::completeAcc(
            PacketPtr pkt, O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        return NoFault;
    }

    template
    Fault MicroLdrNeon1Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon1Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon1Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon1Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon1Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon1Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon2Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon2Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon2Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon2Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon3Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon3Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon3Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon3Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon3Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon3Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon16Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon16Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint8_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint8_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon16Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon16Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon2Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon2Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon2Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon2Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon6Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon6Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon6Uop<uint16_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon6Uop<uint16_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon16Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon16Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon4Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon4Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon12Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon12Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon12Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon12Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon12Uop<uint32_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon12Uop<uint32_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon16Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint64_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon16Uop<uint64_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon16Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint64_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon16Uop<uint64_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroLdrNeon8Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint64_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroLdrNeon8Uop<uint64_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroStrNeon8Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint64_t>::initiateAcc(
            O3DynInst *, Trace::InstRecord *) const;
    template
    Fault MicroStrNeon8Uop<uint64_t>::completeAcc(PacketPtr,
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault MicroDeintNeon4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 2;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[0] = htog(FpOp1P0);
                conv1.cRegs[1] = htog(FpOp1P1);
            
                conv1.cRegs[2] = htog(FpOp1P2);
                conv1.cRegs[3] = htog(FpOp1P3);
            
            unsigned srcElem = 0;
            for (unsigned destOffset = 0;
                    destOffset < perDReg; destOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[dReg * perDReg + destOffset] =
                        conv1.elements[srcElem++];
                }
            }
            
                FpDestS0P0 = gtoh(conv2.cRegs[2 * 0 + 0]);
                FpDestS0P1 = gtoh(conv2.cRegs[2 * 0 + 1]);
            
                FpDestS1P0 = gtoh(conv2.cRegs[2 * 1 + 0]);
                FpDestS1P1 = gtoh(conv2.cRegs[2 * 1 + 1]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroInterNeon4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 2;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[2 * 0 + 0] = htog(FpOp1S0P0);
                conv1.cRegs[2 * 0 + 1] = htog(FpOp1S0P1);
            
                conv1.cRegs[2 * 1 + 0] = htog(FpOp1S1P0);
                conv1.cRegs[2 * 1 + 1] = htog(FpOp1S1P1);
            
            unsigned destElem = 0;
            for (unsigned srcOffset = 0;
                    srcOffset < perDReg; srcOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[destElem++] =
                        conv1.elements[dReg * perDReg + srcOffset];
                }
            }
            
                FpDestP0 = gtoh(conv2.cRegs[0]);
                FpDestP1 = gtoh(conv2.cRegs[1]);
            
                FpDestP2 = gtoh(conv2.cRegs[2]);
                FpDestP3 = gtoh(conv2.cRegs[3]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroDeintNeon6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
FpOp1P4 = xc->readFloatRegOperandBits(this, 7);
FpOp1P5 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 3;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[0] = htog(FpOp1P0);
                conv1.cRegs[1] = htog(FpOp1P1);
            
                conv1.cRegs[2] = htog(FpOp1P2);
                conv1.cRegs[3] = htog(FpOp1P3);
            
                conv1.cRegs[4] = htog(FpOp1P4);
                conv1.cRegs[5] = htog(FpOp1P5);
            
            unsigned srcElem = 0;
            for (unsigned destOffset = 0;
                    destOffset < perDReg; destOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[dReg * perDReg + destOffset] =
                        conv1.elements[srcElem++];
                }
            }
            
                FpDestS0P0 = gtoh(conv2.cRegs[2 * 0 + 0]);
                FpDestS0P1 = gtoh(conv2.cRegs[2 * 0 + 1]);
            
                FpDestS1P0 = gtoh(conv2.cRegs[2 * 1 + 0]);
                FpDestS1P1 = gtoh(conv2.cRegs[2 * 1 + 1]);
            
                FpDestS2P0 = gtoh(conv2.cRegs[2 * 2 + 0]);
                FpDestS2P1 = gtoh(conv2.cRegs[2 * 2 + 1]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroInterNeon6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpDestP4 = 0;
uint32_t FpDestP5 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 3;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[2 * 0 + 0] = htog(FpOp1S0P0);
                conv1.cRegs[2 * 0 + 1] = htog(FpOp1S0P1);
            
                conv1.cRegs[2 * 1 + 0] = htog(FpOp1S1P0);
                conv1.cRegs[2 * 1 + 1] = htog(FpOp1S1P1);
            
                conv1.cRegs[2 * 2 + 0] = htog(FpOp1S2P0);
                conv1.cRegs[2 * 2 + 1] = htog(FpOp1S2P1);
            
            unsigned destElem = 0;
            for (unsigned srcOffset = 0;
                    srcOffset < perDReg; srcOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[destElem++] =
                        conv1.elements[dReg * perDReg + srcOffset];
                }
            }
            
                FpDestP0 = gtoh(conv2.cRegs[0]);
                FpDestP1 = gtoh(conv2.cRegs[1]);
            
                FpDestP2 = gtoh(conv2.cRegs[2]);
                FpDestP3 = gtoh(conv2.cRegs[3]);
            
                FpDestP4 = gtoh(conv2.cRegs[4]);
                FpDestP5 = gtoh(conv2.cRegs[5]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP4;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP5;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroDeintNeon8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
uint32_t FpOp1P6 = 0;
uint32_t FpOp1P7 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
uint32_t FpDestS3P0 = 0;
uint32_t FpDestS3P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
FpOp1P4 = xc->readFloatRegOperandBits(this, 7);
FpOp1P5 = xc->readFloatRegOperandBits(this, 8);
FpOp1P6 = xc->readFloatRegOperandBits(this, 9);
FpOp1P7 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 4;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[0] = htog(FpOp1P0);
                conv1.cRegs[1] = htog(FpOp1P1);
            
                conv1.cRegs[2] = htog(FpOp1P2);
                conv1.cRegs[3] = htog(FpOp1P3);
            
                conv1.cRegs[4] = htog(FpOp1P4);
                conv1.cRegs[5] = htog(FpOp1P5);
            
                conv1.cRegs[6] = htog(FpOp1P6);
                conv1.cRegs[7] = htog(FpOp1P7);
            
            unsigned srcElem = 0;
            for (unsigned destOffset = 0;
                    destOffset < perDReg; destOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[dReg * perDReg + destOffset] =
                        conv1.elements[srcElem++];
                }
            }
            
                FpDestS0P0 = gtoh(conv2.cRegs[2 * 0 + 0]);
                FpDestS0P1 = gtoh(conv2.cRegs[2 * 0 + 1]);
            
                FpDestS1P0 = gtoh(conv2.cRegs[2 * 1 + 0]);
                FpDestS1P1 = gtoh(conv2.cRegs[2 * 1 + 1]);
            
                FpDestS2P0 = gtoh(conv2.cRegs[2 * 2 + 0]);
                FpDestS2P1 = gtoh(conv2.cRegs[2 * 2 + 1]);
            
                FpDestS3P0 = gtoh(conv2.cRegs[2 * 3 + 0]);
                FpDestS3P1 = gtoh(conv2.cRegs[2 * 3 + 1]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P0;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P1;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroInterNeon8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpOp1S3P0 = 0;
uint32_t FpOp1S3P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpDestP4 = 0;
uint32_t FpDestP5 = 0;
uint32_t FpDestP6 = 0;
uint32_t FpDestP7 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1S3P0 = xc->readFloatRegOperandBits(this, 9);
FpOp1S3P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned dRegs = 4;
            const unsigned regs = 2 * dRegs;
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union convStruct {
                FloatRegBits cRegs[regs];
                Element elements[dRegs * perDReg];
            } conv1, conv2;
            
                conv1.cRegs[2 * 0 + 0] = htog(FpOp1S0P0);
                conv1.cRegs[2 * 0 + 1] = htog(FpOp1S0P1);
            
                conv1.cRegs[2 * 1 + 0] = htog(FpOp1S1P0);
                conv1.cRegs[2 * 1 + 1] = htog(FpOp1S1P1);
            
                conv1.cRegs[2 * 2 + 0] = htog(FpOp1S2P0);
                conv1.cRegs[2 * 2 + 1] = htog(FpOp1S2P1);
            
                conv1.cRegs[2 * 3 + 0] = htog(FpOp1S3P0);
                conv1.cRegs[2 * 3 + 1] = htog(FpOp1S3P1);
            
            unsigned destElem = 0;
            for (unsigned srcOffset = 0;
                    srcOffset < perDReg; srcOffset++) {
                for (unsigned dReg = 0; dReg < dRegs; dReg++) {
                    conv2.elements[destElem++] =
                        conv1.elements[dReg * perDReg + srcOffset];
                }
            }
            
                FpDestP0 = gtoh(conv2.cRegs[0]);
                FpDestP1 = gtoh(conv2.cRegs[1]);
            
                FpDestP2 = gtoh(conv2.cRegs[2]);
                FpDestP3 = gtoh(conv2.cRegs[3]);
            
                FpDestP4 = gtoh(conv2.cRegs[4]);
                FpDestP5 = gtoh(conv2.cRegs[5]);
            
                FpDestP6 = gtoh(conv2.cRegs[6]);
                FpDestP7 = gtoh(conv2.cRegs[7]);
            
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP4;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP5;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP6;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP7;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault MicroDeintNeon4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon6Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon6Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon4Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon4Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon6Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon6Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroDeintNeon8Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroInterNeon8Uop<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault MicroUnpackNeon2to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 5);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[1];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
            for (unsigned i = 0; i < 1; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon2to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 5);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 6);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[2];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
            for (unsigned i = 0; i < 2; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon2to6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 5);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 6);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestS2P0 = xc->readFloatRegOperandBits(this, 9);
FpDestS2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[3];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
                    destRegs[2].fRegs[0] = htog(FpDestS2P0);
                    destRegs[2].fRegs[1] = htog(FpDestS2P1);
                
            for (unsigned i = 0; i < 3; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon2to8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
uint32_t FpDestS3P0 = 0;
uint32_t FpDestS3P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 5);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 6);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestS2P0 = xc->readFloatRegOperandBits(this, 9);
FpDestS2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestS3P0 = xc->readFloatRegOperandBits(this, 11);
FpDestS3P1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[4];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
                    destRegs[2].fRegs[0] = htog(FpDestS2P0);
                    destRegs[2].fRegs[1] = htog(FpDestS2P1);
                
                    destRegs[3].fRegs[0] = htog(FpDestS3P0);
                    destRegs[3].fRegs[1] = htog(FpDestS3P1);
                
            for (unsigned i = 0; i < 4; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
                    FpDestS3P0 = gtoh(destRegs[3].fRegs[0]);
                    FpDestS3P1 = gtoh(destRegs[3].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P0;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P1;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon4to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 8);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 9);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[2];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
            for (unsigned i = 0; i < 2; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon4to6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 8);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 9);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 10);
FpDestS2P0 = xc->readFloatRegOperandBits(this, 11);
FpDestS2P1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[3];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
                    destRegs[2].fRegs[0] = htog(FpDestS2P0);
                    destRegs[2].fRegs[1] = htog(FpDestS2P1);
                
            for (unsigned i = 0; i < 3; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackNeon4to8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
uint32_t FpDestS3P0 = 0;
uint32_t FpDestS3P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
FpDestS0P0 = xc->readFloatRegOperandBits(this, 7);
FpDestS0P1 = xc->readFloatRegOperandBits(this, 8);
FpDestS1P0 = xc->readFloatRegOperandBits(this, 9);
FpDestS1P1 = xc->readFloatRegOperandBits(this, 10);
FpDestS2P0 = xc->readFloatRegOperandBits(this, 11);
FpDestS2P1 = xc->readFloatRegOperandBits(this, 12);
FpDestS3P0 = xc->readFloatRegOperandBits(this, 13);
FpDestS3P1 = xc->readFloatRegOperandBits(this, 14);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[4];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
                    destRegs[0].fRegs[0] = htog(FpDestS0P0);
                    destRegs[0].fRegs[1] = htog(FpDestS0P1);
                
                    destRegs[1].fRegs[0] = htog(FpDestS1P0);
                    destRegs[1].fRegs[1] = htog(FpDestS1P1);
                
                    destRegs[2].fRegs[0] = htog(FpDestS2P0);
                    destRegs[2].fRegs[1] = htog(FpDestS2P1);
                
                    destRegs[3].fRegs[0] = htog(FpDestS3P0);
                    destRegs[3].fRegs[1] = htog(FpDestS3P1);
                
            for (unsigned i = 0; i < 4; i++) {
                destRegs[i].elements[lane] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
                    FpDestS3P0 = gtoh(destRegs[3].fRegs[0]);
                    FpDestS3P1 = gtoh(destRegs[3].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P0;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P1;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon2to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[1];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
            for (unsigned i = 0; i < 1; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon2to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[2];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
            for (unsigned i = 0; i < 2; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon2to6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[3];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
            for (unsigned i = 0; i < 3; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon2to8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
uint32_t FpDestS3P0 = 0;
uint32_t FpDestS3P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[4];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
            for (unsigned i = 0; i < 4; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
                    FpDestS3P0 = gtoh(destRegs[3].fRegs[0]);
                    FpDestS3P1 = gtoh(destRegs[3].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P0;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P1;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon4to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[2];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
            for (unsigned i = 0; i < 2; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon4to6Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[3];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
            for (unsigned i = 0; i < 3; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroUnpackAllNeon4to8Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestS0P0 = 0;
uint32_t FpDestS0P1 = 0;
uint32_t FpDestS1P0 = 0;
uint32_t FpDestS1P1 = 0;
uint32_t FpDestS2P0 = 0;
uint32_t FpDestS2P1 = 0;
uint32_t FpDestS3P0 = 0;
uint32_t FpDestS3P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1P2 = xc->readFloatRegOperandBits(this, 5);
FpOp1P3 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } sourceRegs;
            union DestReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } destRegs[4];
            
                sourceRegs.fRegs[0] = htog(FpOp1P0);
                sourceRegs.fRegs[1] = htog(FpOp1P1);
            
                sourceRegs.fRegs[2] = htog(FpOp1P2);
                sourceRegs.fRegs[3] = htog(FpOp1P3);
            
            for (unsigned i = 0; i < 4; i++) {
                for (unsigned j = 0; j < perDReg; j++)
                    destRegs[i].elements[j] = sourceRegs.elements[i];
            }
            
                    FpDestS0P0 = gtoh(destRegs[0].fRegs[0]);
                    FpDestS0P1 = gtoh(destRegs[0].fRegs[1]);
                
                    FpDestS1P0 = gtoh(destRegs[1].fRegs[0]);
                    FpDestS1P1 = gtoh(destRegs[1].fRegs[1]);
                
                    FpDestS2P0 = gtoh(destRegs[2].fRegs[0]);
                    FpDestS2P1 = gtoh(destRegs[2].fRegs[1]);
                
                    FpDestS3P0 = gtoh(destRegs[3].fRegs[0]);
                    FpDestS3P1 = gtoh(destRegs[3].fRegs[1]);
                
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestS0P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS0P1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P0;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS1P1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P0;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS2P1;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P0;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestS3P1;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon2to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[1];
            union DestRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
            for (unsigned i = 0; i < 1; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 1; i < 1 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon4to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[2];
            union DestRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
            for (unsigned i = 0; i < 2; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 2; i < 1 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon6to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[3];
            union DestRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
                    sourceRegs[2].fRegs[0] = htog(FpOp1S2P0);
                    sourceRegs[2].fRegs[1] = htog(FpOp1S2P1);
                
            for (unsigned i = 0; i < 3; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 3; i < 1 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon8to2Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpOp1S3P0 = 0;
uint32_t FpOp1S3P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1S3P0 = xc->readFloatRegOperandBits(this, 9);
FpOp1S3P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[4];
            union DestRegs {
                FloatRegBits fRegs[2 * 1];
                Element elements[1 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
                    sourceRegs[2].fRegs[0] = htog(FpOp1S2P0);
                    sourceRegs[2].fRegs[1] = htog(FpOp1S2P1);
                
                    sourceRegs[3].fRegs[0] = htog(FpOp1S3P0);
                    sourceRegs[3].fRegs[1] = htog(FpOp1S3P1);
                
            for (unsigned i = 0; i < 4; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 4; i < 1 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon4to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[2];
            union DestRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
            for (unsigned i = 0; i < 2; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 2; i < 2 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
                FpDestP2 = gtoh(destRegs.fRegs[2]);
                FpDestP3 = gtoh(destRegs.fRegs[3]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon6to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[3];
            union DestRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
                    sourceRegs[2].fRegs[0] = htog(FpOp1S2P0);
                    sourceRegs[2].fRegs[1] = htog(FpOp1S2P1);
                
            for (unsigned i = 0; i < 3; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 3; i < 2 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
                FpDestP2 = gtoh(destRegs.fRegs[2]);
                FpDestP3 = gtoh(destRegs.fRegs[3]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template <class Element>
    Fault MicroPackNeon8to4Uop<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp1S0P0 = 0;
uint32_t FpOp1S0P1 = 0;
uint32_t FpOp1S1P0 = 0;
uint32_t FpOp1S1P1 = 0;
uint32_t FpOp1S2P0 = 0;
uint32_t FpOp1S2P1 = 0;
uint32_t FpOp1S3P0 = 0;
uint32_t FpOp1S3P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp1S0P0 = xc->readFloatRegOperandBits(this, 3);
FpOp1S0P1 = xc->readFloatRegOperandBits(this, 4);
FpOp1S1P0 = xc->readFloatRegOperandBits(this, 5);
FpOp1S1P1 = xc->readFloatRegOperandBits(this, 6);
FpOp1S2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1S2P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1S3P0 = xc->readFloatRegOperandBits(this, 9);
FpOp1S3P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            const unsigned perDReg = (2 * sizeof(FloatRegBits)) /
                                     sizeof(Element);
            union SourceReg {
                FloatRegBits fRegs[2];
                Element elements[perDReg];
            } sourceRegs[4];
            union DestRegs {
                FloatRegBits fRegs[2 * 2];
                Element elements[2 * perDReg];
            } destRegs;
            
                    sourceRegs[0].fRegs[0] = htog(FpOp1S0P0);
                    sourceRegs[0].fRegs[1] = htog(FpOp1S0P1);
                
                    sourceRegs[1].fRegs[0] = htog(FpOp1S1P0);
                    sourceRegs[1].fRegs[1] = htog(FpOp1S1P1);
                
                    sourceRegs[2].fRegs[0] = htog(FpOp1S2P0);
                    sourceRegs[2].fRegs[1] = htog(FpOp1S2P1);
                
                    sourceRegs[3].fRegs[0] = htog(FpOp1S3P0);
                    sourceRegs[3].fRegs[1] = htog(FpOp1S3P1);
                
            for (unsigned i = 0; i < 4; i++) {
                destRegs.elements[i] = sourceRegs[i].elements[lane];
            }
            for (unsigned i = 4; i < 2 * perDReg; ++i) {
                destRegs.elements[i] = 0;
            }
            
                FpDestP0 = gtoh(destRegs.fRegs[0]);
                FpDestP1 = gtoh(destRegs.fRegs[1]);
            
                FpDestP2 = gtoh(destRegs.fRegs[2]);
                FpDestP3 = gtoh(destRegs.fRegs[3]);
            
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault MicroUnpackNeon2to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon2to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon6to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon8to2Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to6Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon6to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to8Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon8to4Uop<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon2to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon6to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon8to2Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to6Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon6to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to8Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon8to4Uop<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to2Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to2Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon2to2Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon2to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon2to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to2Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon4to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to6Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to6Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon6to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackNeon4to8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroUnpackAllNeon4to8Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault MicroPackNeon8to4Uop<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    Fault MicroAddiUop::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URa = 0;
uint32_t URb = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            URa = URb + imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 0, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroSubiUop::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URa = 0;
uint32_t URb = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            URa = URb - imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 0, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroAddUop::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URa = 0;
uint32_t URb = 0;
uint32_t URc = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
URc = 
        ((urc == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        URa = URb + shift_rm_imm(URc, shiftAmt, shiftType, OptShiftRmCondCodesC);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 0, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroSubUop::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URa = 0;
uint32_t URb = 0;
uint32_t URc = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
URc = 
        ((urc == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
        URa = URb - shift_rm_imm(URc, shiftAmt, shiftType, OptShiftRmCondCodesC);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = URa;
            
        ((ura == PCReg) ? setNextPC(xc, URa) :
         xc->setIntRegOperand(this, 0, URa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroUopRegMov::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t IWRa = 0;
uint32_t URb = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            IWRa = URb;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = IWRa;
            
        ((ura == PCReg) ? setIWNextPC(xc, IWRa) :
         xc->setIntRegOperand(this, 0, IWRa))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroUopRegMovRet::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextItState;
uint32_t IWNPC;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t URb = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        CPSR old_cpsr = Cpsr;
        SCTLR sctlr = Sctlr;
        CPSR new_cpsr =
            cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
        Cpsr = ~CondCodesMask & new_cpsr;
        CondCodesNZ = new_cpsr.nz;
        CondCodesC = new_cpsr.c;
        CondCodesV = new_cpsr.v;
        CondCodesGE = new_cpsr.ge;
        IWNPC = cSwap(URb, old_cpsr.e) | ((Spsr & 0x20) ? 1 : 0);
        NextItState = ((((CPSR)Spsr).it2 << 2) & 0xFC)
                | (((CPSR)Spsr).it1 & 0x3);
        SevMailbox = 1;
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextItstate(NextItState);
__parserAutoPCState.instIWNPC(IWNPC);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MicroUopSetPCCPSR::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t pNPC;
uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t URc = 0;
uint32_t Sctlr = 0;
uint32_t URa = 0;
uint32_t URb = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
URc = 
        ((urc == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Sctlr = xc->readMiscRegOperand(this, 4);
URa = 
        ((ura == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
URb = 
        ((urb == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
                    CPSR cpsrOrCondCodes = URc;
                    SCTLR sctlr = Sctlr;
                    pNPC = URa;
                    CPSR new_cpsr =
                    cpsrWriteByInstr(cpsrOrCondCodes, URb,
                                     0xF, true, sctlr.nmfi);
                    Cpsr = ~CondCodesMask & new_cpsr;
                    NextThumb = new_cpsr.t;
                    NextJazelle = new_cpsr.j;
                    NextItState = ((((CPSR)URb).it2 << 2) & 0xFC)
                                    | (((CPSR)URb).it1 & 0x3);
                    CondCodesNZ = new_cpsr.nz;
                    CondCodesC = new_cpsr.c;
                    CondCodesV = new_cpsr.v;
                    CondCodesGE = new_cpsr.ge;
                    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.instNPC(pNPC);
__parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 & imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AndsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 ^ shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 ^ imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault EorsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 - imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SubsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm - Op1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm - Op1;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, imm, ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, imm, ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC) - Op1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC) - Op1;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC), ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC), ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - Op1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - Op1;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0), ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0), ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = imm - Op1;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RsbsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC) - Op1;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 + imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AddsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdrImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
                               Dest = resTemp = (PC & ~0x3) +
                               (op1 ? imm : -imm);
                            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdrImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t CondCodesNZ = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
                               Dest = resTemp = (PC & ~0x3) +
                               (op1 ? imm : -imm);
                            
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + imm + CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + imm + CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) + CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) + CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) + CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) + CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 + imm + CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault AdcsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) + CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - imm - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - imm - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 - imm - !CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SbcsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - !CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm - Op1 - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm - Op1 - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, imm, ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, imm, ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - Op1 - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - Op1 - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC), ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC), ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - Op1 - !CondCodesC;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0) - Op1 - !CondCodesC;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0), ~Op1) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0), ~Op1) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = imm - Op1 - !CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault RscsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC) - Op1 - !CondCodesC;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & imm;;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TstsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 & shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ imm;;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault TeqsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 ^ shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - imm;;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmpsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 - shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + imm;;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, imm) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, imm) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesC = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _iv;
                _iv = findOverflow(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesV =  _iv;
                DPRINTF(Arm, "(iv) = (%d)\n", _iv);
            
                uint16_t _ic;
                _ic = findCarry(32, resTemp, Op1, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0)) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault CmnsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Op1 + shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 5, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 | shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrrsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault OrnsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 | ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = Op1 & ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 & ~imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BicsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = Op1 & ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~imm;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~imm;
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 0, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t AIWDest = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            AIWDest = resTemp = ~shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = AIWDest;
            
        if (dest == PCReg) {
            bool thumb = THUMB;
            if (thumb) {
                setNextPC(xc, AIWDest);
            } else {
                setIWNextPC(xc, AIWDest);
            }
        } else {
            xc->setIntRegOperand(this, 1, AIWDest);
        }
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Sctlr = xc->readMiscRegOperand(this, 4);
Spsr = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = ~imm;
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MvnsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = ~shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, imm);;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtImmCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, imm);
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = (rotC ? bits(imm, 31) : CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC));;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC));
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_imm(Op2, shiftAmt, shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtRegReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0));;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtRegRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Shift = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
CondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Shift = 
        ((shift == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, shift_rm_rs(Op2, bits(Shift, 7, 0), shiftType, 0));
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        
                uint16_t _ic;
                _ic = shift_carry_rs(Op2, bits(Shift, 7, 0), shiftType, CondCodesC) & 1;
                CondCodesC =  _ic;
                DPRINTF(Arm, "(ic) = (%d)\n", _ic);
            ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtsImmPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Sctlr = xc->readMiscRegOperand(this, 5);
Spsr = xc->readMiscRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, imm);
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MovtsRegPclr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t NextJazelle;
uint32_t NextItState;
uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Spsr = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesV = 0;
uint32_t CondCodesGE = 0;
uint32_t SevMailbox = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
CondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Sctlr = xc->readMiscRegOperand(this, 6);
Spsr = xc->readMiscRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, CondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Dest = resTemp = insertBits(Op1, 31, 16, shift_rm_imm(Op2, shiftAmt, shiftType, CondCodesC));
            SCTLR sctlr = Sctlr;
            CPSR old_cpsr = Cpsr;
            CPSR new_cpsr =
                cpsrWriteByInstr(old_cpsr, Spsr, 0xF, true, sctlr.nmfi);
            Cpsr = ~CondCodesMask & new_cpsr;
            CondCodesNZ = new_cpsr.nz;
            CondCodesC = new_cpsr.c;
            CondCodesV = new_cpsr.v;
            CondCodesGE = new_cpsr.ge;
            NextThumb = (new_cpsr).t;
            NextJazelle = (new_cpsr).j;
            NextItState = (((new_cpsr).it2 << 2) & 0xFC)
                | ((new_cpsr).it1 & 0x3);
            SevMailbox = 1;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.nextJazelle(NextJazelle);
__parserAutoPCState.nextItstate(NextItState);
xc->pcState(__parserAutoPCState);
xc->setMiscRegOperand(this, 0, Cpsr);
if (traceData) { traceData->setData(Cpsr); }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 2, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 6, SevMailbox);
if (traceData) { traceData->setData(SevMailbox); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QaddRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = saturateOp<32>(midRes, Op1, Op2);
                                     Dest = midRes;
        
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Qadd16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int64_t arg1 = sext<16>(bits(Op1, high, low));
                int64_t arg2 = sext<16>(bits(Op2, high, low));
                saturateOp<16>(midRes, arg1, arg2);
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Qadd8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int64_t arg1 = sext<8>(bits(Op1, high, low));
                int64_t arg2 = sext<8>(bits(Op2, high, low));
                saturateOp<8>(midRes, arg1, arg2);
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QdaddRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op2 = 0;
int32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = saturateOp<32>(midRes, Op2, Op2) |
                      saturateOp<32>(midRes, Op1, midRes);
            Dest = midRes;
        
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QsubReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = saturateOp<32>(midRes, Op1, Op2, true);
            Dest = midRes;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QsubRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = saturateOp<32>(midRes, Op1, Op2, true);
            Dest = midRes;
        
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Qsub16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            for (unsigned i = 0; i < 2; i++) {
                 int high = (i + 1) * 16 - 1;
                 int low = i * 16;
                 int64_t arg1 = sext<16>(bits(Op1, high, low));
                 int64_t arg2 = sext<16>(bits(Op2, high, low));
                 saturateOp<16>(midRes, arg1, arg2, true);
                 replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Qsub8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            for (unsigned i = 0; i < 4; i++) {
                 int high = (i + 1) * 8 - 1;
                 int low = i * 8;
                 int64_t arg1 = sext<8>(bits(Op1, high, low));
                 int64_t arg2 = sext<8>(bits(Op2, high, low));
                 saturateOp<8>(midRes, arg1, arg2, true);
                 replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QdsubRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op2 = 0;
int32_t Op1 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = saturateOp<32>(midRes, Op2, Op2) |
                      saturateOp<32>(midRes, Op1, midRes, true);
            Dest = midRes;
        
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 1, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QasxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            saturateOp<16>(midRes, arg1Low, arg2High, true);
            replaceBits(resTemp, 15, 0, midRes);
            saturateOp<16>(midRes, arg1High, arg2Low);
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault QsaxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            saturateOp<16>(midRes, arg1Low, arg2High);
            replaceBits(resTemp, 15, 0, midRes);
            saturateOp<16>(midRes, arg1High, arg2Low, true);
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sadd8RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = sext<8>(bits(Op1, high, low)) +
                                 sext<8>(bits(Op2, high, low));
                replaceBits(resTemp, high, low, midRes);
                if (midRes >= 0) {
                    geBits = geBits | (1 << i);
                }
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sadd16RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = sext<16>(bits(Op1, high, low)) +
                                 sext<16>(bits(Op2, high, low));
                replaceBits(resTemp, high, low, midRes);
                if (midRes >= 0) {
                    geBits = geBits | (0x3 << (i * 2));
                }
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Ssub8RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = sext<8>(bits(Op1, high, low)) -
                                 sext<8>(bits(Op2, high, low));
                replaceBits(resTemp, high, low, midRes);
                if (midRes >= 0) {
                    geBits = geBits | (1 << i);
                }
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Ssub16RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = sext<16>(bits(Op1, high, low)) -
                                 sext<16>(bits(Op2, high, low));
                replaceBits(resTemp, high, low, midRes);
                if (midRes >= 0) {
                    geBits = geBits | (0x3 << (i * 2));
                }
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SasxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = arg1Low - arg2High;
            if (midRes >= 0) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High + arg2Low;
            if (midRes >= 0) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SasxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = arg1Low - arg2High;
            if (midRes >= 0) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High + arg2Low;
            if (midRes >= 0) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SsaxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = arg1Low + arg2High;
            if (midRes >= 0) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High - arg2Low;
            if (midRes >= 0) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SsaxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = arg1Low + arg2High;
            if (midRes >= 0) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High - arg2Low;
            if (midRes >= 0) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Shadd8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes =
                    (uint64_t)(sext<8>(bits(Op1, high, low)) +
                               sext<8>(bits(Op2, high, low))) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Shadd16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes =
                    (uint64_t)(sext<16>(bits(Op1, high, low)) +
                               sext<16>(bits(Op2, high, low))) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Shsub8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes =
                    (uint64_t)(sext<8>(bits(Op1, high, low)) -
                               sext<8>(bits(Op2, high, low))) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Shsub16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes =
                    (uint64_t)(sext<16>(bits(Op1, high, low)) -
                               sext<16>(bits(Op2, high, low))) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault ShasxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = (uint64_t)(arg1Low - arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (arg1High + arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault ShasxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = (uint64_t)(arg1Low - arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (arg1High + arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault ShsaxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = (uint64_t)(arg1Low + arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (uint64_t)(arg1High - arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault ShsaxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = sext<16>(bits(Op1, 15, 0));
            int64_t arg1High = sext<16>(bits(Op1, 31, 16));
            int64_t arg2Low = sext<16>(bits(Op2, 15, 0));
            int64_t arg2High = sext<16>(bits(Op2, 31, 16));
            midRes = (uint64_t)(arg1Low + arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (uint64_t)(arg1High - arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        
            uint16_t _iz, _in;
            _in = (resTemp >> 31) & 1;
            _iz = (resTemp == 0);
            CondCodesNZ = (_in << 1) | _iz;
            DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uqadd16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                uint64_t arg1 = bits(Op1, high, low);
                uint64_t arg2 = bits(Op2, high, low);
                uSaturateOp<16>(midRes, arg1, arg2);
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uqadd8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                uint64_t arg1 = bits(Op1, high, low);
                uint64_t arg2 = bits(Op2, high, low);
                uSaturateOp<8>(midRes, arg1, arg2);
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uqsub16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            for (unsigned i = 0; i < 2; i++) {
                 int high = (i + 1) * 16 - 1;
                 int low = i * 16;
                 uint64_t arg1 = bits(Op1, high, low);
                 uint64_t arg2 = bits(Op2, high, low);
                 uSaturateOp<16>(midRes, arg1, arg2, true);
                 replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uqsub8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            for (unsigned i = 0; i < 4; i++) {
                 int high = (i + 1) * 8 - 1;
                 int low = i * 8;
                 uint64_t arg1 = bits(Op1, high, low);
                 uint64_t arg2 = bits(Op2, high, low);
                 uSaturateOp<8>(midRes, arg1, arg2, true);
                 replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UqasxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            uint64_t arg1Low = bits(Op1, 15, 0);
            uint64_t arg1High = bits(Op1, 31, 16);
            uint64_t arg2Low = bits(Op2, 15, 0);
            uint64_t arg2High = bits(Op2, 31, 16);
            uSaturateOp<16>(midRes, arg1Low, arg2High, true);
            replaceBits(resTemp, 15, 0, midRes);
            uSaturateOp<16>(midRes, arg1High, arg2Low);
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UqsaxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t midRes;
            uint64_t arg1Low = bits(Op1, 15, 0);
            uint64_t arg1High = bits(Op1, 31, 16);
            uint64_t arg2Low = bits(Op2, 15, 0);
            uint64_t arg2High = bits(Op2, 31, 16);
            uSaturateOp<16>(midRes, arg1Low, arg2High);
            replaceBits(resTemp, 15, 0, midRes);
            uSaturateOp<16>(midRes, arg1High, arg2Low, true);
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uadd16RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = bits(Op1, high, low) +
                                 bits(Op2, high, low);
                if (midRes >= 0x10000) {
                    geBits = geBits | (0x3 << (i * 2));
                }
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uadd8RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = bits(Op1, high, low) +
                                 bits(Op2, high, low);
                if (midRes >= 0x100) {
                    geBits = geBits | (1 << i);
                }
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usub16RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = bits(Op1, high, low) -
                                 bits(Op2, high, low);
                if (midRes >= 0) {
                    geBits = geBits | (0x3 << (i * 2));
                }
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Usub8RegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t geBits = 0;
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = bits(Op1, high, low) -
                                 bits(Op2, high, low);
                if (midRes >= 0) {
                    geBits = geBits | (1 << i);
                }
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UasxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = bits(Op1, 15, 0);
            int64_t arg1High = bits(Op1, 31, 16);
            int64_t arg2Low = bits(Op2, 15, 0);
            int64_t arg2High = bits(Op2, 31, 16);
            midRes = arg1Low - arg2High;
            if (midRes >= 0) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High + arg2Low;
            if (midRes >= 0x10000) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UsaxRegCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
uint32_t CondCodesGE = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes, geBits = 0;
            resTemp = 0;
            int64_t arg1Low = bits(Op1, 15, 0);
            int64_t arg1High = bits(Op1, 31, 16);
            int64_t arg2Low = bits(Op2, 15, 0);
            int64_t arg2High = bits(Op2, 31, 16);
            midRes = arg1Low + arg2High;
            if (midRes >= 0x10000) {
                geBits = geBits | 0x3;
            }
            replaceBits(resTemp, 15, 0, midRes);
            midRes = arg1High - arg2Low;
            if (midRes >= 0) {
                geBits = geBits | 0xc;
            }
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
            resTemp = geBits;
        
        CondCodesGE = resTemp;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesGE;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uhadd16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = (bits(Op1, high, low) +
                                  bits(Op2, high, low)) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uhadd8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = (bits(Op1, high, low) +
                                  bits(Op2, high, low)) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uhsub16Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 2; i++) {
                int high = (i + 1) * 16 - 1;
                int low = i * 16;
                int32_t midRes = (bits(Op1, high, low) -
                                  bits(Op2, high, low)) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Uhsub8Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            resTemp = 0;
            for (unsigned i = 0; i < 4; i++) {
                int high = (i + 1) * 8 - 1;
                int low = i * 8;
                int32_t midRes = (bits(Op1, high, low) -
                                  bits(Op2, high, low)) >> 1;
                replaceBits(resTemp, high, low, midRes);
            }
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UhasxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = bits(Op1, 15, 0);
            int64_t arg1High = bits(Op1, 31, 16);
            int64_t arg2Low = bits(Op2, 15, 0);
            int64_t arg2High = bits(Op2, 31, 16);
            midRes = (arg1Low - arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (arg1High + arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UhsaxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op1 = 0;
int32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            int32_t midRes;
            resTemp = 0;
            int64_t arg1Low = bits(Op1, 15, 0);
            int64_t arg1High = bits(Op1, 31, 16);
            int64_t arg2Low = bits(Op2, 15, 0);
            int64_t arg2High = bits(Op2, 31, 16);
            midRes = (arg1Low + arg2High) >> 1;
            replaceBits(resTemp, 15, 0, midRes);
            midRes = (arg1High - arg2Low) >> 1;
            replaceBits(resTemp, 31, 16, midRes);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PkhbtReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t resTemp = 0;
            uint16_t arg1Low = bits(Op1, 15, 0);
            uint16_t arg2High = bits(shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC), 31, 16);
            replaceBits(resTemp, 15, 0, arg1Low);
            replaceBits(resTemp, 31, 16, arg2High);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault PkhtbReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptShiftRmCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint32_t Dest = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptShiftRmCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptShiftRmCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            
            uint32_t resTemp = 0;
            uint16_t arg1High = bits(Op1, 31, 16);
            uint16_t arg2Low = bits(shift_rm_imm(Op2, shiftAmt, shiftType, OptShiftRmCondCodesC), 15, 0);
            replaceBits(resTemp, 15, 0, arg2Low);
            replaceBits(resTemp, 31, 16, arg1High);
            Dest = resTemp;
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault B::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NPC;
uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        NPC = (uint32_t)(PC + imm);
        ;
            if (fault == NoFault)
            {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Bl::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NPC;
uint32_t PC;
uint32_t Thumb;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t LR = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
Thumb = __parserAutoPCState.thumb();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        NPC = (uint32_t)(PC + imm);
        
                if (Thumb)
                    LR = PC | 1;
                else
                    LR = PC - 4;
            ;
            if (fault == NoFault)
            {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);

        
        {
            uint32_t final_val = LR;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BlxImm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NextThumb;
uint32_t Thumb;
uint32_t PC;
uint32_t NPC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t LR = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Thumb = __parserAutoPCState.thumb();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    
                // The immediate version of the blx thumb instruction
                // is 32 bits wide, but "next pc" doesn't reflect that
                // so we don't want to substract 2 from it at this point
                if (Thumb)
                    LR = PC  | 1;
                else
                    LR = PC - 4;
            
    // Switch modes
    
                NextThumb = !Thumb;
                NPC = (Thumb ? (roundDown(PC, 4) + imm) : (PC + imm));
            
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.nextThumb(NextThumb);
__parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);

        
        {
            uint32_t final_val = LR;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BlxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Thumb;
uint32_t PC;
uint32_t IWNPC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t LR = 0;
uint32_t Op1 = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
Thumb = __parserAutoPCState.thumb();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    
                if (Thumb)
                    LR = (PC - 2) | 1;
                else
                    LR = PC - 4;
            
    // Switch modes
    IWNPC = Op1;
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.instIWNPC(IWNPC);
xc->pcState(__parserAutoPCState);

        
        {
            uint32_t final_val = LR;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault BxReg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t IWNPC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    
    // Switch modes
    IWNPC = Op1;
    ;
            if (fault == NoFault)
            {
                __parserAutoPCState.instIWNPC(IWNPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Cbz::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NPC;
uint32_t PC;
uint32_t Op1 = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 0))
    ;
;

        if (Op1 == 0)
        {
            NPC = (uint32_t)(PC + imm);
;
            if (fault == NoFault)
            {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Cbnz::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t NPC;
uint32_t PC;
uint32_t Op1 = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 0))
    ;
;

        if (Op1 != 0)
        {
            NPC = (uint32_t)(PC + imm);
;
            if (fault == NoFault)
            {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Tbb::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t NPC;
uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint8_t Mem = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        
            unsigned memAccessFlags = ArmISA::TLB::AllowUnaligned |
                                      ArmISA::TLB::AlignByte |
                                      ArmISA::TLB::MustBeOne;
            EA = Op1 + Op2
            ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                NPC = PC + 2 * (Mem);
            }

            if (fault == NoFault) {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Tbb::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint8_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        
            unsigned memAccessFlags = ArmISA::TLB::AllowUnaligned |
                                      ArmISA::TLB::AlignByte |
                                      ArmISA::TLB::MustBeOne;
            EA = Op1 + Op2
            ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Tbb::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t NPC;
uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint8_t Mem = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                NPC = PC + 2 * (Mem);
            }

            if (fault == NoFault) {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        }

        return fault;
    }

    Fault Tbh::execute(O3DynInst *xc,
                                  Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t NPC;
uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint16_t Mem = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        
            unsigned memAccessFlags = ArmISA::TLB::AllowUnaligned |
                                      ArmISA::TLB::AlignHalfWord |
                                      ArmISA::TLB::MustBeOne;
            EA = Op1 + Op2 * 2
            ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemAtomic(xc, traceData, EA, Mem, memAccessFlags);
                NPC = PC + 2 * (Mem);
;
            }

            if (fault == NoFault) {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Tbh::initiateAcc(O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Addr EA;
        Fault fault = NoFault;

        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t Op2 = 0;
uint16_t Mem = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;
        
            unsigned memAccessFlags = ArmISA::TLB::AllowUnaligned |
                                      ArmISA::TLB::AlignHalfWord |
                                      ArmISA::TLB::MustBeOne;
            EA = Op1 + Op2 * 2
            ;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            if (fault == NoFault) {
                fault = readMemTiming(xc, traceData, EA, Mem, memAccessFlags);
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Tbh::completeAcc(PacketPtr pkt,
                                      O3DynInst *xc,
                                      Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;

        uint32_t NPC;
uint32_t PC;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint16_t Mem = 0;
TheISA::PCState __parserAutoPCState;
;
        __parserAutoPCState = xc->pcState();
PC = __parserAutoPCState.instPC();
OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            // ARM instructions will not have a pkt if the predicate is false
            getMem(pkt, Mem, traceData);

            if (fault == NoFault) {
                NPC = PC + 2 * (Mem);
;
            }

            if (fault == NoFault) {
                __parserAutoPCState.instNPC(NPC);
xc->pcState(__parserAutoPCState);
;
            }
        }

        return fault;
    }

    Fault Mla::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp = Reg1 * Reg2 + Reg3;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MlaCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp = Reg1 * Reg2 + Reg3;
        uint16_t _iz, _in;
        _in = (resTemp >> 31) & 1;
        _iz = ((uint32_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mls::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg3 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp = Reg3 - Reg1 * Reg2;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Mul::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp = Reg1 * Reg2;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault MulCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp = Reg1 * Reg2;
        uint16_t _iz, _in;
        _in = (resTemp >> 31) & 1;
        _iz = ((uint32_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlabbCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 15, 0)) +
                                        Reg3;
                                 resTemp = bits(resTemp, 32) !=
                                           bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlabtCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 31, 16)) +
                                        Reg3;
                                 resTemp = bits(resTemp, 32) !=
                                           bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlatbCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 15, 0)) +
                                        Reg3;
                                 resTemp = bits(resTemp, 32) !=
                                           bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlattCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 31, 16)) +
                                        Reg3;
                                 resTemp = bits(resTemp, 32) !=
                                           bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmladCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 31, 16)) +
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 15, 0)) +
                                        Reg3;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmladxCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                         sext<16>(bits(Reg1, 31, 16)) *
                                         sext<16>(bits(Reg2, 15, 0)) +
                                         sext<16>(bits(Reg1, 15, 0)) *
                                         sext<16>(bits(Reg2, 31, 16)) +
                                         Reg3;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlal::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<32>(Reg2) * sext<32>(Reg3) +
                                       (int64_t)((Reg1 << 32) | Reg0);
                                   Reg0 = (uint32_t)resTemp;
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlalCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<32>(Reg2) * sext<32>(Reg3) +
                                       (int64_t)((Reg1 << 32) | Reg0);
                                   Reg0 = (uint32_t)resTemp;
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                
        uint16_t _iz, _in;
        _in = (resTemp >> 63) & 1;
        _iz = ((uint64_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlalbb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<16>(bits(Reg2, 15, 0)) *
                                               sext<16>(bits(Reg3, 15, 0)) +
                                               (int64_t)((Reg1 << 32) |
                                                         Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlalbt::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<16>(bits(Reg2, 15, 0)) *
                                               sext<16>(bits(Reg3, 31, 16)) +
                                               (int64_t)((Reg1 << 32) |
                                                         Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlaltb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<16>(bits(Reg2, 31, 16)) *
                                               sext<16>(bits(Reg3, 15, 0)) +
                                               (int64_t)((Reg1 << 32) |
                                                         Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlaltt::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = sext<16>(bits(Reg2, 31, 16)) *
                                               sext<16>(bits(Reg3, 31, 16)) +
                                               (int64_t)((Reg1 << 32) |
                                                         Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlald::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp =
                                        sext<16>(bits(Reg2, 31, 16)) *
                                        sext<16>(bits(Reg3, 31, 16)) +
                                        sext<16>(bits(Reg2, 15, 0)) *
                                        sext<16>(bits(Reg3, 15, 0)) +
                                        (int64_t)((Reg1 << 32) |
                                                  Reg0);
                                    Reg0 = (uint32_t)resTemp;
                                    Reg1 = (uint32_t)(resTemp >> 32);
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlaldx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp =
                                         sext<16>(bits(Reg2, 31, 16)) *
                                         sext<16>(bits(Reg3, 15, 0)) +
                                         sext<16>(bits(Reg2, 15, 0)) *
                                         sext<16>(bits(Reg3, 31, 16)) +
                                         (int64_t)((Reg1 << 32) |
                                                   Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlawbCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        (Reg1 *
                                         sext<16>(bits(Reg2, 15, 0)) +
                                         ((int64_t)Reg3 << 16)) >> 16;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlawtCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        (Reg1 *
                                         sext<16>(bits(Reg2, 31, 16)) +
                                         ((int64_t)Reg3 << 16)) >> 16;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlsdCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                       sext<16>(bits(Reg1, 15, 0)) *
                                       sext<16>(bits(Reg2, 15, 0)) -
                                       sext<16>(bits(Reg1, 31, 16)) *
                                       sext<16>(bits(Reg2, 31, 16)) +
                                       Reg3;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmlsdxCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
int32_t Reg3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 31, 16)) -
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 15, 0)) +
                                        Reg3;
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlsld::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp =
                                        sext<16>(bits(Reg2, 15, 0)) *
                                        sext<16>(bits(Reg3, 15, 0)) -
                                        sext<16>(bits(Reg2, 31, 16)) *
                                        sext<16>(bits(Reg3, 31, 16)) +
                                        (int64_t)((Reg1 << 32) |
                                                  Reg0);
                                    Reg0 = (uint32_t)resTemp;
                                    Reg1 = (uint32_t)(resTemp >> 32);
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smlsldx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg2 = 0;
uint32_t Reg3 = 0;
uint64_t Reg1 = 0;
uint64_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp =
                                         sext<16>(bits(Reg2, 15, 0)) *
                                         sext<16>(bits(Reg3, 31, 16)) -
                                         sext<16>(bits(Reg2, 31, 16)) *
                                         sext<16>(bits(Reg3, 15, 0)) +
                                         (int64_t)((Reg1 << 32) |
                                                   Reg0);
                                     Reg0 = (uint32_t)resTemp;
                                     Reg1 = (uint32_t)(resTemp >> 32);
                                  ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmla::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint64_t Reg3 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                       ((int64_t)(Reg3 << 32) +
                                        (int64_t)Reg1 *
                                        (int64_t)Reg2) >> 32;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmlar::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint64_t Reg3 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        ((int64_t)(Reg3 << 32) +
                                         (int64_t)Reg1 *
                                         (int64_t)Reg2 +
                                         ULL(0x80000000)) >> 32;
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmls::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint64_t Reg3 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                       ((int64_t)(Reg3 << 32) -
                                        (int64_t)Reg1 *
                                        (int64_t)Reg2) >> 32;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmlsr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint64_t Reg3 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        ((int64_t)(Reg3 << 32) -
                                         (int64_t)Reg1 *
                                         (int64_t)Reg2 +
                                         ULL(0x80000000)) >> 32;
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmul::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                       ((int64_t)Reg1 *
                                        (int64_t)Reg2) >> 32;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smmulr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
int32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        ((int64_t)Reg1 *
                                         (int64_t)Reg2 +
                                         ULL(0x80000000)) >> 32;
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmuadCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 15, 0)) +
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 31, 16));
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmuadxCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t CpsrQ = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 31, 16)) +
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 15, 0));
                                    resTemp = bits(resTemp, 32) !=
                                              bits(resTemp, 31);
                                 
        CpsrQ = (resTemp & 1) << 27;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, CpsrQ);
if (traceData) { traceData->setData(CpsrQ); }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smulbb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                         sext<16>(bits(Reg1, 15, 0)) *
                                         sext<16>(bits(Reg2, 15, 0));
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smulbt::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                         sext<16>(bits(Reg1, 15, 0)) *
                                         sext<16>(bits(Reg2, 31, 16));
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smultb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                         sext<16>(bits(Reg1, 31, 16)) *
                                         sext<16>(bits(Reg2, 15, 0));
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smultt::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                         sext<16>(bits(Reg1, 31, 16)) *
                                         sext<16>(bits(Reg2, 31, 16));
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smull::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
uint32_t Reg1 = 0;
uint32_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = (int64_t)Reg2 *
                                             (int64_t)Reg3;
                                   Reg1 = (int32_t)(resTemp >> 32);
                                   Reg0 = (int32_t)resTemp;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault SmullCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Reg2 = 0;
int32_t Reg3 = 0;
uint32_t Reg1 = 0;
uint32_t Reg0 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = (int64_t)Reg2 *
                                             (int64_t)Reg3;
                                   Reg1 = (int32_t)(resTemp >> 32);
                                   Reg0 = (int32_t)resTemp;
                                
        uint16_t _iz, _in;
        _in = (resTemp >> 63) & 1;
        _iz = ((uint64_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smulwb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        (Reg1 *
                                         sext<16>(bits(Reg2, 15, 0))) >> 16;
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smulwt::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
int32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        (Reg1 *
                                         sext<16>(bits(Reg2, 31, 16))) >> 16;
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smusd::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 15, 0)) -
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 31, 16));
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Smusdx::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Reg0 = 0;
uint32_t Reg1 = 0;
uint32_t Reg2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            Reg0 = resTemp =
                                        sext<16>(bits(Reg1, 15, 0)) *
                                        sext<16>(bits(Reg2, 31, 16)) -
                                        sext<16>(bits(Reg1, 31, 16)) *
                                        sext<16>(bits(Reg2, 15, 0));
                                 ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Umaal::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Reg2 = 0;
uint64_t Reg3 = 0;
uint64_t Reg0 = 0;
uint64_t Reg1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Reg2 * Reg3 +
                                             Reg0 + Reg1;
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                   Reg0 = (uint32_t)resTemp;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 1, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Umlal::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Reg2 = 0;
uint64_t Reg3 = 0;
uint64_t Reg0 = 0;
uint64_t Reg1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Reg2 * Reg3 + Reg0 +
                                             (Reg1 << 32);
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                   Reg0 = (uint32_t)resTemp;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 1, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UmlalCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Reg2 = 0;
uint64_t Reg3 = 0;
uint64_t Reg0 = 0;
uint64_t Reg1 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
Reg0 = 
        ((reg0 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
Reg1 = 
        ((reg1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Reg2 * Reg3 + Reg0 +
                                             (Reg1 << 32);
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                   Reg0 = (uint32_t)resTemp;
                                
        uint16_t _iz, _in;
        _in = (resTemp >> 63) & 1;
        _iz = ((uint64_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 0, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 1, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Umull::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Reg2 = 0;
uint64_t Reg3 = 0;
uint32_t Reg1 = 0;
uint32_t Reg0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Reg2 * Reg3;
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                   Reg0 = (uint32_t)resTemp;
                                ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault UmullCc::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint64_t Reg2 = 0;
uint64_t Reg3 = 0;
uint32_t Reg1 = 0;
uint32_t Reg0 = 0;
uint32_t CondCodesNZ = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Reg2 = 
        ((reg2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Reg3 = 
        ((reg3 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 4))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode)/*auto*/)
        {
            resTemp = Reg2 * Reg3;
                                   Reg1 = (uint32_t)(resTemp >> 32);
                                   Reg0 = (uint32_t)resTemp;
                                
        uint16_t _iz, _in;
        _in = (resTemp >> 63) & 1;
        _iz = ((uint64_t)resTemp == 0);
        CondCodesNZ = (_in << 1) | _iz;
        DPRINTF(Arm, "(in, iz) = (%d, %d)\n", _in, _iz);
       ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Reg1;
            
        ((reg1 == PCReg) ? setNextPC(xc, Reg1) :
         xc->setIntRegOperand(this, 0, Reg1))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Reg0;
            
        ((reg0 == PCReg) ? setNextPC(xc, Reg0) :
         xc->setIntRegOperand(this, 1, Reg0))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Sdiv::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
int32_t Op2 = 0;
uint32_t Sctlr = 0;
int32_t Dest = 0;
int32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Sctlr = xc->readMiscRegOperand(this, 4);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    if (Op2 == 0) {
        if (((SCTLR)Sctlr).dz) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
        Dest = 0;
    } else if (Op1 == INT_MIN && Op2 == -1) {
        Dest = INT_MIN;
    } else {
        Dest = Op1 / Op2;
    }
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Udiv::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op2 = 0;
uint32_t Sctlr = 0;
uint32_t Dest = 0;
uint32_t Op1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
Sctlr = xc->readMiscRegOperand(this, 4);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    if (Op2 == 0) {
        if (((SCTLR)Sctlr).dz) {
            if (FullSystem)
                return new UndefinedInstruction;
            else
                return new UndefinedInstruction(false, mnemonic);
        }
        Dest = 0;
    } else {
        Dest = Op1 / Op2;
    }
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Vmsr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t MiscDest = 0;
uint32_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr))
            if (dest != (int)MISCREG_FPEXC && dest != (int)MISCREG_FPSID)
                return disabledFault();
        if (!inPrivilegedMode(Cpsr))
            if (dest != (int)MISCREG_FPSCR)
                return disabledFault();
    MiscDest = Op1;;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, MiscDest);
if (traceData) { traceData->setData(MiscDest); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmsrFpscr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpscr = 0;
uint32_t Op1 = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 5))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr))
            if (dest != (int)MISCREG_FPEXC && dest != (int)MISCREG_FPSID)
                return disabledFault();
        if (!inPrivilegedMode(Cpsr))
            if (dest != (int)MISCREG_FPSCR)
                return disabledFault();
    
    Fpscr = Op1 & ~FpCondCodesMask;
    FpCondCodes = Op1 & FpCondCodesMask;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, Fpscr);
if (traceData) { traceData->setData(Fpscr); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Vmrs::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Dest = 0;
uint32_t MiscOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
MiscOp1 = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr))
            if (op1 != (int)MISCREG_FPEXC && op1 != (int)MISCREG_FPSID &&
                op1 != (int)MISCREG_MVFR0 && op1 != (int)MISCREG_MVFR1)
                return disabledFault();
        if (!inPrivilegedMode(Cpsr))
            if (op1 != (int)MISCREG_FPSCR)
                return disabledFault();
    Dest = MiscOp1;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmrsFpscr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Dest = 0;
uint32_t Fpscr = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpscr = xc->readMiscRegOperand(this, 5);
FpCondCodes = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr))
            if (op1 != (int)MISCREG_FPEXC && op1 != (int)MISCREG_FPSID &&
                op1 != (int)MISCREG_MVFR0 && op1 != (int)MISCREG_MVFR1)
                return disabledFault();
        if (!inPrivilegedMode(Cpsr))
            if (op1 != (int)MISCREG_FPSCR)
                return disabledFault();
    Dest = Fpscr | FpCondCodes;;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmrsApsrFpscr::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t FpCondCodes = 0;
uint32_t CondCodesNZ = 0;
uint32_t CondCodesC = 0;
uint32_t CondCodesV = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
FpCondCodes = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr))
                return disabledFault();
    
        FPSCR fpscr = FpCondCodes;
        CondCodesNZ = (fpscr.n << 1) | fpscr.z;
        CondCodesC = fpscr.c;
        CondCodesV = fpscr.v;
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = CondCodesNZ;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesC;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = CondCodesV;
            xc->setIntRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovImmS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDest = bits(imm, 31, 0);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovImmD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDestP0 = bits(imm, 31, 0);
        FpDestP1 = bits(imm, 63, 32);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovImmQ::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDestP0 = bits(imm, 31, 0);
        FpDestP1 = bits(imm, 63, 32);
        FpDestP2 = bits(imm, 31, 0);
        FpDestP3 = bits(imm, 63, 32);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDest = FpOp1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDestP0 = FpOp1P0;
        FpDestP1 = FpOp1P1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegQ::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpOp1P3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDestP0 = FpOp1P0;
        FpDestP1 = FpOp1P1;
        FpDestP2 = FpOp1P2;
        FpDestP3 = FpOp1P3;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovCoreRegB::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint8_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDest = xc->readFloatRegOperandBits(this, 6);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDest = insertBits(FpDest, imm * 8 + 7, imm * 8, Op1);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovCoreRegH::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint16_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDest = xc->readFloatRegOperandBits(this, 6);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDest = insertBits(FpDest, imm * 16 + 15, imm * 16, Op1);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovCoreRegW::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDest = 0;
uint32_t Op1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDest = Op1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegCoreUB::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        assert(imm < 4);
        Dest = bits(FpOp1, imm * 8 + 7, imm * 8);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegCoreUH::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        assert(imm < 2);
        Dest = bits(FpOp1, imm * 16 + 15, imm * 16);
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegCoreSB::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        assert(imm < 4);
        Dest = sext<8>(bits(FpOp1, imm * 8 + 7, imm * 8));
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegCoreSH::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        assert(imm < 2);
        Dest = sext<16>(bits(FpOp1, imm * 16 + 15, imm * 16));
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmovRegCoreW::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1 = xc->readFloatRegOperandBits(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        Dest = FpOp1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Vmov2Reg2Core::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t Op1 = 0;
uint32_t FpDestP1 = 0;
uint32_t Op2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 6))
    ;
Op2 = 
        ((op2 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 7))
    ;
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FpDestP0 = Op1;
        FpDestP1 = Op2;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Vmov2Core2Reg::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t Dest = 0;
uint32_t FpOp2P0 = 0;
uint32_t Op1 = 0;
uint32_t FpOp2P1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp2P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P1 = xc->readFloatRegOperandBits(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        Dest = FpOp2P0;
        Op1 = FpOp2P1;
    ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = Dest;
            
        ((dest == PCReg) ? setNextPC(xc, Dest) :
         xc->setIntRegOperand(this, 0, Dest))
    ;
            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = Op1;
            
        ((op1 == PCReg) ? setNextPC(xc, Op1) :
         xc->setIntRegOperand(this, 1, Op1))
    ;
            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VaddS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
float FpOp2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = binaryOp(fpscr, FpOp1, FpOp2,fpAddS, fpscr.fz, fpscr.dn, fpscr.rMode);
    
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VaddD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = 
        binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                        dbl(FpOp2P0, FpOp2P1),
                        fpAddD, fpscr.fz, fpscr.dn, fpscr.rMode);
    ;
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VsubS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
float FpOp2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = binaryOp(fpscr, FpOp1, FpOp2,fpSubS, fpscr.fz, fpscr.dn, fpscr.rMode);
    
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VsubD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = 
        binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                        dbl(FpOp2P0, FpOp2P1),
                        fpSubD, fpscr.fz, fpscr.dn, fpscr.rMode);
    ;
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VdivS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
float FpOp2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = binaryOp(fpscr, FpOp1, FpOp2,fpDivS, fpscr.fz, fpscr.dn, fpscr.rMode);
    
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VdivD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = 
        binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                        dbl(FpOp2P0, FpOp2P1),
                        fpDivD, fpscr.fz, fpscr.dn, fpscr.rMode);
    ;
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmulS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
float FpOp2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = binaryOp(fpscr, FpOp1, FpOp2,fpMulS, fpscr.fz, fpscr.dn, fpscr.rMode);
    
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmulD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = 
        binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                        dbl(FpOp2P0, FpOp2P1),
                        fpMulD, fpscr.fz, fpscr.dn, fpscr.rMode);
    ;
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VsqrtS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = unaryOp(fpscr, FpOp1, sqrtf, fpscr.fz, fpscr.rMode);
    
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VsqrtD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = 
        unaryOp(fpscr, dbl(FpOp1P0, FpOp1P1), sqrt,
                fpscr.fz, fpscr.rMode)
    ;
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnegS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = -FpOp1;
    ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnegD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = -dbl(FpOp1P0, FpOp1P1);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VabsS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        FpDest = fabsf(FpOp1);
    ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VabsD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr M5_VAR_USED = (FPSCR) FpscrExc;
        double dest = fabs(dbl(FpOp1P0, FpOp1P1));
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmlaS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpOp2 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
FpDest = xc->readFloatRegOperand(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, FpOp1, FpOp2,
                fpMulS, fpscr.fz, fpscr.dn, fpscr.rMode);
        FpDest = binaryOp(fpscr, FpDest, mid, fpAddS,
                fpscr.fz, fpscr.dn, fpscr.rMode);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmlaD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP0 = xc->readFloatRegOperandBits(this, 11);
FpDestP1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double mid = binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                                     dbl(FpOp2P0, FpOp2P1),
                                     fpMulD, fpscr.fz, fpscr.dn, fpscr.rMode);
        double dest = binaryOp(fpscr, dbl(FpDestP0, FpDestP1),
                                      mid, fpAddD, fpscr.fz,
                                      fpscr.dn, fpscr.rMode);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmlsS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpOp2 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
FpDest = xc->readFloatRegOperand(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, FpOp1, FpOp2,
                fpMulS, fpscr.fz, fpscr.dn, fpscr.rMode);
        FpDest = binaryOp(fpscr, FpDest, -mid, fpAddS,
                fpscr.fz, fpscr.dn, fpscr.rMode);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VmlsD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP0 = xc->readFloatRegOperandBits(this, 11);
FpDestP1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double mid = binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                                     dbl(FpOp2P0, FpOp2P1),
                                     fpMulD, fpscr.fz, fpscr.dn, fpscr.rMode);
        double dest = binaryOp(fpscr, dbl(FpDestP0, FpDestP1),
                                      -mid, fpAddD, fpscr.fz,
                                      fpscr.dn, fpscr.rMode);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmlaS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpOp2 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
FpDest = xc->readFloatRegOperand(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, FpOp1, FpOp2,
                fpMulS, fpscr.fz, fpscr.dn, fpscr.rMode);
        FpDest = binaryOp(fpscr, -FpDest, -mid, fpAddS,
                fpscr.fz, fpscr.dn, fpscr.rMode);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmlaD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP0 = xc->readFloatRegOperandBits(this, 11);
FpDestP1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double mid = binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                                     dbl(FpOp2P0, FpOp2P1),
                                     fpMulD, fpscr.fz, fpscr.dn, fpscr.rMode);
        double dest = binaryOp(fpscr, -dbl(FpDestP0, FpDestP1),
                                      -mid, fpAddD, fpscr.fz,
                                      fpscr.dn, fpscr.rMode);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmlsS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpOp2 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
FpDest = xc->readFloatRegOperand(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, FpOp1, FpOp2,
                fpMulS, fpscr.fz, fpscr.dn, fpscr.rMode);
        FpDest = binaryOp(fpscr, -FpDest, mid, fpAddS,
                fpscr.fz, fpscr.dn, fpscr.rMode);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmlsD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP0 = xc->readFloatRegOperandBits(this, 11);
FpDestP1 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double mid = binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                                     dbl(FpOp2P0, FpOp2P1),
                                     fpMulD, fpscr.fz, fpscr.dn, fpscr.rMode);
        double dest = binaryOp(fpscr, -dbl(FpDestP0, FpDestP1),
                                      mid, fpAddD, fpscr.fz,
                                      fpscr.dn, fpscr.rMode);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmulS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
float FpOp2 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpOp2 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        FpDest = -binaryOp(fpscr, FpOp1, FpOp2, fpMulS,
                fpscr.fz, fpscr.dn, fpscr.rMode);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VnmulD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P0 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double dest = -binaryOp(fpscr, dbl(FpOp1P0, FpOp1P1),
                                       dbl(FpOp2P0, FpOp2P1),
                                       fpMulD, fpscr.fz, fpscr.dn,
                                       fpscr.rMode);
        FpDestP0 = dblLow(dest);
        FpDestP1 = dblHi(dest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUIntFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = FpOp1;
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUIntFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1P0) : "m" (FpOp1P0));
        double cDest = (uint64_t)FpOp1P0;
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSIntFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
int32_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = FpOp1;
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSIntFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
int32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1P0) : "m" (FpOp1P0));
        double cDest = FpOp1P0;
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUIntSR::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        vfpFlushToZero(fpscr, FpOp1);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, false, false, 0, false);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUIntDR::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t result = vfpFpDToFixed(cOp1, false, false, 0, false);
        __asm__ __volatile__("" :: "m" (result));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = result;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSIntSR::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
int32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        vfpFlushToZero(fpscr, FpOp1);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, true, false, 0, false);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            int32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSIntDR::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        int64_t result = vfpFpDToFixed(cOp1, true, false, 0, false);
        __asm__ __volatile__("" :: "m" (result));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = result;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUIntS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        fesetround(FeRoundZero);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, false, false, 0);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUIntD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        fesetround(FeRoundZero);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t result = vfpFpDToFixed(cOp1, false, false, 0);
        __asm__ __volatile__("" :: "m" (result));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = result;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSIntS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
int32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        fesetround(FeRoundZero);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, true, false, 0);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            int32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSIntD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        fesetround(FeRoundZero);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        int64_t result = vfpFpDToFixed(cOp1, true, false, 0);
        __asm__ __volatile__("" :: "m" (result));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = result;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        double cDest = fixFpSFpDDest(FpscrExc, FpOp1);
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpDFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDest = xc->readFloatRegOperand(this, 9);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        FpDest = fixFpDFpSDest(FpscrExc, cOp1);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpHTFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vcvtFpHFpS(fpscr, fpscr.dn, fpscr.ahp,
                            bits(fpToBits(FpOp1), 31, 16));
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpHBFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vcvtFpHFpS(fpscr, fpscr.dn, fpscr.ahp,
                            bits(fpToBits(FpOp1), 15, 0));
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSFpHT::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vcvtFpHFpS(fpscr, fpscr.dn, fpscr.ahp,
                            bits(fpToBits(FpOp1), 31, 16));
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSFpHB::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1), "=m" (FpDest)
                                : "m" (FpOp1), "m" (FpDest));
        FpDest = insertBits(FpDest, 15, 0,
                               vcvtFpSFpH(fpscr, fpscr.fz, fpscr.dn,
                               fpscr.rMode, fpscr.ahp, FpOp1));
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpDest = xc->readFloatRegOperand(this, 7);
FpOp1 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpDest, FpOp1);
        if (FpDest == FpOp1) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < FpOp1) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > FpOp1) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            const uint32_t qnan = 0x7fc00000;
            const bool nan1 = std::isnan(FpDest);
            const bool signal1 = nan1 && ((fpToBits(FpDest) & qnan) != qnan);
            const bool nan2 = std::isnan(FpOp1);
            const bool signal2 = nan2 && ((fpToBits(FpOp1) & qnan) != qnan);
            if (signal1 || signal2)
                fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        double cDest = dbl(FpDestP0, FpDestP1);
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, cDest, cOp1);
        if (cDest == cOp1) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest < cOp1) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest > cOp1) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            const uint64_t qnan = ULL(0x7ff8000000000000);
            const bool nan1 = std::isnan(cDest);
            const bool signal1 = nan1 && ((fpToBits(cDest) & qnan) != qnan);
            const bool nan2 = std::isnan(cOp1);
            const bool signal2 = nan2 && ((fpToBits(cOp1) & qnan) != qnan);
            if (signal1 || signal2)
                fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpZeroS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpDest = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpDest);
        // This only handles imm == 0 for now.
        assert(imm == 0);
        if (FpDest == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            const uint32_t qnan = 0x7fc00000;
            const bool nan = std::isnan(FpDest);
            const bool signal = nan && ((fpToBits(FpDest) & qnan) != qnan);
            if (signal)
                fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpZeroD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        // This only handles imm == 0 for now.
        assert(imm == 0);
        double cDest = dbl(FpDestP0, FpDestP1);
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, cDest);
        if (cDest == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            const uint64_t qnan = ULL(0x7ff8000000000000);
            const bool nan = std::isnan(cDest);
            const bool signal = nan && ((fpToBits(cDest) & qnan) != qnan);
            if (signal)
                fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpeS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
float FpOp1 = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpDest = xc->readFloatRegOperand(this, 7);
FpOp1 = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpDest, FpOp1);
        if (FpDest == FpOp1) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < FpOp1) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > FpOp1) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpeD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        double cDest = dbl(FpDestP0, FpDestP1);
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, cDest, cOp1);
        if (cDest == cOp1) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest < cOp1) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest > cOp1) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpeZeroS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpDest = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpDest = xc->readFloatRegOperand(this, 7);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpDest);
        if (FpDest == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (FpDest < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (FpDest > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcmpeZeroD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpCondCodes = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        double cDest = dbl(FpDestP0, FpDestP1);
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, cDest);
        if (cDest == imm) {
            fpscr.n = 0; fpscr.z = 1; fpscr.c = 1; fpscr.v = 0;
        } else if (cDest < imm) {
            fpscr.n = 1; fpscr.z = 0; fpscr.c = 0; fpscr.v = 0;
        } else if (cDest > imm) {
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 0;
        } else {
            fpscr.ioc = 1;
            fpscr.n = 0; fpscr.z = 0; fpscr.c = 1; fpscr.v = 1;
        }
        FpCondCodes = fpscr & FpCondCodesMask;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        
        {
            uint32_t final_val = FpCondCodes;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSFixedS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
int32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, true, false, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            int32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSFixedD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t mid = vfpFpDToFixed(cOp1, true, false, imm);
        __asm__ __volatile__("" :: "m" (mid));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = mid;
        FpDestP1 = mid >> 32;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUFixedS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint32_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, false, false, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUFixedD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t mid = vfpFpDToFixed(cOp1, false, false, imm);
        __asm__ __volatile__("" :: "m" (mid));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = mid;
        FpDestP1 = mid >> 32;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSFixedFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
int32_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpSFixedToFpS(fpscr.fz, fpscr.dn, FpOp1, false, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSFixedFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        uint64_t mid = ((uint64_t)FpOp1P0 | ((uint64_t)FpOp1P1 << 32));
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (mid) : "m" (mid));
        double cDest = vfpSFixedToFpD(fpscr.fz, fpscr.dn, mid, false, imm);
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUFixedFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpUFixedToFpS(fpscr.fz, fpscr.dn, FpOp1, false, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUFixedFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        uint64_t mid = ((uint64_t)FpOp1P0 | ((uint64_t)FpOp1P1 << 32));
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (mid) : "m" (mid));
        double cDest = vfpUFixedToFpD(fpscr.fz, fpscr.dn, mid, false, imm);
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSHFixedS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
int16_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, true, true, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            int16_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpSHFixedD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t result = vfpFpDToFixed(cOp1, true, true, imm);
        __asm__ __volatile__("" :: "m" (result));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = result;
        FpDestP1 = result >> 32;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUHFixedS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
float FpOp1 = 0;
uint16_t FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperand(this, 7);
FpDest = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        vfpFlushToZero(fpscr, FpOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpFpSToFixed(FpOp1, false, true, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint16_t final_val = FpDest;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtFpUHFixedD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        double cOp1 = dbl(FpOp1P0, FpOp1P1);
        vfpFlushToZero(fpscr, cOp1);
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (cOp1) : "m" (cOp1));
        uint64_t mid = vfpFpDToFixed(cOp1, false, true, imm);
        __asm__ __volatile__("" :: "m" (mid));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = mid;
        FpDestP1 = mid >> 32;
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSHFixedFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
int16_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpSFixedToFpS(fpscr.fz, fpscr.dn, FpOp1, true, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtSHFixedFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        uint64_t mid = ((uint64_t)FpOp1P0 | ((uint64_t)FpOp1P1 << 32));
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (mid) : "m" (mid));
        double cDest = vfpSFixedToFpD(fpscr.fz, fpscr.dn, mid, true, imm);
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUHFixedFpS::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint16_t FpOp1 = 0;
float FpDest = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1 = xc->readFloatRegOperandBits(this, 7);
FpDest = xc->readFloatRegOperand(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (FpOp1) : "m" (FpOp1));
        FpDest = vfpUFixedToFpS(fpscr.fz, fpscr.dn, FpOp1, true, imm);
        __asm__ __volatile__("" :: "m" (FpDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDest;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault VcvtUHFixedFpD::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpscrExc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpscrExc = xc->readMiscRegOperand(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!vfpEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        FPSCR fpscr = (FPSCR) FpscrExc;
        uint64_t mid = ((uint64_t)FpOp1P0 | ((uint64_t)FpOp1P1 << 32));
        VfpSavedState state = prepFpState(fpscr.rMode);
        __asm__ __volatile__("" : "=m" (mid) : "m" (mid));
        double cDest = vfpUFixedToFpD(fpscr.fz, fpscr.dn, mid, true, imm);
        __asm__ __volatile__("" :: "m" (cDest));
        finishVfp(fpscr, state, fpscr.fz);
        FpDestP0 = dblLow(cDest);
        FpDestP1 = dblHi(cDest);
        FpscrExc = fpscr;
    ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    static float
    vcgtFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (op1 > op2) ? 0.0 : 1.0;
    }

    static float
    vcgeFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (op1 >= op2) ? 0.0 : 1.0;
    }

    static float
    vceqFunc(float op1, float op2)
    {
        if (isSnan(op1) || isSnan(op2))
            return 2.0;
        return (op1 == op2) ? 0.0 : 1.0;
    }

    static float
    vcleFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (op1 <= op2) ? 0.0 : 1.0;
    }

    static float
    vcltFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (op1 < op2) ? 0.0 : 1.0;
    }

    static float
    vacgtFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (fabsf(op1) > fabsf(op2)) ? 0.0 : 1.0;
    }

    static float
    vacgeFunc(float op1, float op2)
    {
        if (std::isnan(op1) || std::isnan(op2))
            return 2.0;
        return (fabsf(op1) >= fabsf(op2)) ? 0.0 : 1.0;
    }

    template <class Element>
    Fault VhaddD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element carryBit =
            (((unsigned)srcElem1 & 0x1) +
             ((unsigned)srcElem2 & 0x1)) >> 1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) +
                    ((srcElem2 & ~(Element)1) / 2)) + carryBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VhaddD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VhaddQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element carryBit =
            (((unsigned)srcElem1 & 0x1) +
             ((unsigned)srcElem2 & 0x1)) >> 1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) +
                    ((srcElem2 & ~(Element)1) / 2)) + carryBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VhaddQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhaddQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrhaddD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element carryBit =
            (((unsigned)srcElem1 & 0x1) +
             ((unsigned)srcElem2 & 0x1) + 1) >> 1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) +
                    ((srcElem2 & ~(Element)1) / 2)) + carryBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrhaddD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrhaddQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element carryBit =
            (((unsigned)srcElem1 & 0x1) +
             ((unsigned)srcElem2 & 0x1) + 1) >> 1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) +
                    ((srcElem2 & ~(Element)1) / 2)) + carryBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrhaddQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrhaddQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VhsubD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element barrowBit =
            (((srcElem1 & 0x1) - (srcElem2 & 0x1)) >> 1) & 0x1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) -
                    ((srcElem2 & ~(Element)1) / 2)) - barrowBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VhsubD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VhsubQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        Element barrowBit =
            (((srcElem1 & 0x1) - (srcElem2 & 0x1)) >> 1) & 0x1;
        // Use division instead of a shift to ensure the sign extension works
        // right. The compiler will figure out if it can be a shift. Mask the
        // inputs so they get truncated correctly.
        destElem = (((srcElem1 & ~(Element)1) / 2) -
                    ((srcElem2 & ~(Element)1) / 2)) - barrowBit;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VhsubQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VhsubQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VandD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 & srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VandD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VandQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 & srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VandQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VandQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbicD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 & ~srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbicD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbicQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 & ~srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbicQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbicQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VorrD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VorrD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VorrQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VorrQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VorrQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmovD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmovD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmovQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmovQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmovQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VornD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | ~srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VornD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VornQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 | ~srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VornQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VornQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VeorD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 ^ srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VeorD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VeorQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 ^ srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VeorQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VeorQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbifD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (destElem & srcElem2) | (srcElem1 & ~srcElem2);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbifD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbifQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (destElem & srcElem2) | (srcElem1 & ~srcElem2);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbifQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbifQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbitD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (srcElem1 & srcElem2) | (destElem & ~srcElem2);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbitD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbitQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (srcElem1 & srcElem2) | (destElem & ~srcElem2);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbitQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbitQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbslD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (srcElem1 & destElem) | (srcElem2 & ~destElem);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbslD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VbslQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = (srcElem1 & destElem) | (srcElem2 & ~destElem);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VbslQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VbslQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmaxD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 > srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmaxD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmaxQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 > srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmaxQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmaxQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VminD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 < srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VminD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VminQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 < srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VminQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VminQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVaddD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVaddD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVaddQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVaddQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVaddQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVpaddD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i] :
                                        srcReg2.elements[2 * i - eCount]);
                Element srcElem2 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i + 1] :
                                        srcReg2.elements[2 * i + 1 - eCount]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVpaddD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vaddl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vaddl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vaddw<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vaddw<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddw<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddw<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddw<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddw<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddw<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vaddhn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
FpOp2P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            BigRegVect srcReg2;
            RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg2.regs[3] = htog(FpOp2P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            Element destElem;
            
            
        destElem = ((BigElement)srcElem1 + (BigElement)srcElem2) >>
                   (sizeof(Element) * 8);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vaddhn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddhn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddhn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddhn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddhn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vaddhn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vraddhn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
FpOp2P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            BigRegVect srcReg2;
            RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg2.regs[3] = htog(FpOp2P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            Element destElem;
            
            
        destElem = ((BigElement)srcElem1 + (BigElement)srcElem2 +
                    ((BigElement)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vraddhn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vraddhn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vraddhn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vraddhn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vraddhn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vraddhn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsubD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsubD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsubQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsubQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsubQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vsubl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 - (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vsubl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vsubw<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 - (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vsubw<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubw<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubw<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubw<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubw<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubw<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqaddUD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (destElem < srcElem1 || destElem < srcElem2) {
            destElem = (Element)(-1);
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqaddUD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqaddUQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (destElem < srcElem1 || destElem < srcElem2) {
            destElem = (Element)(-1);
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqaddUQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddUQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vsubhn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
FpOp2P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            BigRegVect srcReg2;
            RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg2.regs[3] = htog(FpOp2P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            Element destElem;
            
            
        destElem = ((BigElement)srcElem1 - (BigElement)srcElem2) >>
                   (sizeof(Element) * 8);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vsubhn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubhn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubhn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubhn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubhn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vsubhn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vrsubhn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpOp2P0 = xc->readFloatRegOperandBits(this, 10);
FpOp2P1 = xc->readFloatRegOperandBits(this, 11);
FpOp2P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            BigRegVect srcReg1;
            BigRegVect srcReg2;
            RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg2.regs[3] = htog(FpOp2P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement srcElem2 = gtoh(srcReg2.elements[i]);
            Element destElem;
            
            
        destElem = ((BigElement)srcElem1 - (BigElement)srcElem2 +
                    ((BigElement)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vrsubhn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vrsubhn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vrsubhn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vrsubhn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vrsubhn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vrsubhn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqaddSD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        bool negDest = (destElem < 0);
        bool negSrc1 = (srcElem1 < 0);
        bool negSrc2 = (srcElem2 < 0);
        if ((negDest != negSrc1) && (negSrc1 == negSrc2)) {
            destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            if (negDest)
                destElem -= 1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqaddSD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqaddSQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 + srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        bool negDest = (destElem < 0);
        bool negSrc1 = (srcElem1 < 0);
        bool negSrc2 = (srcElem2 < 0);
        if ((negDest != negSrc1) && (negSrc1 == negSrc2)) {
            destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            if (negDest)
                destElem -= 1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqaddSQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqaddSQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqsubUD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (destElem > srcElem1) {
            destElem = 0;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqsubUD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqsubUQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (destElem > srcElem1) {
            destElem = 0;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqsubUQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubUQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqsubSD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        bool negDest = (destElem < 0);
        bool negSrc1 = (srcElem1 < 0);
        bool posSrc2 = (srcElem2 >= 0);
        if ((negDest != negSrc1) && (negSrc1 == posSrc2)) {
            destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            if (negDest)
                destElem -= 1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqsubSD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqsubSQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 - srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        bool negDest = (destElem < 0);
        bool negSrc1 = (srcElem1 < 0);
        bool posSrc2 = (srcElem2 >= 0);
        if ((negDest != negSrc1) && (negSrc1 == posSrc2)) {
            destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            if (negDest)
                destElem -= 1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqsubSQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqsubSQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgtD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 > srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgtD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgtQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 > srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgtQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgtQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgeD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 >= srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgeD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgeQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 >= srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgeQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VcgeQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VceqD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 == srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VceqD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VceqQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem =  (srcElem1 == srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VceqQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VceqQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VshlD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (ltz(srcElem1) && !ltz(destElem)) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
        } else {
            if (shiftAmt >= sizeof(Element) * 8) {
                destElem = 0;
            } else {
                destElem = srcElem1 << shiftAmt;
            }
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VshlD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VshlQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (ltz(srcElem1) && !ltz(destElem)) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
        } else {
            if (shiftAmt >= sizeof(Element) * 8) {
                destElem = 0;
            } else {
                destElem = srcElem1 << shiftAmt;
            }
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VshlQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VshlQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrshlD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt > sizeof(Element) * 8 && ltz(srcElem1))
                rBit = 1;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (ltz(srcElem1) && !ltz(destElem)) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
            destElem += rBit;
        } else if (shiftAmt > 0) {
            if (shiftAmt >= sizeof(Element) * 8) {
                destElem = 0;
            } else {
                destElem = srcElem1 << shiftAmt;
            }
        } else {
            destElem = srcElem1;
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrshlD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrshlQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt > sizeof(Element) * 8 && ltz(srcElem1))
                rBit = 1;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (ltz(srcElem1) && !ltz(destElem)) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
            destElem += rBit;
        } else if (shiftAmt > 0) {
            if (shiftAmt >= sizeof(Element) * 8) {
                destElem = 0;
            } else {
                destElem = srcElem1 << shiftAmt;
            }
        } else {
            destElem = srcElem1;
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrshlQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VrshlQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqshlUD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
        } else if (shiftAmt > 0) {
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = 0;
                }
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - shiftAmt)) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqshlUD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqshlUQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
        } else if (shiftAmt > 0) {
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = 0;
                }
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - shiftAmt)) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqshlUQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlUQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqshlSD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (srcElem1 < 0 && destElem >= 0) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
        } else if (shiftAmt > 0) {
            bool sat = false;
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0)
                    sat = true;
                else
                    destElem = 0;
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - 1 - shiftAmt) !=
                        ((srcElem1 < 0) ? mask(shiftAmt + 1) : 0)) {
                    sat = true;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
            if (sat) {
                fpscr.qc = 1;
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqshlSD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqshlSQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (srcElem1 < 0 && destElem >= 0) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
        } else if (shiftAmt > 0) {
            bool sat = false;
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0)
                    sat = true;
                else
                    destElem = 0;
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - 1 - shiftAmt) !=
                        ((srcElem1 < 0) ? mask(shiftAmt + 1) : 0)) {
                    sat = true;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
            if (sat) {
                fpscr.qc = 1;
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqshlSQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqshlSQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrshlUD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            destElem += rBit;
        } else {
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = 0;
                }
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - shiftAmt)) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrshlUD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrshlUQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            destElem += rBit;
        } else {
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = 0;
                }
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - shiftAmt)) {
                    destElem = mask(sizeof(Element) * 8);
                    fpscr.qc = 1;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrshlUQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlUQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrshlSD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt > sizeof(Element) * 8 && srcElem1 < 0)
                rBit = 1;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (srcElem1 < 0 && destElem >= 0) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
            destElem += rBit;
        } else if (shiftAmt > 0) {
            bool sat = false;
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0)
                    sat = true;
                else
                    destElem = 0;
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - 1 - shiftAmt) !=
                        ((srcElem1 < 0) ? mask(shiftAmt + 1) : 0)) {
                    sat = true;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
            if (sat) {
                fpscr.qc = 1;
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrshlSD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrshlSQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        int16_t shiftAmt = (int8_t)srcElem2;
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (shiftAmt < 0) {
            shiftAmt = -shiftAmt;
            Element rBit = 0;
            if (shiftAmt <= sizeof(Element) * 8)
                rBit = bits(srcElem1, shiftAmt - 1);
            if (shiftAmt > sizeof(Element) * 8 && srcElem1 < 0)
                rBit = 1;
            if (shiftAmt >= sizeof(Element) * 8) {
                shiftAmt = sizeof(Element) * 8 - 1;
                destElem = 0;
            } else {
                destElem = (srcElem1 >> shiftAmt);
            }
            // Make sure the right shift sign extended when it should.
            if (srcElem1 < 0 && destElem >= 0) {
                destElem |= -((Element)1 << (sizeof(Element) * 8 -
                                             1 - shiftAmt));
            }
            destElem += rBit;
        } else if (shiftAmt > 0) {
            bool sat = false;
            if (shiftAmt >= sizeof(Element) * 8) {
                if (srcElem1 != 0)
                    sat = true;
                else
                    destElem = 0;
            } else {
                if (bits(srcElem1, sizeof(Element) * 8 - 1,
                            sizeof(Element) * 8 - 1 - shiftAmt) !=
                        ((srcElem1 < 0) ? mask(shiftAmt + 1) : 0)) {
                    sat = true;
                } else {
                    destElem = srcElem1 << shiftAmt;
                }
            }
            if (sat) {
                fpscr.qc = 1;
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrshlSQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrshlSQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabaD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem += (srcElem1 > srcElem2) ? (srcElem1 - srcElem2) :
                                            (srcElem2 - srcElem1);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabaD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabaQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem += (srcElem1 > srcElem2) ? (srcElem1 - srcElem2) :
                                            (srcElem2 - srcElem1);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabaQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabaQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vabal<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        destElem += (srcElem1 > srcElem2) ?
            ((BigElement)srcElem1 - (BigElement)srcElem2) :
            ((BigElement)srcElem2 - (BigElement)srcElem1);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vabal<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabal<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabal<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabal<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabal<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabal<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabdD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 > srcElem2) ? (srcElem1 - srcElem2) :
                                           (srcElem2 - srcElem1);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabdD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabdQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 > srcElem2) ? (srcElem1 - srcElem2) :
                                           (srcElem2 - srcElem1);
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabdQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VabdQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vabdl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (srcElem1 > srcElem2) ?
            ((BigElement)srcElem1 - (BigElement)srcElem2) :
            ((BigElement)srcElem2 - (BigElement)srcElem1);
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vabdl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabdl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabdl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabdl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabdl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vabdl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VtstD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 & srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VtstD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VtstQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = (srcElem1 & srcElem2) ? (Element)(-1) : 0;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VtstQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VtstQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmull<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 * (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmull<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmull<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmull<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmull<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmull<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmull<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlaD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem + srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlaD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlaQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem + srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlaQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlaQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmlal<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        destElem = destElem + (BigElement)srcElem1 * (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmlal<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlal<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlal<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlal<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlal<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlal<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmlal<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpscrQc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        BigElement midElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            midElem = ~((BigElement)maxNeg << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        bool negPreDest = ltz(destElem);
        destElem += midElem;
        bool negDest = ltz(destElem);
        bool negMid = ltz(midElem);
        if (negPreDest == negMid && negMid != negDest) {
            destElem = mask(sizeof(BigElement) * 8 - 1);
            if (negPreDest)
                destElem = ~destElem;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmlal<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlal<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlal<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlal<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlal<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlal<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmlsl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpscrQc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        BigElement midElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            midElem = ~((BigElement)maxNeg << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        bool negPreDest = ltz(destElem);
        destElem -= midElem;
        bool negDest = ltz(destElem);
        bool posMid = ltz((BigElement)-midElem);
        if (negPreDest == posMid && posMid != negDest) {
            destElem = mask(sizeof(BigElement) * 8 - 1);
            if (negPreDest)
                destElem = ~destElem;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmlsl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmull<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (Element)(sizeof(Element) * 8 - 1))) {
            destElem = ~((BigElement)srcElem1 << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmull<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmull<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmull<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmull<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmull<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmull<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem - srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlsD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem - srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlsQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmlsQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmlsl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        destElem = destElem - (BigElement)srcElem1 * (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmlsl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulpD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = 0;
        for (unsigned j = 0; j < sizeof(Element) * 8; j++) {
            if (bits(srcElem2, j))
                destElem ^= srcElem1 << j;
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulpD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulpQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        destElem = 0;
        for (unsigned j = 0; j < sizeof(Element) * 8; j++) {
            if (bits(srcElem2, j))
                destElem ^= srcElem1 << j;
        }
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulpQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmulpQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmullp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp2P0 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
            RegVect srcReg1;
            RegVect srcReg2;
            BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element srcElem2 = gtoh(srcReg2.elements[i]);
            BigElement destElem;
            
            
        destElem = 0;
        for (unsigned j = 0; j < sizeof(Element) * 8; j++) {
            if (bits(srcElem2, j))
                destElem ^= (BigElement)srcElem1 << j;
        }
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmullp<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmullp<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmullp<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpmaxD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i] :
                                        srcReg2.elements[2 * i - eCount]);
                Element srcElem2 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i + 1] :
                                        srcReg2.elements[2 * i + 1 - eCount]);
                Element destElem;
                
                
        destElem = (srcElem1 > srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpmaxD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpmaxD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpmaxD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpmaxD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpmaxD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpmaxD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpminD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i] :
                                        srcReg2.elements[2 * i - eCount]);
                Element srcElem2 = gtoh(2 * i < eCount ?
                                        srcReg1.elements[2 * i + 1] :
                                        srcReg2.elements[2 * i + 1 - eCount]);
                Element destElem;
                
                
        destElem = (srcElem1 < srcElem2) ? srcElem1 : srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpminD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpminD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpminD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpminD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpminD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VpminD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqdmulhD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2) >>
                   (sizeof(Element) * 8);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (sizeof(Element) * 8 - 1))) {
            destElem = ~srcElem1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqdmulhD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqdmulhQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2) >>
                   (sizeof(Element) * 8);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (sizeof(Element) * 8 - 1))) {
            destElem = ~srcElem1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqdmulhQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrdmulhD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2 +
                    ((int64_t)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            if (destElem < 0) {
                destElem = mask(sizeof(Element) * 8 - 1);
            } else {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            }
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrdmulhD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrdmulhQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[i]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2 +
                    ((int64_t)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            if (destElem < 0) {
                destElem = mask(sizeof(Element) * 8 - 1);
            } else {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            }
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
            
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrdmulhQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmaxDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMaxS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmaxDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmaxQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMaxS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmaxQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VminDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMinS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VminDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VminQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMinS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VminQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpmaxDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMaxS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpmaxDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpmaxQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMaxS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpmaxQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpminDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMinS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpminDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpminQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        bool done;
        destReg = processNans(fpscr, done, true, srcReg1, srcReg2);
        if (!done) {
            destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMinS,
                               true, true, VfpRoundNearest);
        } else if (flushToZero(srcReg1, srcReg2)) {
            fpscr.idc = 1;
        }
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpminQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VaddDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VaddDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VaddQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VaddQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpaddDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpaddDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VpaddQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = (2 * r < rCount) ?
                    srcRegs1[2 * r] : srcRegs2[2 * r - rCount];
                FloatReg srcReg2 = (2 * r < rCount) ?
                    srcRegs1[2 * r + 1] : srcRegs2[2 * r + 1 - rCount];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VpaddQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VsubDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VsubDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VsubQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VsubQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmulQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmulQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlaDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpscrExc = xc->readMiscRegOperand(this, 12);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                        destRegs[0] = FpDestP0;
                    
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                        destRegs[1] = FpDestP1;
                    
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                destReg = destRegs[r];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, mid, destReg, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 2, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlaDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlaQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpDestP2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
float FpDestP3 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpOp1P2 = xc->readFloatRegOperand(this, 12);
FpOp2P2 = xc->readFloatRegOperand(this, 13);
FpDestP2 = xc->readFloatRegOperand(this, 14);
FpOp1P3 = xc->readFloatRegOperand(this, 15);
FpOp2P3 = xc->readFloatRegOperand(this, 16);
FpDestP3 = xc->readFloatRegOperand(this, 17);
FpscrExc = xc->readMiscRegOperand(this, 18);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                        destRegs[0] = FpDestP0;
                    
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                        destRegs[1] = FpDestP1;
                    
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                        destRegs[2] = FpDestP2;
                    
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
                        destRegs[3] = FpDestP3;
                    
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                destReg = destRegs[r];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, mid, destReg, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlaQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlsDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpscrExc = xc->readMiscRegOperand(this, 12);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                        destRegs[0] = FpDestP0;
                    
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                        destRegs[1] = FpDestP1;
                    
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                destReg = destRegs[r];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, destReg, mid, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 2, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlsDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmlsQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpDestP2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
float FpDestP3 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpOp1P2 = xc->readFloatRegOperand(this, 12);
FpOp2P2 = xc->readFloatRegOperand(this, 13);
FpDestP2 = xc->readFloatRegOperand(this, 14);
FpOp1P3 = xc->readFloatRegOperand(this, 15);
FpOp2P3 = xc->readFloatRegOperand(this, 16);
FpDestP3 = xc->readFloatRegOperand(this, 17);
FpscrExc = xc->readMiscRegOperand(this, 18);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                        destRegs[0] = FpDestP0;
                    
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                        destRegs[1] = FpDestP1;
                    
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                        destRegs[2] = FpDestP2;
                    
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
                        destRegs[3] = FpDestP3;
                    
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                destReg = destRegs[r];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, destReg, mid, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmlsQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgtDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vcgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgtDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgtQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vcgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgtQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgeDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vcgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgeDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VcgeQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vcgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VcgeQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VacgtDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vacgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VacgtDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VacgtQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vacgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VacgtQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VacgeDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vacgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VacgeDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VacgeQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vacgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VacgeQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VceqDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vceqFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VceqDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VceqQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatRegBits destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, srcReg2, vceqFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
                destRegs.regs[r] = destReg;
            }
            
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VceqQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrecpsDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpRecpsS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrecpsDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrecpsQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpRecpsS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrecpsQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrsqrtsDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpRSqrtsS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrsqrtsDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VrsqrtsQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpRSqrtsS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VrsqrtsQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabdDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpSubS,
                             true, true, VfpRoundNearest);
        destReg = fabs(mid);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabdDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VabdQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
            for (unsigned r = 0; r < rCount; r++) {
                FloatReg srcReg1 = srcRegs1[r];
                FloatReg srcReg2 = srcRegs2[r];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpSubS,
                             true, true, VfpRoundNearest);
        destReg = fabs(mid);
        FpscrExc = fpscr;
    
                destRegs[r] = destReg;
            }
            
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VabdQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlasD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem + srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlasD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlasQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem + srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlasQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlasQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlasDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpscrExc = xc->readMiscRegOperand(this, 12);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                    destRegs[0] = FpDestP0;
                
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                    destRegs[1] = FpDestP1;
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                destReg = destRegs[i];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, mid, destReg, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 2, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlasDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlasQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpDestP2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
float FpDestP3 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpOp1P2 = xc->readFloatRegOperand(this, 12);
FpOp2P2 = xc->readFloatRegOperand(this, 13);
FpDestP2 = xc->readFloatRegOperand(this, 14);
FpOp1P3 = xc->readFloatRegOperand(this, 15);
FpOp2P3 = xc->readFloatRegOperand(this, 16);
FpDestP3 = xc->readFloatRegOperand(this, 17);
FpscrExc = xc->readMiscRegOperand(this, 18);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                    destRegs[0] = FpDestP0;
                
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                    destRegs[1] = FpDestP1;
                
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                    destRegs[2] = FpDestP2;
                
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
                    destRegs[3] = FpDestP3;
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                destReg = destRegs[i];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, mid, destReg, fpAddS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            
            FpDestP2 = destRegs[2];
            
            FpDestP3 = destRegs[3];
            ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlasQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmlals<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem + (BigElement)srcElem1 * (BigElement)srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmlals<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlals<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlals<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlals<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlals<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlals<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlssD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem - srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlssD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlssQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpDestP0 = xc->readFloatRegOperandBits(this, 8);
FpOp1P1 = xc->readFloatRegOperandBits(this, 9);
FpOp2P1 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpOp1P2 = xc->readFloatRegOperandBits(this, 12);
FpOp2P2 = xc->readFloatRegOperandBits(this, 13);
FpDestP2 = xc->readFloatRegOperandBits(this, 14);
FpOp1P3 = xc->readFloatRegOperandBits(this, 15);
FpOp2P3 = xc->readFloatRegOperandBits(this, 16);
FpDestP3 = xc->readFloatRegOperandBits(this, 17);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem - srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlssQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmlssQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlssDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpscrExc = xc->readMiscRegOperand(this, 12);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                    destRegs[0] = FpDestP0;
                
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                    destRegs[1] = FpDestP1;
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                destReg = destRegs[i];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, destReg, mid, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 2, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlssDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmlssQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpDestP0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpDestP1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpDestP2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
float FpDestP3 = 0;
uint32_t FpscrExc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpDestP0 = xc->readFloatRegOperand(this, 8);
FpOp1P1 = xc->readFloatRegOperand(this, 9);
FpOp2P1 = xc->readFloatRegOperand(this, 10);
FpDestP1 = xc->readFloatRegOperand(this, 11);
FpOp1P2 = xc->readFloatRegOperand(this, 12);
FpOp2P2 = xc->readFloatRegOperand(this, 13);
FpDestP2 = xc->readFloatRegOperand(this, 14);
FpOp1P3 = xc->readFloatRegOperand(this, 15);
FpOp2P3 = xc->readFloatRegOperand(this, 16);
FpDestP3 = xc->readFloatRegOperand(this, 17);
FpscrExc = xc->readMiscRegOperand(this, 18);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                    destRegs[0] = FpDestP0;
                
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                    destRegs[1] = FpDestP1;
                
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                    destRegs[2] = FpDestP2;
                
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
                    destRegs[3] = FpDestP3;
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                destReg = destRegs[i];
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        float mid = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                             true, true, VfpRoundNearest);
        destReg = binaryOp(fpscr, destReg, mid, fpSubS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            
            FpDestP2 = destRegs[2];
            
            FpDestP3 = destRegs[3];
            ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmlssQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmlsls<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                destElem = gtoh(destReg.elements[i]);
                
        destElem = destElem - (BigElement)srcElem1 * (BigElement)srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmlsls<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsls<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsls<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsls<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsls<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmlsls<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmulsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        destElem = srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmulsD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmulsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        destElem = srcElem1 * srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmulsQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VmulsQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmulsDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmulsDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VmulsQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp2P0 = 0;
float FpOp1P1 = 0;
float FpOp2P1 = 0;
float FpOp1P2 = 0;
float FpOp2P2 = 0;
float FpOp1P3 = 0;
float FpOp2P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp2P0 = xc->readFloatRegOperand(this, 7);
FpOp1P1 = xc->readFloatRegOperand(this, 8);
FpOp2P1 = xc->readFloatRegOperand(this, 9);
FpOp1P2 = xc->readFloatRegOperand(this, 10);
FpOp2P2 = xc->readFloatRegOperand(this, 11);
FpOp1P3 = xc->readFloatRegOperand(this, 12);
FpOp2P3 = xc->readFloatRegOperand(this, 13);
FpscrExc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1, srcRegs2, destRegs;
        
                srcRegs1[0] = FpOp1P0;
                srcRegs2[0] = FpOp2P0;
            
                srcRegs1[1] = FpOp1P1;
                srcRegs2[1] = FpOp2P1;
            
                srcRegs1[2] = FpOp1P2;
                srcRegs2[2] = FpOp2P2;
            
                srcRegs1[3] = FpOp1P3;
                srcRegs2[3] = FpOp2P3;
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < rCount; i++) {
                FloatReg srcReg1 = srcRegs1[i];
                FloatReg srcReg2 = srcRegs2[imm];
                FloatReg destReg;
                
                
        FPSCR fpscr = (FPSCR) FpscrExc;
        destReg = binaryOp(fpscr, srcReg1, srcReg2, fpMulS,
                           true, true, VfpRoundNearest);
        FpscrExc = fpscr;
    
                destRegs[i] = destReg;
            }
        }
        
            FpDestP0 = destRegs[0];
            
            FpDestP1 = destRegs[1];
            
            FpDestP2 = destRegs[2];
            
            FpDestP3 = destRegs[3];
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VmulsQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vmulls<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                
                
        destElem = (BigElement)srcElem1 * (BigElement)srcElem2;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vmulls<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmulls<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmulls<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmulls<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmulls<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vmulls<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmulls<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (Element)(sizeof(Element) * 8 - 1))) {
            destElem = ~((BigElement)srcElem1 << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmulls<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmulls<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmulls<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmulls<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmulls<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmulls<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmlals<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpscrQc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                destElem = gtoh(destReg.elements[i]);
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        BigElement midElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            midElem = ~((BigElement)maxNeg << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        bool negPreDest = ltz(destElem);
        destElem += midElem;
        bool negDest = ltz(destElem);
        bool negMid = ltz(midElem);
        if (negPreDest == negMid && negMid != negDest) {
            destElem = mask(sizeof(BigElement) * 8 - 1);
            if (negPreDest)
                destElem = ~destElem;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmlals<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlals<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlals<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlals<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlals<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlals<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault Vqdmlsls<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
uint32_t FpscrQc = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpDestP0 = xc->readFloatRegOperandBits(this, 10);
FpDestP1 = xc->readFloatRegOperandBits(this, 11);
FpDestP2 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);;
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);;
            
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                BigElement destElem;
                destElem = gtoh(destReg.elements[i]);
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        BigElement midElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            midElem = ~((BigElement)maxNeg << (sizeof(Element) * 8));
            fpscr.qc = 1;
        }
        bool negPreDest = ltz(destElem);
        destElem -= midElem;
        bool negDest = ltz(destElem);
        bool posMid = ltz((BigElement)-midElem);
        if (negPreDest == posMid && posMid != negDest) {
            destElem = mask(sizeof(BigElement) * 8 - 1);
            if (negPreDest)
                destElem = ~destElem;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }xc->setMiscRegOperand(this, 4, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault Vqdmlsls<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsls<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsls<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsls<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsls<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault Vqdmlsls<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqdmulhsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2) >>
                   (sizeof(Element) * 8);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (sizeof(Element) * 8 - 1))) {
            destElem = ~srcElem1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqdmulhsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqdmulhsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2) >>
                   (sizeof(Element) * 8);
        if (srcElem1 == srcElem2 &&
                srcElem1 == (Element)((Element)1 <<
                    (sizeof(Element) * 8 - 1))) {
            destElem = ~srcElem1;
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqdmulhsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqdmulhsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrdmulhsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2 +
                    ((int64_t)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            if (destElem < 0) {
                destElem = mask(sizeof(Element) * 8 - 1);
            } else {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            }
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrdmulhsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault VqrdmulhsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
FpscrQc = xc->readMiscRegOperand(this, 14);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, srcReg2, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
        if (imm < 0 && imm >= eCount) {
            if (FullSystem)
                fault = new UndefinedInstruction;
            else
                fault = new UndefinedInstruction(false, mnemonic);
        } else {
            for (unsigned i = 0; i < eCount; i++) {
                Element srcElem1 = gtoh(srcReg1.elements[i]);
                Element srcElem2 = gtoh(srcReg2.elements[imm]);
                Element destElem;
                
                
        FPSCR fpscr = (FPSCR) FpscrQc;
        destElem = (2 * (int64_t)srcElem1 * (int64_t)srcElem2 +
                    ((int64_t)1 << (sizeof(Element) * 8 - 1))) >>
                   (sizeof(Element) * 8);
        Element maxNeg = (Element)1 << (sizeof(Element) * 8 - 1);
        Element halfNeg = maxNeg / 2;
        if ((srcElem1 == maxNeg && srcElem2 == maxNeg) ||
            (srcElem1 == halfNeg && srcElem2 == maxNeg) ||
            (srcElem1 == maxNeg && srcElem2 == halfNeg)) {
            if (destElem < 0) {
                destElem = mask(sizeof(Element) * 8 - 1);
            } else {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
            }
            fpscr.qc = 1;
        }
        FpscrQc = fpscr;
    
                destReg.elements[i] = htog(destElem);
            }
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault VqrdmulhsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault VqrdmulhsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshrD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm >= sizeof(srcElem1) * 8) {
            if (ltz(srcElem1))
                destElem = -1;
            else
                destElem = 0;
        } else {
            destElem = srcElem1 >> imm;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshrD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshrQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm >= sizeof(srcElem1) * 8) {
            if (ltz(srcElem1))
                destElem = -1;
            else
                destElem = 0;
        } else {
            destElem = srcElem1 >> imm;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshrQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsraD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        Element mid;;
        if (imm >= sizeof(srcElem1) * 8) {
            mid = ltz(srcElem1) ? -1 : 0;
        } else {
            mid = srcElem1 >> imm;
            if (ltz(srcElem1) && !ltz(mid)) {
                mid |= -(mid & ((Element)1 <<
                            (sizeof(Element) * 8 - 1 - imm)));
            }
        }
        destElem += mid;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsraD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsraQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                    destRegs.regs[2] = htog(FpDestP2);
                
                srcRegs1.regs[3] = htog(FpOp1P3);
            
                    destRegs.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        Element mid;;
        if (imm >= sizeof(srcElem1) * 8) {
            mid = ltz(srcElem1) ? -1 : 0;
        } else {
            mid = srcElem1 >> imm;
            if (ltz(srcElem1) && !ltz(mid)) {
                mid |= -(mid & ((Element)1 <<
                            (sizeof(Element) * 8 - 1 - imm)));
            }
        }
        destElem += mid;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsraQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsraQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrshrD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm > sizeof(srcElem1) * 8) {
            destElem = 0;
        } else if (imm) {
            Element rBit = bits(srcElem1, imm - 1);
            destElem = ((srcElem1 >> (imm - 1)) >> 1) + rBit;
        } else {
            destElem = srcElem1;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrshrD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrshrQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm > sizeof(srcElem1) * 8) {
            destElem = 0;
        } else if (imm) {
            Element rBit = bits(srcElem1, imm - 1);
            destElem = ((srcElem1 >> (imm - 1)) >> 1) + rBit;
        } else {
            destElem = srcElem1;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrshrQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsraD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm > sizeof(srcElem1) * 8) {
            destElem += 0;
        } else if (imm) {
            Element rBit = bits(srcElem1, imm - 1);
            destElem += ((srcElem1 >> (imm - 1)) >> 1) + rBit;
        } else {
            destElem += srcElem1;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsraD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsraQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                    destRegs.regs[2] = htog(FpDestP2);
                
                srcRegs1.regs[3] = htog(FpOp1P3);
            
                    destRegs.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm > sizeof(srcElem1) * 8) {
            destElem += 0;
        } else if (imm) {
            Element rBit = bits(srcElem1, imm - 1);
            destElem += ((srcElem1 >> (imm - 1)) >> 1) + rBit;
        } else {
            destElem += srcElem1;
        }
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsraQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrsraQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsriD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm >= sizeof(Element) * 8)
            destElem = destElem;
        else
            destElem = (srcElem1 >> imm) |
                (destElem & ~mask(sizeof(Element) * 8 - imm));
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsriD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsriQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                    destRegs.regs[2] = htog(FpDestP2);
                
                srcRegs1.regs[3] = htog(FpOp1P3);
            
                    destRegs.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm >= sizeof(Element) * 8)
            destElem = destElem;
        else
            destElem = (srcElem1 >> imm) |
                (destElem & ~mask(sizeof(Element) * 8 - imm));
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsriQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsriQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshlD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm >= sizeof(Element) * 8)
            destElem = (srcElem1 << (sizeof(Element) * 8 - 1)) << 1;
        else
            destElem = srcElem1 << imm;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshlD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshlQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        if (imm >= sizeof(Element) * 8)
            destElem = (srcElem1 << (sizeof(Element) * 8 - 1)) << 1;
        else
            destElem = srcElem1 << imm;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshlQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshlQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsliD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm >= sizeof(Element) * 8)
            destElem = destElem;
        else
            destElem = (srcElem1 << imm) | (destElem & mask(imm));
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsliD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVsliQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                    destRegs.regs[0] = htog(FpDestP0);
                
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                    destRegs.regs[1] = htog(FpDestP1);
                
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                    destRegs.regs[2] = htog(FpDestP2);
                
                srcRegs1.regs[3] = htog(FpOp1P3);
            
                    destRegs.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            destElem = gtoh(destRegs.elements[i]);
            
        if (imm >= sizeof(Element) * 8)
            destElem = destElem;
        else
            destElem = (srcElem1 << imm) | (destElem & mask(imm));
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVsliQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVsliQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshlD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrQc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 != 0) {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
                if (srcElem1 > 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - 1 - imm);
            if (topBits != 0 && topBits != mask(imm + 1)) {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
                if (srcElem1 > 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshlD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshlQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 != 0) {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
                if (srcElem1 > 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - 1 - imm);
            if (topBits != 0 && topBits != mask(imm + 1)) {
                destElem = (Element)1 << (sizeof(Element) * 8 - 1);
                if (srcElem1 > 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshlQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshluD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrQc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - imm);
            if (topBits != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshluD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshluQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - imm);
            if (topBits != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshluQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshluQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshlusD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrQc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 < 0) {
                destElem = 0;
                fpscr.qc = 1;
            } else if (srcElem1 > 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - imm);
            if (srcElem1 < 0) {
                destElem = 0;
                fpscr.qc = 1;
            } else if (topBits != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            }
        } else {
            if (srcElem1 < 0) {
                fpscr.qc = 1;
                destElem = 0;
            } else {
                destElem = srcElem1;
            }
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshlusD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshlusQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm >= sizeof(Element) * 8) {
            if (srcElem1 < 0) {
                destElem = 0;
                fpscr.qc = 1;
            } else if (srcElem1 > 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = 0;
            }
        } else if (imm) {
            destElem = (srcElem1 << imm);
            uint64_t topBits = bits((uint64_t)srcElem1,
                                    sizeof(Element) * 8 - 1,
                                    sizeof(Element) * 8 - imm);
            if (srcElem1 < 0) {
                destElem = 0;
                fpscr.qc = 1;
            } else if (topBits != 0) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            }
        } else {
            if (srcElem1 < 0) {
                fpscr.qc = 1;
                destElem = 0;
            } else {
                destElem = srcElem1;
            }
        }
        FpscrQc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshlusQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshlusQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshrn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        if (imm >= sizeof(srcElem1) * 8) {
            destElem = 0;
        } else {
            destElem = srcElem1 >> imm;
        }
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshrn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshrn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrshrn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        if (imm > sizeof(srcElem1) * 8) {
            destElem = 0;
        } else if (imm) {
            Element rBit = bits(srcElem1, imm - 1);
            destElem = ((srcElem1 >> (imm - 1)) >> 1) + rBit;
        } else {
            destElem = srcElem1;
        }
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrshrn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrshrn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshrn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0 && srcElem1 != -1)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = ((srcElem1 >> (imm - 1)) >> 1);
            mid |= -(mid & ((BigElement)1 <<
                        (sizeof(BigElement) * 8 - 1 - imm)));
            if (mid != (Element)mid) {
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshrn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshrn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshrn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshrun<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = ((srcElem1 >> (imm - 1)) >> 1);
            if (mid != (Element)mid) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshrun<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshrun<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshrun<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqshruns<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = ((srcElem1 >> (imm - 1)) >> 1);
            if (bits(mid, sizeof(BigElement) * 8 - 1,
                          sizeof(Element) * 8) != 0) {
                if (srcElem1 < 0) {
                    destElem = 0;
                } else {
                    destElem = mask(sizeof(Element) * 8);
                }
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqshruns<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshruns<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqshruns<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqrshrn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0 && srcElem1 != -1)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = (srcElem1 >> (imm - 1));
            uint64_t rBit = mid & 0x1;
            mid >>= 1;
            mid |= -(mid & ((BigElement)1 <<
                        (sizeof(BigElement) * 8 - 1 - imm)));
            mid += rBit;
            if (mid != (Element)mid) {
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            if (srcElem1 != (Element)srcElem1) {
                destElem = mask(sizeof(Element) * 8 - 1);
                if (srcElem1 < 0)
                    destElem = ~destElem;
                fpscr.qc = 1;
            } else {
                destElem = srcElem1;
            }
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqrshrn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshrn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshrn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqrshrun<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = (srcElem1 >> (imm - 1));
            uint64_t rBit = mid & 0x1;
            mid >>= 1;
            mid += rBit;
            if (mid != (Element)mid) {
                destElem = mask(sizeof(Element) * 8);
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            if (srcElem1 != (Element)srcElem1) {
                destElem = mask(sizeof(Element) * 8 - 1);
                fpscr.qc = 1;
            } else {
                destElem = srcElem1;
            }
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqrshrun<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshrun<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshrun<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqrshruns<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (imm > sizeof(srcElem1) * 8) {
            if (srcElem1 != 0)
                fpscr.qc = 1;
            destElem = 0;
        } else if (imm) {
            BigElement mid = (srcElem1 >> (imm - 1));
            uint64_t rBit = mid & 0x1;
            mid >>= 1;
            mid |= -(mid & ((BigElement)1 <<
                            (sizeof(BigElement) * 8 - 1 - imm)));
            mid += rBit;
            if (bits(mid, sizeof(BigElement) * 8 - 1,
                          sizeof(Element) * 8) != 0) {
                if (srcElem1 < 0) {
                    destElem = 0;
                } else {
                    destElem = mask(sizeof(Element) * 8);
                }
                fpscr.qc = 1;
            } else {
                destElem = mid;
            }
        } else {
            if (srcElem1 < 0) {
                fpscr.qc = 1;
                destElem = 0;
            } else {
                destElem = srcElem1;
            }
        }
        FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqrshruns<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshruns<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqrshruns<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVshll<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement destElem;
            
            
        if (imm >= sizeof(destElem) * 8) {
            destElem = 0;
        } else {
            destElem = (BigElement)srcElem1 << imm;
        }
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVshll<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshll<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshll<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshll<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshll<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVshll<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmovl<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement destElem;
            
            
        destElem = srcElem1;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmovl<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovl<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovl<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovl<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovl<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovl<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvt2ufxD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcElem1))
            fpscr.idc = 1;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcElem1) : "m" (srcElem1));
        destReg = vfpFpSToFixed(srcElem1, false, false, imm);
        __asm__ __volatile__("" :: "m" (destReg));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.regs[i] = htog(destReg);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvt2ufxD<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvt2ufxQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcElem1))
            fpscr.idc = 1;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcElem1) : "m" (srcElem1));
        destReg = vfpFpSToFixed(srcElem1, false, false, imm);
        __asm__ __volatile__("" :: "m" (destReg));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.regs[i] = htog(destReg);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvt2ufxQ<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvt2sfxD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcElem1))
            fpscr.idc = 1;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcElem1) : "m" (srcElem1));
        destReg = vfpFpSToFixed(srcElem1, true, false, imm);
        __asm__ __volatile__("" :: "m" (destReg));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.regs[i] = htog(destReg);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvt2sfxD<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvt2sfxQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcRegs1.elements[i]);
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcElem1))
            fpscr.idc = 1;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcElem1) : "m" (srcElem1));
        destReg = vfpFpSToFixed(srcElem1, true, false, imm);
        __asm__ __volatile__("" :: "m" (destReg));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.regs[i] = htog(destReg);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvt2sfxQ<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvtu2fpD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            FloatRegBits srcReg1 = gtoh(srcRegs1.regs[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcReg1) : "m" (srcReg1));
        destElem = vfpUFixedToFpS(true, true, srcReg1, false, imm);
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvtu2fpD<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvtu2fpQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            FloatRegBits srcReg1 = gtoh(srcRegs1.regs[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcReg1) : "m" (srcReg1));
        destElem = vfpUFixedToFpS(true, true, srcReg1, false, imm);
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvtu2fpQ<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvts2fpD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            FloatRegBits srcReg1 = gtoh(srcRegs1.regs[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcReg1) : "m" (srcReg1));
        destElem = vfpSFixedToFpS(true, true, srcReg1, false, imm);
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvts2fpD<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvts2fpQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs1, destRegs;
        
                srcRegs1.regs[0] = htog(FpOp1P0);
            
                srcRegs1.regs[1] = htog(FpOp1P1);
            
                srcRegs1.regs[2] = htog(FpOp1P2);
            
                srcRegs1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            FloatRegBits srcReg1 = gtoh(srcRegs1.regs[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcReg1) : "m" (srcReg1));
        destElem = vfpSFixedToFpS(true, true, srcReg1, false, imm);
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destRegs.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destRegs.regs[0]);
            
            FpDestP1 = gtoh(destRegs.regs[1]);
            
            FpDestP2 = gtoh(destRegs.regs[2]);
            
            FpDestP3 = gtoh(destRegs.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvts2fpQ<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvts2h<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = 0;
        FPSCR fpscr = (FPSCR) FpscrExc;
        float srcFp1 = bitsToFp(srcElem1, (float)0.0);
        if (flushToZero(srcFp1))
            fpscr.idc = 1;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcFp1), "=m" (destElem)
                                : "m" (srcFp1), "m" (destElem));
        destElem = vcvtFpSFpH(fpscr, true, true, VfpRoundNearest,
                              fpscr.ahp, srcFp1);
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvts2h<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcvth2s<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1;
        BigRegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            BigElement destElem;
            
            
        destElem = 0;
        FPSCR fpscr = (FPSCR) FpscrExc;
        VfpSavedState state = prepFpState(VfpRoundNearest);
        __asm__ __volatile__("" : "=m" (srcElem1), "=m" (destElem)
                                : "m" (srcElem1), "m" (destElem));
        destElem = fpToBits(vcvtFpHFpS(fpscr, true, fpscr.ahp, srcElem1));
        __asm__ __volatile__("" :: "m" (destElem));
        finishVfp(fpscr, state, true);
        FpscrExc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcvth2s<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsqrteD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = unsignedRSqrtEstimate(srcElem1);
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsqrteD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsqrteQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = unsignedRSqrtEstimate(srcElem1);
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsqrteQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsqrteDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcReg1))
            fpscr.idc = 1;
        destReg = fprSqrtEstimate(fpscr, srcReg1);
        FpscrExc = fpscr;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsqrteDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrsqrteQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcReg1))
            fpscr.idc = 1;
        destReg = fprSqrtEstimate(fpscr, srcReg1);
        FpscrExc = fpscr;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrsqrteQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrecpeD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = unsignedRecipEstimate(srcElem1);
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrecpeD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrecpeQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = unsignedRecipEstimate(srcElem1);
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrecpeQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrecpeDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcReg1))
            fpscr.idc = 1;
        destReg = fpRecipEstimate(fpscr, srcReg1);
        FpscrExc = fpscr;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrecpeDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrecpeQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        if (flushToZero(srcReg1))
            fpscr.idc = 1;
        destReg = fpRecipEstimate(fpscr, srcReg1);
        FpscrExc = fpscr;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrecpeQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev16D<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 1) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev16D<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev16Q<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 1) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev16Q<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev32D<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 2) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev32D<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev32D<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev32Q<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 2) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev32Q<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev32Q<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev64D<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 3) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev64D<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev64D<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev64D<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVrev64Q<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = srcElem1;
        unsigned groupSize = ((1 << 3) / sizeof(Element));
        unsigned reverseMask = (groupSize - 1);
        j = i ^ reverseMask;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVrev64Q<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev64Q<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVrev64Q<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVpaddlD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs;
        BigRegVect destReg;
        
                srcRegs.regs[0] = htog(FpOp1P0);
            
                srcRegs.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount / 2; i++) {
            Element srcElem1 = gtoh(srcRegs.elements[2 * i]);
            Element srcElem2 = gtoh(srcRegs.elements[2 * i + 1]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVpaddlD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVpaddlQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs;
        BigRegVect destReg;
        
                srcRegs.regs[0] = htog(FpOp1P0);
            
                srcRegs.regs[1] = htog(FpOp1P1);
            
                srcRegs.regs[2] = htog(FpOp1P2);
            
                srcRegs.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount / 2; i++) {
            Element srcElem1 = gtoh(srcRegs.elements[2 * i]);
            Element srcElem2 = gtoh(srcRegs.elements[2 * i + 1]);
            BigElement destElem;
            
            
        destElem = (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVpaddlQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpaddlQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVpadalD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs;
        BigRegVect destReg;
        
                srcRegs.regs[0] = htog(FpOp1P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcRegs.regs[1] = htog(FpOp1P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount / 2; i++) {
            Element srcElem1 = gtoh(srcRegs.elements[2 * i]);
            Element srcElem2 = gtoh(srcRegs.elements[2 * i + 1]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        destElem += (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVpadalD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVpadalQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcRegs;
        BigRegVect destReg;
        
                srcRegs.regs[0] = htog(FpOp1P0);
            
                    destReg.regs[0] = htog(FpDestP0);
                
                srcRegs.regs[1] = htog(FpOp1P1);
            
                    destReg.regs[1] = htog(FpDestP1);
                
                srcRegs.regs[2] = htog(FpOp1P2);
            
                    destReg.regs[2] = htog(FpDestP2);
                
                srcRegs.regs[3] = htog(FpOp1P3);
            
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount / 2; i++) {
            Element srcElem1 = gtoh(srcRegs.elements[2 * i]);
            Element srcElem2 = gtoh(srcRegs.elements[2 * i + 1]);
            BigElement destElem;
            destElem = gtoh(destReg.elements[i]);
            
        destElem += (BigElement)srcElem1 + (BigElement)srcElem2;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVpadalQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVpadalQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVclsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        if (srcElem1 < 0) {
            srcElem1 <<= 1;
            while (srcElem1 < 0 && count < sizeof(Element) * 8 - 1) {
                count++;
                srcElem1 <<= 1;
            }
        } else {
            srcElem1 <<= 1;
            while (srcElem1 >= 0 && count < sizeof(Element) * 8 - 1) {
                count++;
                srcElem1 <<= 1;
            }
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVclsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVclsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        if (srcElem1 < 0) {
            srcElem1 <<= 1;
            while (srcElem1 < 0 && count < sizeof(Element) * 8 - 1) {
                count++;
                srcElem1 <<= 1;
            }
        } else {
            srcElem1 <<= 1;
            while (srcElem1 >= 0 && count < sizeof(Element) * 8 - 1) {
                count++;
                srcElem1 <<= 1;
            }
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVclsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclsQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVclzD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        while (srcElem1 >= 0 && count < sizeof(Element) * 8) {
            count++;
            srcElem1 <<= 1;
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVclzD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVclzQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        while (srcElem1 >= 0 && count < sizeof(Element) * 8) {
            count++;
            srcElem1 <<= 1;
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVclzQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVclzQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcntD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        while (srcElem1 && count < sizeof(Element) * 8) {
            count += srcElem1 & 0x1;
            srcElem1 >>= 1;
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcntD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcntQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        unsigned count = 0;
        while (srcElem1 && count < sizeof(Element) * 8) {
            count += srcElem1 & 0x1;
            srcElem1 >>= 1;
        }
        destElem = count;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcntQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcntQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmvnD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = ~srcElem1;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmvnD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmvnQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = ~srcElem1;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmvnQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqabsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrQc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (srcElem1 == (Element)((Element)1 << (sizeof(Element) * 8 - 1))) {
            fpscr.qc = 1;
            destElem = ~srcElem1;
        } else if (srcElem1 < 0) {
            destElem = -srcElem1;
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqabsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqabsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (srcElem1 == (Element)((Element)1 << (sizeof(Element) * 8 - 1))) {
            fpscr.qc = 1;
            destElem = ~srcElem1;
        } else if (srcElem1 < 0) {
            destElem = -srcElem1;
        } else {
            destElem = srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqabsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqabsQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqnegD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpscrQc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (srcElem1 == (Element)((Element)1 << (sizeof(Element) * 8 - 1))) {
            fpscr.qc = 1;
            destElem = ~srcElem1;
        } else {
            destElem = -srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqnegD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqnegQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        FPSCR fpscr = (FPSCR) FpscrQc;
        if (srcElem1 == (Element)((Element)1 << (sizeof(Element) * 8 - 1))) {
            fpscr.qc = 1;
            destElem = ~srcElem1;
        } else {
            destElem = -srcElem1;
        }
        FpscrQc = fpscr;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqnegQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqnegQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVabsD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        if (srcElem1 < 0) {
            destElem = -srcElem1;
        } else {
            destElem = srcElem1;
        }
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVabsD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVabsQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        if (srcElem1 < 0) {
            destElem = -srcElem1;
        } else {
            destElem = srcElem1;
        }
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVabsQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVabsQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVabsDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        union
        {
            uint32_t i;
            float f;
        } cStruct;
        cStruct.f = srcReg1;
        cStruct.i &= mask(sizeof(Element) * 8 - 1);
        destReg = cStruct.f;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVabsDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVabsQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        union
        {
            uint32_t i;
            float f;
        } cStruct;
        cStruct.f = srcReg1;
        cStruct.i &= mask(sizeof(Element) * 8 - 1);
        destReg = cStruct.f;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVabsQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVnegD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = -srcElem1;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVnegD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVnegQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
        destElem = -srcElem1;
    
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVnegQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVnegQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVnegDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        destReg = -srcReg1;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVnegDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVnegQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
float FpDestP0 = 0;
float FpDestP1 = 0;
float FpDestP2 = 0;
float FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        FloatVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatReg destReg;
            
            
        destReg = -srcReg1;
    
            destRegs[r] = destReg;
        }
        
                FpDestP0 = destRegs[0];
                
                FpDestP1 = destRegs[1];
                
                FpDestP2 = destRegs[2];
                
                FpDestP3 = destRegs[3];
                ;
            if (fault == NoFault)
            {
                
        {
            float final_val = FpDestP0;
            xc->setFloatRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP1;
            xc->setFloatRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP2;
            xc->setFloatRegOperand(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            float final_val = FpDestP3;
            xc->setFloatRegOperand(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVnegQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgtD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 > 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgtD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgtQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 > 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgtQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgtQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgtDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgtDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgtQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcgtFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgtQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgeD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 >= 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgeD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgeQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 >= 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgeQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcgeQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgeDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgeDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcgeQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcgeFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcgeQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVceqD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 == 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVceqD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVceqQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 == 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVceqQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVceqQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVceqDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vceqFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVceqDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVceqQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vceqFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVceqQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcleD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 <= 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcleD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcleQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 <= 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcleQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcleQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcleDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcleFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcleDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcleQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcleFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcleQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcltD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 < 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcltD<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltD<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltD<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltD<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcltQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned j = i;
            Element srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = (srcElem1 < 0) ? mask(sizeof(Element) * 8) : 0;
            destReg.elements[j] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcltQ<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltQ<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltQ<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVcltQ<int64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcltDFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpscrExc = xc->readMiscRegOperand(this, 8);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcltFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcltDFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVcltQFp<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
float FpOp1P0 = 0;
float FpOp1P1 = 0;
float FpOp1P2 = 0;
float FpOp1P3 = 0;
uint32_t FpscrExc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperand(this, 6);
FpOp1P1 = xc->readFloatRegOperand(this, 7);
FpOp1P2 = xc->readFloatRegOperand(this, 8);
FpOp1P3 = xc->readFloatRegOperand(this, 9);
FpscrExc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        typedef FloatReg FloatVect[rCount];
        FloatVect srcRegs1;
        RegVect destRegs;

                srcRegs1[0] = FpOp1P0;
            
                srcRegs1[1] = FpOp1P1;
            
                srcRegs1[2] = FpOp1P2;
            
                srcRegs1[3] = FpOp1P3;
            
        for (unsigned r = 0; r < rCount; r++) {
            FloatReg srcReg1 = srcRegs1[r];
            FloatRegBits destReg;
            
            
        FPSCR fpscr = (FPSCR) FpscrExc;
        float res = binaryOp(fpscr, srcReg1, (FloatReg)0.0, vcltFunc,
                             true, true, VfpRoundNearest);
        destReg = (res == 0) ? -1 : 0;
        if (res == 2.0)
            fpscr.ioc = 1;
        FpscrExc = fpscr;
    
            destRegs.regs[r] = destReg;
        }
        
                FpDestP0 = destRegs.regs[0];
                
                FpDestP1 = destRegs.regs[1];
                
                FpDestP2 = destRegs.regs[2];
                
                FpDestP3 = destRegs.regs[3];
                ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrExc);
if (traceData) { traceData->setData(FpscrExc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVcltQFp<float>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVswpD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
        FloatRegBits mid;
        for (unsigned r = 0; r < rCount; r++) {
            mid = srcReg1.regs[r];
            srcReg1.regs[r] = destReg.regs[r];
            destReg.regs[r] = mid;
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVswpD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVswpQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                destReg.regs[2] = htog(FpDestP2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                destReg.regs[3] = htog(FpDestP3);
            
        FloatRegBits mid;
        for (unsigned r = 0; r < rCount; r++) {
            mid = srcReg1.regs[r];
            srcReg1.regs[r] = destReg.regs[r];
            destReg.regs[r] = mid;
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            FpOp1P2 = gtoh(srcReg1.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            FpOp1P3 = gtoh(srcReg1.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P2;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P3;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVswpQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVtrnD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
        Element mid;
        for (unsigned i = 0; i < eCount; i += 2) {
            mid = srcReg1.elements[i];
            srcReg1.elements[i] = destReg.elements[i + 1];
            destReg.elements[i + 1] = mid;
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVtrnD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVtrnD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVtrnD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVtrnQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                destReg.regs[2] = htog(FpDestP2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                destReg.regs[3] = htog(FpDestP3);
            
        Element mid;
        for (unsigned i = 0; i < eCount; i += 2) {
            mid = srcReg1.elements[i];
            srcReg1.elements[i] = destReg.elements[i + 1];
            destReg.elements[i + 1] = mid;
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            FpOp1P2 = gtoh(srcReg1.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            FpOp1P3 = gtoh(srcReg1.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P2;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P3;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVtrnQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVtrnQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVtrnQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVuzpD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
        Element mid[eCount];
        memcpy(&mid, &srcReg1, sizeof(srcReg1));
        for (unsigned i = 0; i < eCount / 2; i++) {
            srcReg1.elements[i] = destReg.elements[2 * i + 1];
            srcReg1.elements[eCount / 2 + i] = mid[2 * i + 1];
            destReg.elements[i] = destReg.elements[2 * i];
        }
        for (unsigned i = 0; i < eCount / 2; i++) {
            destReg.elements[eCount / 2 + i] = mid[2 * i];
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVuzpD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVuzpQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                destReg.regs[2] = htog(FpDestP2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                destReg.regs[3] = htog(FpDestP3);
            
        Element mid[eCount];
        memcpy(&mid, &srcReg1, sizeof(srcReg1));
        for (unsigned i = 0; i < eCount / 2; i++) {
            srcReg1.elements[i] = destReg.elements[2 * i + 1];
            srcReg1.elements[eCount / 2 + i] = mid[2 * i + 1];
            destReg.elements[i] = destReg.elements[2 * i];
        }
        for (unsigned i = 0; i < eCount / 2; i++) {
            destReg.elements[eCount / 2 + i] = mid[2 * i];
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            FpOp1P2 = gtoh(srcReg1.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            FpOp1P3 = gtoh(srcReg1.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P2;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P3;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVuzpQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVuzpQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVzipD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
        Element mid[eCount];
        memcpy(&mid, &destReg, sizeof(destReg));
        for (unsigned i = 0; i < eCount / 2; i++) {
            destReg.elements[2 * i] = mid[i];
            destReg.elements[2 * i + 1] = srcReg1.elements[i];
        }
        for (int i = 0; i < eCount / 2; i++) {
            srcReg1.elements[2 * i] = mid[eCount / 2 + i];
            srcReg1.elements[2 * i + 1] = srcReg1.elements[eCount / 2 + i];
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVzipD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVzipQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpDestP0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpDestP1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpDestP2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpDestP3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
                destReg.regs[0] = htog(FpDestP0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
                destReg.regs[1] = htog(FpDestP1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
                destReg.regs[2] = htog(FpDestP2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
                destReg.regs[3] = htog(FpDestP3);
            
        Element mid[eCount];
        memcpy(&mid, &destReg, sizeof(destReg));
        for (unsigned i = 0; i < eCount / 2; i++) {
            destReg.elements[2 * i] = mid[i];
            destReg.elements[2 * i + 1] = srcReg1.elements[i];
        }
        for (int i = 0; i < eCount / 2; i++) {
            srcReg1.elements[2 * i] = mid[eCount / 2 + i];
            srcReg1.elements[2 * i + 1] = srcReg1.elements[eCount / 2 + i];
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            FpOp1P0 = gtoh(srcReg1.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            FpOp1P1 = gtoh(srcReg1.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            FpOp1P2 = gtoh(srcReg1.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            FpOp1P3 = gtoh(srcReg1.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpOp1P0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P2;
            xc->setFloatRegOperandBits(this, 4, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 5, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpOp1P3;
            xc->setFloatRegOperandBits(this, 6, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 7, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVzipQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVzipQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmovn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            destElem = srcElem1;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmovn<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovn<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVmovn<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVdupD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[imm]);
            Element destElem;
            
            destElem = srcElem1;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVdupD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupD<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupD<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVdupQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect srcReg1, destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            Element srcElem1 = gtoh(srcReg1.elements[imm]);
            Element destElem;
            
            destElem = srcElem1;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVdupQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupQ<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupQ<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVdupDGpr<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        RegVect destReg;
        for (unsigned i = 0; i < eCount; i++) {
            destReg.elements[i] = htog((Element)Op1);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVdupDGpr<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupDGpr<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupDGpr<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVdupQGpr<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Op1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
Op1 = 
        ((op1 == PCReg) ? readPC(xc) : xc->readIntRegOperand(this, 3))
    ;
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        RegVect destReg;
        for (unsigned i = 0; i < eCount; i++) {
            destReg.elements[i] = htog((Element)Op1);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVdupQGpr<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupQGpr<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVdupQGpr<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmoviD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            
            destElem = imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmoviD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmoviQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            
            destElem = imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmoviQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVorriD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            destElem = gtoh(destReg.elements[i]);
            destElem |= imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVorriD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVorriQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
FpDestP2 = xc->readFloatRegOperandBits(this, 8);
FpDestP3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            destElem = gtoh(destReg.elements[i]);
            destElem |= imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVorriQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmvniD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            
            destElem = ~imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmvniD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVmvniQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            
            destElem = ~imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVmvniQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVbiciD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            destElem = gtoh(destReg.elements[i]);
            destElem &= ~imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVbiciD<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVbiciQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpDestP0 = xc->readFloatRegOperandBits(this, 6);
FpDestP1 = xc->readFloatRegOperandBits(this, 7);
FpDestP2 = xc->readFloatRegOperandBits(this, 8);
FpDestP3 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        RegVect destReg;
        
                    destReg.regs[0] = htog(FpDestP0);
                
                    destReg.regs[1] = htog(FpDestP1);
                
                    destReg.regs[2] = htog(FpDestP2);
                
                    destReg.regs[3] = htog(FpDestP3);
                
        for (unsigned i = 0; i < eCount; i++) {
            Element destElem;
            destElem = gtoh(destReg.elements[i]);
            destElem &= ~imm;
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVbiciQ<uint64_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqmovn<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
    FPSCR fpscr = (FPSCR) FpscrQc;
    destElem = srcElem1;
    if ((BigElement)destElem != srcElem1) {
        fpscr.qc = 1;
        destElem = mask(sizeof(Element) * 8 - 1);
        if (srcElem1 < 0)
            destElem = ~destElem;
    }
    FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqmovn<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovn<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovn<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqmovun<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
    FPSCR fpscr = (FPSCR) FpscrQc;
    destElem = srcElem1;
    if ((BigElement)destElem != srcElem1) {
        fpscr.qc = 1;
        destElem = mask(sizeof(Element) * 8);
    }
    FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqmovun<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovun<uint16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovun<uint32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVqmovuns<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        typedef typename bigger_type_t<Element>::type BigElement;
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpscrQc = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp1P1 = xc->readFloatRegOperandBits(this, 7);
FpOp1P2 = xc->readFloatRegOperandBits(this, 8);
FpOp1P3 = xc->readFloatRegOperandBits(this, 9);
FpscrQc = xc->readMiscRegOperand(this, 10);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
            BigElement bigElements[eCount / 2];
        };

        union BigRegVect {
            FloatRegBits regs[2 * rCount];
            BigElement elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
        BigRegVect srcReg1;
        RegVect destReg;
        
                srcReg1.regs[0] = htog(FpOp1P0);
            
                srcReg1.regs[1] = htog(FpOp1P1);
            
                srcReg1.regs[2] = htog(FpOp1P2);
            
                srcReg1.regs[3] = htog(FpOp1P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            BigElement srcElem1 = gtoh(srcReg1.elements[i]);
            Element destElem;
            
            
    FPSCR fpscr = (FPSCR) FpscrQc;
    destElem = srcElem1;
    if (srcElem1 < 0 ||
            ((BigElement)destElem & mask(sizeof(Element) * 8)) != srcElem1) {
        fpscr.qc = 1;
        destElem = mask(sizeof(Element) * 8);
        if (srcElem1 < 0)
            destElem = ~destElem;
    }
    FpscrQc = fpscr;
    
            destReg.elements[i] = htog(destElem);
        }
        
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                xc->setMiscRegOperand(this, 0, FpscrQc);
if (traceData) { traceData->setData(FpscrQc); }
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVqmovuns<int8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovuns<int16_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template
    Fault NVqmovuns<int32_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVextD<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
;

        const unsigned rCount = 2;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        RegVect srcReg1, srcReg2, destReg;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned index = i + imm;
            if (index < eCount) {
                destReg.elements[i] = srcReg1.elements[index];
            } else {
                index -= eCount;
                if (index >= eCount) {
                    if (FullSystem)
                        fault = new UndefinedInstruction;
                    else
                        fault = new UndefinedInstruction(false, mnemonic);
                } else {
                    destReg.elements[i] = srcReg2.elements[index];
                }
            }
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVextD<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    template <class Element>
    Fault NVextQ<Element>::execute(O3DynInst *xc,
            Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint32_t Cpsr = 0;
uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t Cpacr = 0;
uint32_t Fpexc = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp2P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp2P3 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpDestP2 = 0;
uint32_t FpDestP3 = 0;
;
        Cpsr = xc->readMiscRegOperand(this, 0);
OptCondCodesNZ = xc->readIntRegOperand(this, 1);
OptCondCodesC = xc->readIntRegOperand(this, 2);
OptCondCodesV = xc->readIntRegOperand(this, 3);
Cpacr = xc->readMiscRegOperand(this, 4);
Fpexc = xc->readMiscRegOperand(this, 5);
FpOp1P0 = xc->readFloatRegOperandBits(this, 6);
FpOp2P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp2P1 = xc->readFloatRegOperandBits(this, 9);
FpOp1P2 = xc->readFloatRegOperandBits(this, 10);
FpOp2P2 = xc->readFloatRegOperandBits(this, 11);
FpOp1P3 = xc->readFloatRegOperandBits(this, 12);
FpOp2P3 = xc->readFloatRegOperandBits(this, 13);
;

        const unsigned rCount = 4;
        const unsigned eCount = rCount * sizeof(FloatRegBits) / sizeof(Element);

        union RegVect {
            FloatRegBits regs[rCount];
            Element elements[eCount];
        };

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        RegVect srcReg1, srcReg2, destReg;
        
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[0] = htog(FpOp1P0);
                srcReg2.regs[0] = htog(FpOp2P0);
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[1] = htog(FpOp1P1);
                srcReg2.regs[1] = htog(FpOp2P1);
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[2] = htog(FpOp1P2);
                srcReg2.regs[2] = htog(FpOp2P2);
            
        if (!neonEnabled(Cpacr, Cpsr, Fpexc))
            return disabledFault();
    
                srcReg1.regs[3] = htog(FpOp1P3);
                srcReg2.regs[3] = htog(FpOp2P3);
            
        for (unsigned i = 0; i < eCount; i++) {
            unsigned index = i + imm;
            if (index < eCount) {
                destReg.elements[i] = srcReg1.elements[index];
            } else {
                index -= eCount;
                if (index >= eCount) {
                    if (FullSystem)
                        fault = new UndefinedInstruction;
                    else
                        fault = new UndefinedInstruction(false, mnemonic);
                } else {
                    destReg.elements[i] = srcReg2.elements[index];
                }
            }
        }
    
            FpDestP0 = gtoh(destReg.regs[0]);
            
            FpDestP1 = gtoh(destReg.regs[1]);
            
            FpDestP2 = gtoh(destReg.regs[2]);
            
            FpDestP3 = gtoh(destReg.regs[3]);
            ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP2;
            xc->setFloatRegOperandBits(this, 2, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP3;
            xc->setFloatRegOperandBits(this, 3, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    template
    Fault NVextQ<uint8_t>::execute(
            O3DynInst *, Trace::InstRecord *) const;

    Fault NVtbl1::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 1;
            const bool isVtbl = true;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = 0;
table.regs[3] = 0;
table.regs[4] = 0;
table.regs[5] = 0;
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbl2::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 2;
            const bool isVtbl = true;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = 0;
table.regs[5] = 0;
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbl3::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
FpOp1P4 = xc->readFloatRegOperandBits(this, 11);
FpOp1P5 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 3;
            const bool isVtbl = true;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = htog(FpOp1P4);
table.regs[5] = htog(FpOp1P5);
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbl4::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
uint32_t FpOp1P6 = 0;
uint32_t FpOp1P7 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
FpOp1P4 = xc->readFloatRegOperandBits(this, 11);
FpOp1P5 = xc->readFloatRegOperandBits(this, 12);
FpOp1P6 = xc->readFloatRegOperandBits(this, 13);
FpOp1P7 = xc->readFloatRegOperandBits(this, 14);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 4;
            const bool isVtbl = true;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = htog(FpOp1P4);
table.regs[5] = htog(FpOp1P5);
table.regs[6] = htog(FpOp1P6);
table.regs[7] = htog(FpOp1P7);

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbx1::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 1;
            const bool isVtbl = false;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = 0;
table.regs[3] = 0;
table.regs[4] = 0;
table.regs[5] = 0;
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbx2::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 2;
            const bool isVtbl = false;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = 0;
table.regs[5] = 0;
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbx3::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
FpOp1P4 = xc->readFloatRegOperandBits(this, 11);
FpOp1P5 = xc->readFloatRegOperandBits(this, 12);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 3;
            const bool isVtbl = false;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = htog(FpOp1P4);
table.regs[5] = htog(FpOp1P5);
table.regs[6] = 0;
table.regs[7] = 0;

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault NVtbx4::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t FpOp2P0 = 0;
uint32_t FpOp2P1 = 0;
uint32_t FpDestP0 = 0;
uint32_t FpDestP1 = 0;
uint32_t FpOp1P0 = 0;
uint32_t FpOp1P1 = 0;
uint32_t FpOp1P2 = 0;
uint32_t FpOp1P3 = 0;
uint32_t FpOp1P4 = 0;
uint32_t FpOp1P5 = 0;
uint32_t FpOp1P6 = 0;
uint32_t FpOp1P7 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
FpOp2P0 = xc->readFloatRegOperandBits(this, 3);
FpOp2P1 = xc->readFloatRegOperandBits(this, 4);
FpDestP0 = xc->readFloatRegOperandBits(this, 5);
FpDestP1 = xc->readFloatRegOperandBits(this, 6);
FpOp1P0 = xc->readFloatRegOperandBits(this, 7);
FpOp1P1 = xc->readFloatRegOperandBits(this, 8);
FpOp1P2 = xc->readFloatRegOperandBits(this, 9);
FpOp1P3 = xc->readFloatRegOperandBits(this, 10);
FpOp1P4 = xc->readFloatRegOperandBits(this, 11);
FpOp1P5 = xc->readFloatRegOperandBits(this, 12);
FpOp1P6 = xc->readFloatRegOperandBits(this, 13);
FpOp1P7 = xc->readFloatRegOperandBits(this, 14);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
            union
            {
                uint8_t bytes[32];
                FloatRegBits regs[8];
            } table;
            union
            {
                uint8_t bytes[8];
                FloatRegBits regs[2];
            } destReg, srcReg2;
            const unsigned length = 4;
            const bool isVtbl = false;
            srcReg2.regs[0] = htog(FpOp2P0);
            srcReg2.regs[1] = htog(FpOp2P1);
            destReg.regs[0] = htog(FpDestP0);
            destReg.regs[1] = htog(FpDestP1);
        table.regs[0] = htog(FpOp1P0);
table.regs[1] = htog(FpOp1P1);
table.regs[2] = htog(FpOp1P2);
table.regs[3] = htog(FpOp1P3);
table.regs[4] = htog(FpOp1P4);
table.regs[5] = htog(FpOp1P5);
table.regs[6] = htog(FpOp1P6);
table.regs[7] = htog(FpOp1P7);

        for (unsigned i = 0; i < sizeof(destReg); i++) {
            uint8_t index = srcReg2.bytes[i];
            if (index < 8 * length) {
                destReg.bytes[i] = table.bytes[index];
            } else {
                if (isVtbl)
                    destReg.bytes[i] = 0;
                // else destReg.bytes[i] unchanged
            }
        }
        FpDestP0 = gtoh(destReg.regs[0]);
        FpDestP1 = gtoh(destReg.regs[1]);
        ;
            if (fault == NoFault)
            {
                
        {
            uint32_t final_val = FpDestP0;
            xc->setFloatRegOperandBits(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        {
            uint32_t final_val = FpDestP1;
            xc->setFloatRegOperandBits(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    uint64_t join32to64(uint32_t r1, uint32_t r0);
    
    Fault Arm::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::arm(xc->tcBase());
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Quiesce::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::quiesce(xc->tcBase());
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
            PseudoInst::quiesceSkip(xc->tcBase());
        }

        return fault;
    }

    Fault QuiesceNs::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::quiesceNs(xc->tcBase(), join32to64(R1, R0));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
            PseudoInst::quiesceSkip(xc->tcBase());
        }

        return fault;
    }

    Fault QuiesceCycles::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::quiesceCycles(xc->tcBase(), join32to64(R1, R0));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
            PseudoInst::quiesceSkip(xc->tcBase());
        }

        return fault;
    }

    Fault QuiesceTime::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R0 = 0;
uint32_t R1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t qt_val = PseudoInst::quiesceTime(xc->tcBase());
    R0 = bits(qt_val, 31, 0);
    R1 = bits(qt_val, 63, 32);
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = R1;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Rpns::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R0 = 0;
uint32_t R1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t rpns_val = PseudoInst::rpns(xc->tcBase());
    R0 = bits(rpns_val, 31, 0);
    R1 = bits(rpns_val, 63, 32);
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = R1;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault WakeCPU::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::wakeCPU(xc->tcBase(), join32to64(R1,R0));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Deprecated_ivlb::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            warn_once("Obsolete M5 ivlb instruction encountered.\n");;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Deprecated_ivle::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            warn_once("Obsolete M5 ivle instruction encountered.\n");;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Deprecated_exit::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        warn_once("Obsolete M5 exit instruction encountered.\n");
        PseudoInst::m5exit(xc->tcBase(), 0);
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5exit::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        PseudoInst::m5exit(xc->tcBase(), join32to64(R1, R0));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5fail::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
        PseudoInst::m5fail(xc->tcBase(), join32to64(R1, R0), join32to64(R3, R2));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Loadsymbol::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::loadsymbol(xc->tcBase());
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Initparam::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R0 = 0;
uint32_t R1 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    uint64_t ip_val  = PseudoInst::initParam(xc->tcBase());
    R0 = bits(ip_val, 31, 0);
    R1 = bits(ip_val, 63, 32);
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        }
        
        {
            uint32_t final_val = R1;
            xc->setIntRegOperand(this, 1, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Resetstats::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::resetstats(xc->tcBase(), join32to64(R1, R0), join32to64(R3, R2));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Dumpstats::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::dumpstats(xc->tcBase(), join32to64(R1, R0), join32to64(R3, R2));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault Dumpresetstats::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::dumpresetstats(xc->tcBase(), join32to64(R1, R0), join32to64(R3, R2));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5checkpoint::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::m5checkpoint(xc->tcBase(), join32to64(R1, R0), join32to64(R3, R2));
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5readfile::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R0 = xc->readIntRegOperand(this, 3);
R3 = xc->readIntRegOperand(this, 4);
R2 = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    int n = 4;
    uint64_t offset = getArgument(xc->tcBase(), n, sizeof(uint64_t), false);
    R0 = PseudoInst::readfile(xc->tcBase(), R0, join32to64(R3,R2), offset);
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5writefile::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R0 = xc->readIntRegOperand(this, 3);
R3 = xc->readIntRegOperand(this, 4);
R2 = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    int n = 4;
    uint64_t offset = getArgument(xc->tcBase(), n, sizeof(uint64_t), false);
    n = 6;
    Addr filenameAddr = getArgument(xc->tcBase(), n, sizeof(Addr), false);
    R0 = PseudoInst::writefile(xc->tcBase(), R0, join32to64(R3,R2), offset,
                                filenameAddr);
    ;
            if (fault == NoFault)
            {
                
        
        {
            uint32_t final_val = R0;
            xc->setIntRegOperand(this, 0, final_val);

            if (traceData) { traceData->setData(final_val); }
        };
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5break::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            PseudoInst::debugbreak(xc->tcBase());;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5switchcpu::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            PseudoInst::switchcpu(xc->tcBase());;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5addsymbol::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R2 = xc->readIntRegOperand(this, 5);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            
    PseudoInst::addsymbol(xc->tcBase(), join32to64(R1, R0), R2);
    ;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5panic::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            panic("M5 panic instruction called at pc=%#x.",
                     xc->pcState().pc());;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5workbegin::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            PseudoInst::workbegin(
                          xc->tcBase(),
                          join32to64(R1, R0),
                          join32to64(R3, R2)
                      );;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault M5workend::execute(O3DynInst *xc, Trace::InstRecord *traceData) const
    {
        Fault fault = NoFault;
        uint64_t resTemp = 0;
        resTemp = resTemp;
        uint32_t OptCondCodesNZ = 0;
uint32_t OptCondCodesC = 0;
uint32_t OptCondCodesV = 0;
uint32_t R1 = 0;
uint32_t R0 = 0;
uint32_t R3 = 0;
uint32_t R2 = 0;
;
        OptCondCodesNZ = xc->readIntRegOperand(this, 0);
OptCondCodesC = xc->readIntRegOperand(this, 1);
OptCondCodesV = xc->readIntRegOperand(this, 2);
R1 = xc->readIntRegOperand(this, 3);
R0 = xc->readIntRegOperand(this, 4);
R3 = xc->readIntRegOperand(this, 5);
R2 = xc->readIntRegOperand(this, 6);
;

        if (testPredicate(OptCondCodesNZ, OptCondCodesC, OptCondCodesV, condCode))
        {
            PseudoInst::workend(
                        xc->tcBase(),
                        join32to64(R1, R0),
                        join32to64(R3, R2)
                    );;
            if (fault == NoFault)
            {
                ;
            }
        } else {
            xc->setPredicate(false);
        }

        return fault;
    }

    Fault
    FailUnimplemented::execute(O3DynInst *xc,
                               Trace::InstRecord *traceData) const
    {
        if (FullSystem)
            return new UndefinedInstruction;
        else
            return new UndefinedInstruction(machInst, false, mnemonic);
    }

    Fault
    WarnUnimplemented::execute(O3DynInst *xc,
                               Trace::InstRecord *traceData) const
    {
        if (!warned) {
            warn("\tinstruction '%s' unimplemented\n", mnemonic);
            warned = true;
        }

        return NoFault;
    }

    Fault
    FlushPipeInst::execute(O3DynInst *xc,
                           Trace::InstRecord *traceData) const
    {
        return new FlushPipe();
    }

    Fault
    Breakpoint::execute(O3DynInst *xc,
                     Trace::InstRecord *traceData) const
    {
        return new PrefetchAbort(xc->pcState().pc(), ArmFault::DebugEvent);
    }

// ArmUnconditional::armUnconditional(([], {}))

// ArmMultAndMultAcc::armMultAndMultAcc(([], {}))

// ArmSyncMem::armSyncMem(([], {}))

// Unknown::unknown(([], {}))

// AddrMode3::addrMode3(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcReg::armDataProcReg(([], {}))

// ArmMsrMrs::armMsrMrs(([], {}))

// ArmBxClz::armBxClz(([], {}))

// ArmBlxReg::armBlxReg(([], {}))

// Unknown::unknown(([], {}))

// ArmSatAddSub::armSatAddSub(([], {}))

// Breakpoint::bkpt(([], {}))

// Unknown::unknown(([], {}))

// ArmHalfWordMultAndMultAcc::armHalfWordMultAndMultAcc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmDataProcImm::armDataProcImm(([], {}))

// ArmMisc::armMisc(([], {}))

// Unknown::unknown(([], {}))

// AddrMode2::addrMode2((['True'], {}))

// AddrMode2::addrMode2((['False'], {}))

// ArmParallelAddSubtract::armParallelAddSubtract(([], {}))

// ArmPackUnpackSatReverse::armPackUnpackSatReverse(([], {}))

// ArmSignedMultiplies::armSignedMultiplies(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// ArmMiscMedia::armMiscMedia(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// ArmBBlxImm::armBBlxImm(([], {}))

// ArmBlBlxImm::armBlBlxImm(([], {}))

// Unknown::unknown(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStore(([], {}))

// Unknown::unknown(([], {}))

// VfpData::vfpData(([], {}))

// Unknown::unknown(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Svc::svc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb16ShiftAddSubMoveCmp::thumb16ShiftAddMoveCmp(([], {}))

// Thumb16DataProcessing::thumb16DataProcessing(([], {}))

// Thumb16SpecDataAndBx::thumb16SpecDataAndBx(([], {}))

// Thumb16MemLit::thumb16MemLit(([], {}))

// Thumb16MemReg::thumb16MemReg(([], {}))

// Thumb16MemImm::thumb16MemImm(([], {}))

// Thumb16Adr::thumb16Adr(([], {}))

// Thumb16AddSp::thumb16AddSp(([], {}))

// Thumb16Misc::thumb16Misc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16MacroMem::thumb16MacroMem(([], {}))

// Thumb16CondBranchAndSvc::thumb16CondBranchAndSvc(([], {}))

// Unknown::unknown(([], {}))

// Thumb16UncondBranch::thumb16UncondBranch(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32SrsRfe::thumb32SrsRfe(([], {}))

// ArmMacroMem::armMacroMem(([], {}))

// Thumb32LdrStrDExTbh::thumb32LdrStrDExTbh(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcShiftReg::thumb32DataProcShiftReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::ThumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32DataProcModImm::thumb32DataProcModImm(([], {}))

// Thumb32DataProcPlainBin::thumb32DataProcPlainBin(([], {}))

// Unknown::unknown(([], {}))

// Thumb32BranchesAndMiscCtrl::thumb32BranchesAndMiscCtrl(([], {}))

// Unknown::unknown(([], {}))

// Thumb32StoreSingle::thumb32StoreSingle(([], {}))

// ThumbNeonMem::thumbNeonMem(([], {}))

// Unknown::unknown(([], {}))

// LoadByteMemoryHints::loadByteMemoryHints(([], {}))

// LoadHalfwordMemoryHints::loadHalfwordMemoryHints(([], {}))

// Thumb32LoadWord::thumb32LoadWord(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Thumb32MulMulAccAndAbsDiff::thumb32MulMulAccAndAbsDiff(([], {}))

// Thumb32LongMulMulAccAndDiv::thumb32LongMulMulAccAndDiv(([], {}))

// Thumb32DataProcReg::thumb32DataProcReg(([], {}))

// VfpData::vfpData(([], {}))

// WarnUnimpl::cdp(([], {}))

// M5ops::m5ops(([], {}))

// ShortFpTransfer::shortFpTransfer(([], {}))

// McrMrc14::mcrMrc14(([], {}))

// McrMrc15::mcrMrc15(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// ThumbNeonData::thumbNeonData(([], {}))

// ExtensionRegLoadStore::extensionRegLoadStre(([], {}))

// Unknown::undefined(([], {}))

// WarnUnimpl::mcrr(([], {}))

// WarnUnimpl::mrrc(([], {}))

// WarnUnimpl::stc(([], {}))

// WarnUnimpl::ldc(([], {}))

// WarnUnimpl::ldc(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))


} // namespace ArmISAInst


